*  Seaside#+STARTUP: content align#+FILETAGS: :programming:#+TAGS:pharo:squeak:nocomment:important:** Introduction #+BEGIN_EXAMPLEWorking Notes of an "in depth" study of the Seaside guts and patterns.#+END_EXAMPLE** JSCore*** JSJoin*** JSJson*** JSLogger*** JSScript#+BEGIN_EXAMPLEJSObject subclass: #JSScriptI represent a sequence of JavaScript statements.#+END_EXAMPLE*** JSFunction** JSDecoration** JQuery** JQ** JQAjax** JQWidget** Brush#+BEGIN_EXAMPLEWAObject subclass: #WABrushI represent a brush to be used on a *WACanvas*.Instance Variables	canvas:		The canvas instance I am used with.	parent:		The parent brush I am used within.	closed:		Wether I have been closed/flushed yet.I have three immediate subclasses:WACompoundWAJsonBrushWATagBrush#+END_EXAMPLE*** WACompund#+BEGIN_EXAMPLEWABrush subclass: #WACompoundI am the superclass for stuff that is not html element but you still want to access via the canvas API.I have two subclasses and do not appear to be very popular.#+END_EXAMPLE*** WAJsonBrush#+BEGIN_EXAMPLEWABrush subclass: #WAJsonBrushA brush to generate JSON#+END_EXAMPLE*** WAJsonArrayBrush#+BEGIN_EXAMPLEWAJsonBrush subclass: #WAJsonArrayBrushBrush for a JSON array#+END_EXAMPLE*** WAJsonElementBrush#+BEGIN_EXAMPLEWAJsonBrush subclass: #WAJsonElementBrushAbstract superclass for JSON elements#+END_EXAMPLE*** WAJsonKeyValueBrush#+BEGIN_EXAMPLEWAJsonElementBrush subclass: #WAJsonKeyValueBrushA JSON key value#+END_EXAMPLE*** WAJsonValueBrush#+BEGIN_EXAMPLEWAJsonElementBrush subclass: #WAJsonValueBrushA JSON value#+END_EXAMPLE*** WAJsonObjectBrush#+BEGIN_EXAMPLEWAJsonBrush subclass: #WAJsonObjectBrushA brush to generate a JSON object#+END_EXAMPLE*** WATagBrush#+BEGIN_EXAMPLEWABrush subclass: #WATagBrushThis is the superclass for all XML element classes. Its main additions are- element name (#tag)- attributes (instance of WAHtmlAttributes)- common events (onXXX), this is a hack and would better be solved with traitsMy subclasses are:WAAnchorTag WABasicFormTag WABreakTag WACanvasTag WACollectionTag WACommandTag WADetailsTag WAEmbedTag WAEventSourceTag WAFieldSetTag WAFormInputTag WAGenericTag WAHeadingTag WAHorizontalRuleTag WAIframeTag WAImageTag WAKeyGeneratorTag WALabelTag WAMediaElementTag WAMenuTag WAMeterTag WAObjectTag WAOptionGroupTag WAOptionTag WAOptionalBreakTag WAOutputTag WAParameterTag WAProgressTag WARubyTextTag WAScriptTag WASourceTag WATableCellTag WATableTag WATimeTag WATrackTag WAImageMapTag WAPopupAnchorTag WAFormTag WADatalistTag WAListTag WASelectTag WAAbstractTextAreaTag WAButtonTag WACheckboxTag WAFileUploadTag WAHiddenInputTag WARadioButtonTag WASubmitButtonTag WAEditTag ZurbIFrameTag WAAudioTag WAVideoTag WATableColumnGroupTag WATableDataTag WAOrderedListTag WAUnorderedListTag WAMultiSelectTag WAColorInputTag WAEmailInputTag WASearchInputTag WASteppedTag WATelephoneInputTag WATextAreaTag WATextInputTag WAUrlInputTag WACancelButtonTag WAImageButtonTag WATableColumnTag WATableHeadingTag WAClosedRangeTag WADateInputTag WADateTimeInputTag WADateTimeLocalInputTag WAMonthInputTag WAWeekInputTag WAPasswordInputTag WANumberInputTag WARangeInputTag WATimeInputTagWith the Zurb framework, I includeZurbAnchorTag ZurbArticleTag ZurbButtonTag ZurbCalloutTag ZurbCellTag ZurbCloseButtonTag ZurbDivTag ZurbFieldSetTag ZurbFlexGridTag ZurbFloatGridTag ZurbFooterTag ZurbGenericButtonTag ZurbListItemTag ZurbMenuTag ZurbNavTag ZurbResetButtonTag ZurbSpanTag ZurbSubmitButtonTag ZurbTableTag ZurbTabsTag #+END_EXAMPLE** Builder#+BEGIN_EXAMPLEThis is a convenience class which provides a result of a rendering operation as a string. It is expected to be used like this:WAHtmlCanvas builder render: [ :html |	html anchor		url: 'htttp://www.seaside.st';		with: 'Seaside Homepage' ]See WABuilderCanvasTest for more examples.#+END_EXAMPLE** Cache*** WACache#+BEGIN_EXAMPLEWAObject subclass: #WACacheWACacheis the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCache.>>keySize returns 16All other instance methods implement self subclassResponsibility#+END_EXAMPLE***  WABidirectionalCache#+BEGIN_EXAMPLEWACache subclass: #WABidirectionalCacheI support key -> value and value -> key mappings and never forget anything.I also implement serveral methods of Dictionary.#+END_EXAMPLE*** WAPredictableCache#+BEGIN_EXAMPLEWABidirectionalCache subclass: #WAPredictableCacheA WAPredictableCache is a WACache that uses incrementing numbers as cache keys. This way the keys are predictable. This is useful for tests.#+END_EXAMPLE***  WAExpiringCache#+BEGIN_EXAMPLEWACache subclass: #WAExpiringCacheI am the abstract base class for caches that remove entries. Subclasses are intended to use to track sessions.    Instance Variables	maximumSize			<Integer>	maximumRelativeAge		<Integer>	maximumAbsoluteAge	<Integer>	overflowAction			<Symbol>				maximumSize:	Number of sessions supported. When this limit is reached the overflow action is run. 0 for no maximum size. Has to be positive.maximumRelativeAge:	After so many seconds of inactivity a session is considered expired. 0 for no limit. Has to be positive.maximumAbsoluteAge:	After so many seconds after its creation a session is considered expired no matter when it was last accessed. 0 for no limit. Has to be positive.overflowAction:	What to do when the maximum number of sessions is reached. Only matters when the maximum size is bigger than 0.	Possible values:		#removeRelativeOldest remove the entry that hasn't been accessed for the longest time		#removeAbsoluteOldest remove the entry that has been created the longest time ago		#signalError signal WAMaximumNumberOfSessionsExceededError#+END_EXAMPLE***  WABulkReapingCache#+BEGIN_EXAMPLEWAExpiringCache subclass: #WABulkReapingCacheI am a cache that reaps all elements at once instead of incrementally.I am intended to be used in GemStone/S instead of WAHashCache. A background process should send #reap to me.    Instance Variables	dictionary:		<Dictionary>#+END_EXAMPLE***  WAHashCache#+BEGIN_EXAMPLEWAExpiringCache subclass: #WAHashCacheWAHashCache is a hash table based implementation of WACache.The characteristics of WAHashCache are:- supports both absolute and relative timeouts at the same time https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration- supports a maximum size with definable overflow action (expire oldest, expire least recently used, signal exception)- access by key is fast (O(1) average case O(n) worst case)- reaping expired sessions is proportional (O(n)) to the number of expired session and independent of the total number of sessions (O(1))- creating a new session independent of the total number of sessions- does not guard against hash collision attacks, you should not use user generated keysInstance Variables:	keyTable 				<Array<WACacheKeyEntry>>	size					<Integer>	byAccessStart			<WACacheListEntry>	byAccessEnd			<WACacheListEntry>	byCreationStart		<WACacheListEntry>	byCreationEnd			<WACacheListEntry>keyTable:	Open hash table of  WACacheKeyEntrybyAccessStart	Head of the linked list sorted by access timebyAccessEnd		Tail of the linked list sorted by access timebyCreationStart	Head of the linked list sorted by creation timebyCreationEnd	Tail of the linked list sorted by creation timeThe implementation is a combination of:- an open hash table, used for look ups by key - a linked list of cache entries sorted by creation time, used for reaping by absolute age- a linked list of cache entries sorted by access time, used for reaping by relative ageFor every cache entry there is a node in the hash table and a node in both of the linked lists. It is possible to navigate from every node for a key to every other node of the same key. This is required for removing and updating entries.#+END_EXAMPLE*** WAMutualExclusionCache#+BEGIN_EXAMPLEWACache subclass: #WAMutualExclusionCacheWAMutualExclusionCacheNG is a wrapper around a WACacheNG that wraps all messages in a mutex.Instance Variables:	mutex	<WAMutex>	cache	<WACache>#+END_EXAMPLE*** WAUnidirectionalCache#+BEGIN_EXAMPLEWACache subclass: #WAUnidirectionalCacheI support only key -> value mappings and never forget anything.#+END_EXAMPLE** Codec*** GRCodec#+BEGIN_EXAMPLEA codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding) and back outside the image (encoding). The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.#+END_EXAMPLE*** GRNullCodec#+BEGIN_EXAMPLEGRObject subclass: #GRCodecThe null codec always returns the original streams. It assumes that the outside world uses the same encoding as the inside world. This is highly efficient as no transformation is applied to the data, but has its drawbacks.#+END_EXAMPLE*** GRPharoLating1Codec#+BEGIN_EXAMPLEGRNullCodec subclass: #GRPharoLatin1CodecA GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).#+END_EXAMPLE*** GRPharoGenericCodec#+BEGIN_EXAMPLEGRCodec subclass: #GRPharoGenericCodec:nocomment:#+END_EXAMPLE*** GRPharoUtf8Codec#+BEGIN_EXAMPLEGRCodec subclass: #GRPharoUtf8CodecA WAUtf8Codec is a WACodec optimized for UTF-8.#+END_EXAMPLE** Context*** WAContextTest*** WARequestContext#+BEGIN_EXAMPLE  WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)  WARequestContext encapsulates all the knowledge that should be available while processing a single request.   It does not matter if this is a request to a static file,   an AJAX request,   a long Comet request   or a normal Seaside requestion.  The request context is valid only during the request that caused it.   It should not be stored.   Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.   In both cases this might lead to memory leaks.#+END_EXAMPLE** DocumentA Seaside Document is basically a wrapper on a Stream and a Codec.*** WADocument#+BEGIN_EXAMPLEWAObject subclass: #WADocumentA WADocument combines an output stream and an instance of root. The root is responsible to render header and footer if necessary.#+END_EXAMPLE*** WAJsonDocument#+BEGIN_EXAMPLEWADocument subclass: #WAJsonDocumentI add the possibility to generate JSON.#+END_EXAMPLE*** WAXmlDocument#+BEGIN_EXAMPLEWADocument subclass: #WAXmlDocumentA WAXmlDocument is adds the possibility to generate XML tags and knows encoders for XML text and URLs.#+END_EXAMPLE*** WAHtmlDocument#+BEGIN_EXAMPLEWAXmlDocument subclass: #WAHtmlDocumentA WAHtmlDocument controls how a string is created from a series of brushes.#+END_EXAMPLE*** WAPrettyPrintedDocument#+BEGIN_EXAMPLEWAHtmlDocument subclass: #WAPrettyPrintedDocumentThis Document can be used in place of a WAHtmlDocument and will display a pretty version of the HTML source that would have been generated by the WAHtmlDocument.The technique here is that: - anything we are asked to output raw (i.e. #nextPut: and #nextPutAll:) we encode with entities - anything we are asked to entity encode (i.e. via #xmlEncoder) we double-encode, by wrapping the two WAXmlEncoders around each other - anything we want to output ourselves (i.e. prettiness) we do using a WAHtmlCanvas that we create ourselves#+END_EXAMPLE*** WAUnescapedDocument#+BEGIN_EXAMPLEWAXmlDocument subclass: #WAUnescapedDocumentA WAUnescapedDocument does not do any escaping.#+END_EXAMPLE** Key Generator*** WAKeyGenerator                       #+BEGIN_EXAMPLEWAObject subclass: #WAKeyGenerator:nocomment:#+END_EXAMPLE*** WAPrecomputedKeyGenerator              #+BEGIN_EXAMPLEWAKeyGenerator subclass: #WAPrecomputedKeyGenerator:nocomment:#+END_EXAMPLE** Painter #+BEGIN_EXAMPLEPainters are Visitors#+END_EXAMPLE*** WAPainterVisitor#+BEGIN_EXAMPLEWAVisitor subclass: #WAPainterVisitorAn implementation of the Visitor pattern for Painter subclasses.#+END_EXAMPLE*** WAHaloVisitor                             #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAHaloVisitor#+END_EXAMPLE*** WAInitialRequestVisitor                             #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAInitialRequestVisitor#+END_EXAMPLE*** WAPluggablePresenterVisitor                         #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAPluggablePresenterVisitorNO CLASS COMMENT#+END_EXAMPLE*** WAPresenterGuide#+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAPresenterGuideWAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations. Along the way, they will ask their client to visit each Painter they come across.This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.#+END_EXAMPLE*** WARenderingGuide#+BEGIN_EXAMPLEWAPresenterGuide subclass: #WARenderingGuideCurrently an empty class but still present for clarity and to allow customization of Rendering behaviour.#+END_EXAMPLE*** WAVisiblePresenterGuide#+BEGIN_EXAMPLEWAPresenterGuide subclass: #WAVisiblePresenterGuideVisit the tree of all Presenters and their registered #children. Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.#+END_EXAMPLE*** WAAllPresenterGuide#+BEGIN_EXAMPLEWAVisiblePresenterGuide subclass: #WAAllPresenterGuideVisit the tree of all Presenters and their registered #children.#+END_EXAMPLE*** WARenderVisitor  #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WARenderVisitorA visitor that renders Painters. It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.#+END_EXAMPLE*** WATaskVisitor                #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WATaskVisitor#+END_EXAMPLE*** WAUpdateRootVisitor#+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAUpdateRootVisitorA visitor which asks Painters to update a WARoot subclass using #updateRoot:.This is used to update the root of the Document stored on a WARenderContext.#+END_EXAMPLE*** WAUpdateStatesVisitor  #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAUpdateStatesVisitorA visitor which asks Painters to update a WARoot subclass using #updateRoot:.This is used to update the root of the Document stored on a WARenderContext.#+END_EXAMPLE*** WAUpdateUrlVisitor#+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAUpdateUrlVisitorA visitor which asks Painters to update a WAUrl subclass using #updateRoot:.This is used to update the base URL stored on a WARenderContext.#+END_EXAMPLE** Registry#+BEGIN_EXAMPLEsee WARegistry under WARequestHandler#+END_EXAMPLE** Renderer#+BEGIN_EXAMPLEA Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.Renderer are typically controlled by a Painter.#+END_EXAMPLE*** WARenderer#+BEGIN_EXAMPLEWAObject subclass: #WARendererA Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.Renderer are typically controlled by a Painter (Painters are Visitors).#+END_EXAMPLE#+BEGIN_EXAMPLEWAObject subclass: #WARendererA Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.Renderer are typically controlled by a Painter.javascript-core and jquery-core have methods in me.I provide the nextid and lastid and render method (verify this)#+END_EXAMPLE*** WACanvas#+BEGIN_EXAMPLEWARenderer subclass: #WACanvasThis is the superclass of all canvas. It's a rendering interface that generates brushes (see WABrush).Subclass WAXmlCanvas, if you want to generate an XML dialect.#+END_EXAMPLE*** WAJsonCanvas#+BEGIN_EXAMPLEWACanvas subclass: #WAJsonCanvasI am a  specific canvas to render JSON output.#+END_EXAMPLE*** WATagCanvas#+BEGIN_EXAMPLEWACanvas subclass: #WATagCanvasI am the abstract superclass for tag based canvases.#+END_EXAMPLE*** WAHtmlCanvas#+BEGIN_EXAMPLEWATagCanvas subclass: #WAHtmlCanvasI'm a canvas for building HTML.#+END_EXAMPLE*** WAXmlCanvas#+BEGIN_EXAMPLEI'm an abstract canvas base class for building canvas for custom XML dialects.WATagCanvas subclass: #WAXmlCanvas#+END_EXAMPLE** Render Context*** WARenderContext #+BEGIN_EXAMPLE WAObject subclass: #WARenderContext A WARenderContext provides all the state needed by a Renderer to do its work. It is a decoupling device between whatever is initiating rendering and the Renderer itself. #+END_EXAMPLE** Request*** WARequest#+BEGIN_EXAMPLEWAObject subclass: #WARequest  has no childrenI am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.Instance Variables	method:			<String>	uri:					<WAUrl>	version:				<WAHttpVersion>	remoteAddress:	<String>	headers:			<Dictionary<String, String>>	cookies:			<Collection<WARequestCookie>>	body:				<String>	postFields:			<WARequestFields>	sslSessionId:		<String>			method	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		uri	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.	version	- The version of this request.	remoteAddress	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.headers	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.	cookies	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.	body	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.	postFields	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.	sslSessionId	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.#+END_EXAMPLE** Request Handler and  Continuation*** WARequestHandler#+BEGIN_EXAMPLEWAObject subclass: #WARequestHandlerWARequestHandler is an abstract class whose subclasses handle http requests. Most of the methods are either empty or return a default value. Subclasses must implement the following messages:	handleFiltered:	process the requestBelow are the Handlers/registries.#+END_EXAMPLE*** WADispatcher#+BEGIN_EXAMPLEWARequestHandler subclass: #WADispatcherexplore: WADispatcher defaultThis is the entry point for Seaside.see WAApplication , which is stored in the WADisplatcher.WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc). WADispatcher class>>default is the top level dispatcher. When a Seaside application is registered as "foo" the application is added to the top level dispatcher. The application is added to the entryPoints of the dispatcher at the key "foo". If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo". That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".   When a http request is received it is sent to WADispatcher class>>default to find the correct handler for the request. If a handler exists for the request is sent to that handler. Otherwise the request is sent to the not found response generator.The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class>>default. One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming). Instance Variables:	defaultName	<String>	entryPoints	<(Dictionary of: WAEntryPoint)>	 the keys are strings, which are the names and URL path segments for the handler at that key#+END_EXAMPLE*** WADocumentHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WADocumentHandlerWADocumentHandler handles requests for images, text documents and binary files (byte arrays). This class is not normally used directly. A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler. Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document, registers the handler with a Registry, and adds the correct url in the tag for the document.Instance Variables:	document	<WAMimeDocument>	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.#+END_EXAMPLE*** WAFileHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WAFileHandlerSeaside serves static files using WAFileLibrary subclasses. WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server. WAFileHandler is registered with the default WADispatcher automatically.#+END_EXAMPLE*** WALegacyRedirectionHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WALegacyRedirectionHandlerI provide compatibility with old Seaside URLs that have Seaside in the path (eg. '/seaside/examples/counter') by simply removing it.#+END_EXAMPLE*** WANextUnconsumedPathElementRequestHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WANextUnconsumedPathElementRequestHandler:nocomment:#+END_EXAMPLE*** WARegistry#+BEGIN_EXAMPLEWARequestHandler subclass: #WARegistryWARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd. WARegistry checks incoming request URLs for a key and looks for a matching active request handler. If one exists, the request is sent to the proper handler. If not, the request is either a new request (in which case #handleDefaultRequest: is called) or a request to a now-inactive handler (in which case #handleExpiredRequest: is called). These two methods allow subclasses to properly handle these requests.Subclasses must implement the following messages:	handleDefaultRequest:		Handle a request without a session key, ie a new request.	handlerField		The URL parameter in which to store the request handler key.Instance Variables:	cache - an instance of WACache to hold the stored request handlers#+END_EXAMPLE*** WAApplication#+BEGIN_EXAMPLE WARegistry subclass: #WAApplicationWAApplication is the starting point for a Seaside application. When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher.   (explore: WADispatcher default)The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application. "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)If you change the cache configuration  you need to send #initializeCache for the changes to take effect."libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.Registering an Application.	An application can be registered with a dispatcher by using the Seaside configuration page or via code. Below MyComponent is a subclass of WAComponent. The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration. MyComponent class>>initialize	"self initialize"	| application |	application := self registerAsApplication: 'sample'.	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.	application addLibrary: SampleLibrary.	application configuration addAncestor: GlorpConfiguration new.	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.	application preferenceAt: #databaseServer put: '127.0.0.1'.	application preferenceAt: #databaseConnectString put: 'glorptests'.MyComponent>>someInstanceMethod	"example of how to access attributes (preferences)"	self session application preferenceAt: #glorpDatabasePlatform#+END_EXAMPLE*** WARedirectingApplication#+BEGIN_EXAMPLEWAApplication subclass: #WARedirectingApplicationI revert to the old < 3.3.0 behavior which is easier for tests.#+END_EXAMPLE*** WARedirectingRegistry#+BEGIN_EXAMPLEWARegistry subclass: #WARedirectingRegistryI revert to the old < 3.3.0 behavior which is easier for tests.#+END_EXAMPLE*** WARestfulHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WARestfulHandler:nocomment:#+END_EXAMPLE*** WACORSResourceExample#+BEGIN_EXAMPLEWARestfulHandler subclass: #WACORSResourceExample:nocomment:#+END_EXAMPLE*** WASession#+BEGIN_EXAMPLEWARequestHandler subclass: #WASessionI am a Seaside session. A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.This class is intended to be subclasses by applications that need global state, like a user. Custom state can be added by creating instance variables and storing it there. The session can be retrieved by #session if inside a component or task or by evaluating: WACurrentRequestContext sessionIf the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system. To manually expire a session call #expire.A good way to clear all sessions is the following code:WARegistry clearAllHandlers.WAPlatform current garbageCollect#+END_EXAMPLE*** WAExpirySession#+BEGIN_EXAMPLEWASession subclass: #WAExpirySession:nocomment:#+END_EXAMPLE*** WASessionCookieProtectedSession#+BEGIN_EXAMPLEWASession subclass: #WASessionCookieProtectedSessionI am a session with a WASessionCookieProtectionFilter.provide a link here#+END_EXAMPLE*** WATestSession#+BEGIN_EXAMPLEWASession subclass: #WATestSession:nocomment:#+END_EXAMPLE*** WASessionContinuation#+BEGIN_EXAMPLEWARequestHandler subclass: #WASessionContinuationI represent a continuation as part of the flow of pages within a session. I am not a real continuation (as compared to those used in #call: and #answer:), I only represent a specific point in the session. I reference the root component and a memory snapshot of backtracked objects.#+END_EXAMPLE*** WANullSessionContinuation#+BEGIN_EXAMPLEWASessionContinuation subclass: #WANullSessionContinuation:nocomment:#+END_EXAMPLE*** WARenderLoopContinuation#+BEGIN_EXAMPLEWASessionContinuation subclass: #WARenderLoopContinuation:nocomment:#+END_EXAMPLE*** WAActionPhaseContinuation#+BEGIN_EXAMPLEWARenderLoopContinuation subclass: #WAActionPhaseContinuation:nocomment:#+END_EXAMPLE*** WACallbackProcessingActionContinuation#+BEGIN_EXAMPLEWAActionPhaseContinuation subclass: #WACallbackProcessingActionContinuation:nocomment:#+END_EXAMPLE*** WAInitialRenderLoopContinuation#+BEGIN_EXAMPLEWAActionPhaseContinuation subclass: #WAInitialRenderLoopContinuationI'm the initial continuation of a render loop. I just render the initial page. Subclasses may want to override #shouldRedirect and answer true so that a redirect happens before displaying the first page.#+END_EXAMPLE*** WAPluggableActionContinuation#+BEGIN_EXAMPLEWAActionPhaseContinuation subclass: #WAPluggableActionContinuationThis continuation executes an action (any class that implements #value or #value:). If possible, the renderContext is passed in as an argument. When the action is complete, if a response hasn't been returned, control is passed to a render continuation.'Instance Variables:	action	<BlockClosure | BlockContext | GRDelayedSend | MessageSend | WAContinuation | WAPartialContinuation>:important:#+END_EXAMPLE*** WARenderPhaseContinuation#+BEGIN_EXAMPLEWARenderLoopContinuation subclass: #WARenderPhaseContinuation:nocomment:#+END_EXAMPLE***  WAFlushingRenderPhaseContinuation#+BEGIN_EXAMPLEWARenderPhaseContinuation subclass: #WAFlushingRenderPhaseContinuation:nocomment:#+END_EXAMPLE*** WATestNoopRequestHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WATestNoopRequestHandler:nocomment:#+END_EXAMPLE*** WATestNoopSessionHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WATestNoopSessionHandler:nocomment:#+END_EXAMPLE** Response*** WAResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse . I have childrenA WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.See class side initialize protocol for all the responses from the server.#+END_EXAMPLE*** WABufferedResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WABufferedResponseA WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.Instance Variables	contentsStream:		<WriteStream> The contents of this message.Basically a wrapper on a stream that obtains its headers from the parent.#+END_EXAMPLE*** WAComboResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WAComboResponseWAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:renderContentOn: aCanvas	"Render the search page"	self renderSearchLabelOn: aCanvas.	self requestContext request flush. "flush before starting search to give immediate feedback"	self searchResultsDo: [ :result |		self renderSearchResult: result on: aCanvas.		self requestContext request flush "flush after each search result" ]After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.on the TODO, I will investigate this more, later#+END_EXAMPLE*** WAStreamedResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WAStreamedResponseA WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.Instance Variables	committed:		<Boolean>	Whether the status and header was written to the stream.	externalStream:		<WriteStream>	The external stream to write to.#+END_EXAMPLE** Root*** WARoot#+BEGIN_EXAMPLEWAObject subclass: #WARootA WARoot is the root of a document. It is responsible to generate header and footer of a document.#+END_EXAMPLE*** WAHtmlRoot#+BEGIN_EXAMPLEWARoot subclass: #WAHtmlRootA WAHtmlRoot is the root element of an HTML Document (<html>).Instance Variables	bodyAttrs:		<WAHtmlAttributes>	context:			<WARenderContext>	docType:		<String>	headAttrs:		<WAHtmlAttributes>	headElements:	<OrderedCollection<WAHtmlElement>>	htmlAttrs:		<WAHtmlAttributes>	scripts:			<Set<String>>	styles:			<Set<String>>	title:			<String>bodyAttrs	- the attributes of the <body> elementcontext	- the context used to render the contents of the <body> elementdocType	- the document typeheadAttrs	- the attributes of the <head> elementheadElements	- the elements inside the <head> sectionhtmlAttrs	- the attributes of the <html> elementscripts	- contains the strings returned by WAPresenter >> #scriptstyles	- contains the strings returned by WAPresenter >> #styletitle	- the title of the HTML document, the contents of the <title> elementwriteHeadOn: aDocument	aDocument nextPutAll: docType.	aDocument openTag: 'html' attributes: htmlAttrs.	aDocument openTag: 'head' attributes: headAttrs.	self writeElementsOn: aDocument.	self writeStylesOn: aDocument.	self writeScriptsOn: aDocument.	aDocument closeTag: 'head'.	aDocument openTag: 'body' attributes: bodyAttrs#+END_EXAMPLE*** WAXmlRoot#+BEGIN_EXAMPLEWARoot subclass: #WAXmlRootNo comment.writePreambleOn: aDocument	aDocument nextPutAll: '<?xml version="1.0" encoding="'; nextPutAll: self charSet; nextPutAll: '"?>'#+END_EXAMPLE** Server*** WAServerAdaptor#+BEGIN_EXAMPLEA WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol: - #codec - #usesSmalltalkEncodingInstance Variables	codec:		<WACodec>codec	- the codec used for response conversion from characters to bytes#+END_EXAMPLE*** WATestServerAdapator#+BEGIN_EXAMPLEWAServerAdaptor subclass: #WATestServerAdaptorA WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager#+END_EXAMPLE*** WAWebServerAdaptor                             #+BEGIN_EXAMPLEWAServerAdaptor subclass: #WAWebServerAdaptorWhat does this thing do?It holds a reference to its WAServerManagera porta requestHandlera codeca server of class WebServer from WebClient-Core in squeaka certName#+END_EXAMPLE*** WAServerManager#+BEGIN_EXAMPLEA server manager cares on the available Seaside server adopters#+END_EXAMPLE*** WebServer#+BEGIN_EXAMPLENot a part of Seaside in Squeak, but part of WebClient-CoreI wonder if other WebClient-Core classes are used within the WA framework...WebClient provides a simple yet complete HTTP server implementation.To view the documentation evaluate:	HelpBrowser openOn: WebServerHelp.Does Pharo use a different class?#+END_EXAMPLE** Visitor*** WAVisitor#+BEGIN_EXAMPLEWAObject subclass: #WAVisitorCommon superclass for all visitors (visitor pattern)#+END_EXAMPLE*** WAAttributeVisitor#+BEGIN_EXAMPLEWAVisitor subclass: #WAAttributeVisitorA visitor of attributes#+END_EXAMPLE*** WAUserConfigurationEditorVisitor                             #+BEGIN_EXAMPLEWAAttributeVisitor subclass: #WAUserConfigurationEditorVisitor#+END_EXAMPLE** HOWTO#+BEGIN_EXAMPLEan assortment of howtos follows#+END_EXAMPLE*** Clear Sessions#+BEGIN_EXAMPLETo manually expire a session call #expire.A good way to clear all sessions is the following code:WARegistry clearAllHandlers.WAPlatform current garbageCollect#+END_EXAMPLE** Followup#+BEGIN_EXAMPLEUpdate Doc to handle TAGS and ignore #Startup etc.Squeak uses WebServer, does Pharo use Kom thing?Get examples/strategies/use-cases of WAExpiringCachesee if we can hack Seaside using examples from: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_ExpirationWrite a mockups of WAComboResponseWAStreamedResponseget a sense of the things WAVisitor children do.#+END_EXAMPLE** Bibliography#+BEGIN_EXAMPLE  https://github.com/seasidest  https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration#+END_EXAMPLE** Todo below here*** Builder*** Error *** WAError#+BEGIN_EXAMPLEGRError subclass: #WAErrorCommon superclass for Seaside errors#+END_EXAMPLE*** WAAuthConfigurationError#+BEGIN_EXAMPLEWAError subclass: #WAAuthConfigurationErrorA WAAuthConfigurationError is signaled when no WAAuthConfiguration was added to an application that is behind a WAAuthenticationFilter.#+END_EXAMPLE*** GRPlatform*** GRPharoPlatform#+BEGIN_EXAMPLEGRPlatform subclass: #GRPharoPlatformA GRPharoPlatform is the Pharo implementation of GRPlatform, the Grease class that provides functionality that can not be implemented in a platform independent way.#+END_EXAMPLE*** GRSqueakPlatform#+BEGIN_EXAMPLEGRPharoPlatform subclass: #GRSqueakPlatform#+END_EXAMPLE*** Transient Value Holder*** WAValueHolder#+BEGIN_EXAMPLEWAObject subclass: #WAValueHolderI wrap a single object. I am like value holder except that I am portable and don't include the Model cruft in Squeak.#+END_EXAMPLE*** WADynamic Variable*** WAKeyGenerator*** WAMutex*** WACookie#+BEGIN_EXAMPLEI represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.You can never trust information in a cookie, the client is free to edit it.I model only a part of the full cookie specification.Browser support:http://www.mnot.net/blog/2006/10/27/cookie_funNetscape spechttp://cgi.netscape.com/newsref/std/cookie_spec.htmlCookie spechttp://tools.ietf.org/html/rfc2109Cookie 2 spechttps://tools.ietf.org/html/rfc6265HttpOnlyhttp://msdn2.microsoft.com/en-us/library/ms533046.aspxhttps://bugzilla.mozilla.org/show_bug.cgi?id=178993Compared to WARequestCookie I represent the information that is sent to the user agent.#+END_EXAMPLE*** WARequestCookie#+BEGIN_EXAMPLEA WARequestCookie is the cookie the user agent sent to the server.Instance Variables	domain:			<String>	key:			<String>	path:			<String>	pathEncoded:	<String>	ports:			<Collection<Integer>>	value:			<String>	version:			<Integer>domain	- xxxxxkey	- xxxxxpath	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:  1.  Let uri-path be the path portion of the request-uri if such a       portion exists (and empty otherwise).  For example, if the       request-uri contains just a path (and optional query string),       then the uri-path is that path (without the %x3F ("?") character       or query string), and if the request-uri contains a full       absoluteURI, the uri-path is the path component of that URI.   2.  If the uri-path is empty or if the first character of the uri-       path is not a %x2F ("/") character, output %x2F ("/") and skip       the remaining steps.   3.  If the uri-path contains no more than one %x2F ("/") character,       output %x2F ("/") and skip the remaining step.   4.  Output the characters of the uri-path from the first character up       to, but not including, the right-most %x2F ("/").ports	- xxxxxvalue	- xxxxxversion	- the version of the cookie specification supported, currently only 1 is known#+END_EXAMPLE*** WAMergedRequestFields#+BEGIN_EXAMPLEProvides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.#+END_EXAMPLE