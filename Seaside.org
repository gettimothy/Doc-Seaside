*  Seaside** Introduction#+BEGIN_EXAMPLEWorking Notes of an "in depth" study of the Seaside guts and patterns.#+END_EXAMPLE** Followups#+BEGIN_EXAMPLEWrite a mockups of WAComboResponseWAStreamedResponse#+END_EXAMPLE** WAContextTest** WARequestContext#+BEGIN_EXAMPLE  WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)#+END_EXAMPLE** Codec** WARequest#+BEGIN_EXAMPLEWAObject subclass: #WARequest  has no childrenI am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.Instance Variables	method:			<String>	uri:					<WAUrl>	version:				<WAHttpVersion>	remoteAddress:	<String>	headers:			<Dictionary<String, String>>	cookies:			<Collection<WARequestCookie>>	body:				<String>	postFields:			<WARequestFields>	sslSessionId:		<String>			method	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		uri	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.	version	- The version of this request.	remoteAddress	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.headers	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.	cookies	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.	body	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.	postFields	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.	sslSessionId	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.#+END_EXAMPLE** WAResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse . I have childrenA WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.See class side initialize protocol for all the responses from the server.#+END_EXAMPLE** WABufferedResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WABufferedResponseA WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.Instance Variables	contentsStream:		<WriteStream> The contents of this message.Basically a wrapper on a stream that obtains its headers from the parent.#+END_EXAMPLE** WAComboResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WAComboResponseWAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:renderContentOn: aCanvas	"Render the search page"	self renderSearchLabelOn: aCanvas.	self requestContext request flush. "flush before starting search to give immediate feedback"	self searchResultsDo: [ :result |		self renderSearchResult: result on: aCanvas.		self requestContext request flush "flush after each search result" ]After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.on the TODO, I will investigate this more, later#+END_EXAMPLE** WAStreamedResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WAStreamedResponseA WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.Instance Variables	committed:		<Boolean>	Whether the status and header was written to the stream.	externalStream:		<WriteStream>	The external stream to write to.#+END_EXAMPLE** Minor Stuff Below Here** WACookie#+BEGIN_EXAMPLEI represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.You can never trust information in a cookie, the client is free to edit it.I model only a part of the full cookie specification.Browser support:http://www.mnot.net/blog/2006/10/27/cookie_funNetscape spechttp://cgi.netscape.com/newsref/std/cookie_spec.htmlCookie spechttp://tools.ietf.org/html/rfc2109Cookie 2 spechttps://tools.ietf.org/html/rfc6265HttpOnlyhttp://msdn2.microsoft.com/en-us/library/ms533046.aspxhttps://bugzilla.mozilla.org/show_bug.cgi?id=178993Compared to WARequestCookie I represent the information that is sent to the user agent.#+END_EXAMPLE** WARequestCookie#+BEGIN_EXAMPLEA WARequestCookie is the cookie the user agent sent to the server.Instance Variables	domain:			<String>	key:			<String>	path:			<String>	pathEncoded:	<String>	ports:			<Collection<Integer>>	value:			<String>	version:			<Integer>domain	- xxxxxkey	- xxxxxpath	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:  1.  Let uri-path be the path portion of the request-uri if such a       portion exists (and empty otherwise).  For example, if the       request-uri contains just a path (and optional query string),       then the uri-path is that path (without the %x3F ("?") character       or query string), and if the request-uri contains a full       absoluteURI, the uri-path is the path component of that URI.   2.  If the uri-path is empty or if the first character of the uri-       path is not a %x2F ("/") character, output %x2F ("/") and skip       the remaining steps.   3.  If the uri-path contains no more than one %x2F ("/") character,       output %x2F ("/") and skip the remaining step.   4.  Output the characters of the uri-path from the first character up       to, but not including, the right-most %x2F ("/").ports	- xxxxxvalue	- xxxxxversion	- the version of the cookie specification supported, currently only 1 is known#+END_EXAMPLE** WAMergedRequestFields#+BEGIN_EXAMPLEProvides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.#+END_EXAMPLE** Bibliography#+BEGIN_EXAMPLE  https://github.com/seasidest#+END_EXAMPLE