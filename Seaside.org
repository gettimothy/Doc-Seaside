*  Seaside#+STARTUP: content align#+FILETAGS: :programming:#+TAGS:pharo:squeak:nocomment:important:** Introduction #+BEGIN_EXAMPLEWorking Notes of an "in depth" study of the Seaside guts and patterns.This documentation lives here:   https://github.com/gettimothy/Doc-Seaside#+END_EXAMPLE** Todo#+BEGIN_EXAMPLEUpdate Doc to handle TAGS and ignore #Startup etc.Squeak uses WebServer, does Pharo use Kom thing?Get examples/strategies/use-cases of WAExpiringCachesee if we can hack Seaside using examples from: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_ExpirationWrite a mockups of WAComboResponseWAStreamedResponseget a sense of the things WAVisitor children do.WACallback look like convenience things.In the WANumberAttribute, possibility of deploying a complex or float attributefor didadict purposes.WARequestFilter and otherWACORSFilter examples.WAFileLibrary handles requests for static files. Read its class commentWAExceptionHandler examplesBuild out robust examples of the Strategy stuff. fascinating.Image the following request path:/start/middle/endand a dispatcher mapped at 'start' and an application mapped at 'middle'.The above, from WAPathConsumer provides important insight.Dispatcher->App->thing#+END_EXAMPLE** JSCore*** JSJoin*** JSJson*** JSLogger*** JSScript#+BEGIN_EXAMPLEJSObject subclass: #JSScriptI represent a sequence of JavaScript statements.#+END_EXAMPLE*** JSFunction** JSDecoration** JQuery** JQ** JQAjax** JQWidget** Authentication#+BEGIN_EXAMPLESee WAAuthConfiguration#+END_EXAMPLE** Brush#+BEGIN_EXAMPLEWAObject subclass: #WABrushI represent a brush to be used on a *WACanvas*.Instance Variables	canvas:		The canvas instance I am used with.	parent:		The parent brush I am used within.	closed:		Wether I have been closed/flushed yet.I have three immediate subclasses:WACompoundWAJsonBrushWATagBrush#+END_EXAMPLE*** WACompund#+BEGIN_EXAMPLEWABrush subclass: #WACompoundI am the superclass for stuff that is not html element but you still want to access via the canvas API.I have two subclasses and do not appear to be very popular.#+END_EXAMPLE*** WAJsonBrush#+BEGIN_EXAMPLEWABrush subclass: #WAJsonBrushA brush to generate JSON#+END_EXAMPLE*** WAJsonArrayBrush#+BEGIN_EXAMPLEWAJsonBrush subclass: #WAJsonArrayBrushBrush for a JSON array#+END_EXAMPLE*** WAJsonElementBrush#+BEGIN_EXAMPLEWAJsonBrush subclass: #WAJsonElementBrushAbstract superclass for JSON elements#+END_EXAMPLE*** WAJsonKeyValueBrush#+BEGIN_EXAMPLEWAJsonElementBrush subclass: #WAJsonKeyValueBrushA JSON key value#+END_EXAMPLE*** WAJsonValueBrush#+BEGIN_EXAMPLEWAJsonElementBrush subclass: #WAJsonValueBrushA JSON value#+END_EXAMPLE*** WAJsonObjectBrush#+BEGIN_EXAMPLEWAJsonBrush subclass: #WAJsonObjectBrushA brush to generate a JSON object#+END_EXAMPLE*** WATagBrush#+BEGIN_EXAMPLEWABrush subclass: #WATagBrushThis is the superclass for all XML element classes. Its main additions are- element name (#tag)- attributes (instance of WAHtmlAttributes)- common events (onXXX), this is a hack and would better be solved with traitsMy subclasses are:WAAnchorTag WABasicFormTag WABreakTag WACanvasTag WACollectionTag WACommandTag WADetailsTag WAEmbedTag WAEventSourceTag WAFieldSetTag WAFormInputTag WAGenericTag WAHeadingTag WAHorizontalRuleTag WAIframeTag WAImageTag WAKeyGeneratorTag WALabelTag WAMediaElementTag WAMenuTag WAMeterTag WAObjectTag WAOptionGroupTag WAOptionTag WAOptionalBreakTag WAOutputTag WAParameterTag WAProgressTag WARubyTextTag WAScriptTag WASourceTag WATableCellTag WATableTag WATimeTag WATrackTag WAImageMapTag WAPopupAnchorTag WAFormTag WADatalistTag WAListTag WASelectTag WAAbstractTextAreaTag WAButtonTag WACheckboxTag WAFileUploadTag WAHiddenInputTag WARadioButtonTag WASubmitButtonTag WAEditTag ZurbIFrameTag WAAudioTag WAVideoTag WATableColumnGroupTag WATableDataTag WAOrderedListTag WAUnorderedListTag WAMultiSelectTag WAColorInputTag WAEmailInputTag WASearchInputTag WASteppedTag WATelephoneInputTag WATextAreaTag WATextInputTag WAUrlInputTag WACancelButtonTag WAImageButtonTag WATableColumnTag WATableHeadingTag WAClosedRangeTag WADateInputTag WADateTimeInputTag WADateTimeLocalInputTag WAMonthInputTag WAWeekInputTag WAPasswordInputTag WANumberInputTag WARangeInputTag WATimeInputTagWith the Zurb framework, I includeZurbAnchorTag ZurbArticleTag ZurbButtonTag ZurbCalloutTag ZurbCellTag ZurbCloseButtonTag ZurbDivTag ZurbFieldSetTag ZurbFlexGridTag ZurbFloatGridTag ZurbFooterTag ZurbGenericButtonTag ZurbListItemTag ZurbMenuTag ZurbNavTag ZurbResetButtonTag ZurbSpanTag ZurbSubmitButtonTag ZurbTableTag ZurbTabsTag #+END_EXAMPLE*** WAGenericTag#+BEGIN_EXAMPLEWATagBrush subclass: #WAGenericTagA WAGenericTag is the class for all tags that do not have a class of their own.Instance Variables	tag:		<String>tag	- the name of the tag#+END_EXAMPLE*** WARadioGroup#+BEGIN_EXAMPLEWAObject subclass: #WARadioGroupA WARadioGroup is a container for several related radio buttons. It must be used to create radio buttons.Example:| group |group := html radioGroup.group radioButton	selected: aBoolean;	callback: [ self someThing ].#+END_EXAMPLE** Builder#+BEGIN_EXAMPLEThis is a convenience class which provides a result of a rendering operation as a string. It is expected to be used like this:WAHtmlCanvas builder render: [ :html |	html anchor		url: 'htttp://www.seaside.st';		with: 'Seaside Homepage' ]See WABuilderCanvasTest for more examples.#+END_EXAMPLE*** Builder HTML Canvas#+BEGIN_EXAMPLE	.((WABuilder on: WAHtmlCanvas)	rootClass: WAHtmlRoot;	documentClass: WAHtmlDocument)		render:[:h |			h inspect.			h anchor					url:'http://www.seaside.st' ;					with:'Seaside Home Page']. '<a href="http://www.seaside.st">Seaside Home Page</a>' #+END_EXAMPLE***  Builder Json Canvas#+BEGIN_EXAMPLE"Json Canvas" ((WABuilder on: WAJsonCanvas)	documentClass: WAJsonDocument)		render: [:json | json array:[						json object: [json key:'name' value:'dude']]]((WABuilder on: WAJsonCanvas)	documentClass: WAJsonDocument)		render: [:json | 	json array: [		GRPackage grPackages do:[ :grPackage |			json object: [ 				json key: 'name' value: grPackage name.				json key: 'dependencies' value: [  					json array: [ grPackage dependencies do: [ :dep |						json value: [ json string: dep name ] ] ] ] ] ] ]]#+END_EXAMPLE*** Builder XML Canvas#+BEGIN_EXAMPLE"XML Canvas"((WABuilder on: WAXmlCanvas)	documentClass: WAXmlDocument;	rootClass: WAXmlRoot)		render: [:xml | xml cdata: 'dude']#+END_EXAMPLE** Cache*** WACache#+BEGIN_EXAMPLEWAObject subclass: #WACacheWACacheis the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCache.>>keySize returns 16All other instance methods implement self subclassResponsibility#+END_EXAMPLE*** WABidirectionalCache#+BEGIN_EXAMPLEWACache subclass: #WABidirectionalCacheI support key -> value and value -> key mappings and never forget anything.I also implement serveral methods of Dictionary.#+END_EXAMPLE*** WAPredictableCache#+BEGIN_EXAMPLEWABidirectionalCache subclass: #WAPredictableCacheA WAPredictableCache is a WACache that uses incrementing numbers as cache keys. This way the keys are predictable. This is useful for tests.#+END_EXAMPLE*** WAExpiringCache#+BEGIN_EXAMPLEWACache subclass: #WAExpiringCacheI am the abstract base class for caches that remove entries. Subclasses are intended to use to track sessions.    Instance Variables	maximumSize			<Integer>	maximumRelativeAge		<Integer>	maximumAbsoluteAge	<Integer>	overflowAction			<Symbol>				maximumSize:	Number of sessions supported. When this limit is reached the overflow action is run. 0 for no maximum size. Has to be positive.maximumRelativeAge:	After so many seconds of inactivity a session is considered expired. 0 for no limit. Has to be positive.maximumAbsoluteAge:	After so many seconds after its creation a session is considered expired no matter when it was last accessed. 0 for no limit. Has to be positive.overflowAction:	What to do when the maximum number of sessions is reached. Only matters when the maximum size is bigger than 0.	Possible values:		#removeRelativeOldest remove the entry that hasn't been accessed for the longest time		#removeAbsoluteOldest remove the entry that has been created the longest time ago		#signalError signal WAMaximumNumberOfSessionsExceededError#+END_EXAMPLE*** WABulkReapingCache#+BEGIN_EXAMPLEWAExpiringCache subclass: #WABulkReapingCacheI am a cache that reaps all elements at once instead of incrementally.I am intended to be used in GemStone/S instead of WAHashCache. A background process should send #reap to me.    Instance Variables	dictionary:		<Dictionary>#+END_EXAMPLE*** WABulkReapingCacheEntry#+BEGIN_EXAMPLEWAObject subclass: #WABulkReapingCacheEntryI am a value in a WABulkReapingCache. It's important that my values are not concurrently updated in order to avoid commit conflicts on GemStone/S.accessTime:		only set by reapercreationTime:	immutable, set only oncevalue:			immutable, set only oncelastCount:		only set by reapercount:			updated concurrently but this is not an issue since we use a WAReducedConflictCounter    Instance Variables	count:			<WAReducedConflictCounter>	lastCount:		<Integer>	creationTime:	<Integer>	accessTime:		<Integer>	value:			<Object>#+END_EXAMPLE*** WAReducedConflictCounter#+BEGIN_EXAMPLEWAObject subclass: #WAReducedConflictCounterI am a fake implementation of RcCounter, which is a Gemstone Smalltalk class that provides a counter object with reduced transaction conflicts.#+END_EXAMPLE*** WAHashCache#+BEGIN_EXAMPLEWAExpiringCache subclass: #WAHashCacheWAHashCache is a hash table based implementation of WACache.The characteristics of WAHashCache are:- supports both absolute and relative timeouts at the same time https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration- supports a maximum size with definable overflow action (expire oldest, expire least recently used, signal exception)- access by key is fast (O(1) average case O(n) worst case)- reaping expired sessions is proportional (O(n)) to the number of expired session and independent of the total number of sessions (O(1))- creating a new session independent of the total number of sessions- does not guard against hash collision attacks, you should not use user generated keysInstance Variables:	keyTable 				<Array<WACacheKeyEntry>>	size					<Integer>	byAccessStart			<WACacheListEntry>	byAccessEnd			<WACacheListEntry>	byCreationStart		<WACacheListEntry>	byCreationEnd			<WACacheListEntry>keyTable:	Open hash table of  WACacheKeyEntrybyAccessStart	Head of the linked list sorted by access timebyAccessEnd		Tail of the linked list sorted by access timebyCreationStart	Head of the linked list sorted by creation timebyCreationEnd	Tail of the linked list sorted by creation timeThe implementation is a combination of:- an open hash table, used for look ups by key - a linked list of cache entries sorted by creation time, used for reaping by absolute age- a linked list of cache entries sorted by access time, used for reaping by relative ageFor every cache entry there is a node in the hash table and a node in both of the linked lists. It is possible to navigate from every node for a key to every other node of the same key. This is required for removing and updating entries.#+END_EXAMPLE*** WACacheKeyEntry#+BEGIN_EXAMPLEWAObject subclass: #WACacheKeyEntryI am an entry in the table of WAHashCache.Besides keys and values I keep track of linked list entries so they can be removed without scanning the list. Internal Representation and Key Implementation Points.    Instance Variables	byAccessListEntry:		<WACacheListEntry>	byCreationListEntry:		<WACacheListEntry>	key:		<Object>	keyHash:		<Integer>	next:		<WACacheKeyEntry>	value:		<Object>#+END_EXAMPLE*** WACacheListEntry#+BEGIN_EXAMPLEWAObject subclass: #WACacheListEntryI am a node in a sorted linked list in WAHashCache.    Instance Variables	cacheEntry:		<WACacheKeyEntry>	next:		<WACacheListEntry>	previous:		<WACacheListEntry>	time:		<Integer>time:	timestamp in seconds, could be the creation time or access time depending on with of the two linked lists it is#+END_EXAMPLE*** WAHashTableSizes#+BEGIN_EXAMPLEWAObject subclass: #WAHashTableSizesWAHashTableSizes is a helper class, used by hashedCollections to determine sizes for hash tables.Public protocol is all class-side:#goodSizeAtLeast: anInteger   answers a "good" integer greater than or equal to the given integer.An integer is not "good" as a hash table size if it is any of:- Not prime- Divides 256**k +- a, for small k and a- Close to a power of two- Close to dividing the hashMultiply constantSee Andres Valloud's hashing book, and Knuth TAOCP vol. 3.This class caches a table of selected good primes within the positive SmallInteger range. When this table must be rebuilt, it uses an instance to compute the table. Primes are selected to keep the table fairly small, with approximately five entries per power of two.The cached table is ordered, and is searched with a binary search to find the closest good size >= the requested size.Original implementation by Martin McClure#+END_EXAMPLE*** WACacheConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WACacheConfigurationI am the configuration of WAHashCache.This entgry is duplicated in Configuration System#+END_EXAMPLE*** WAMutualExclusionCache#+BEGIN_EXAMPLEWACache subclass: #WAMutualExclusionCacheWAMutualExclusionCacheNG is a wrapper around a WACacheNG that wraps all messages in a mutex.Instance Variables:	mutex	<WAMutex>	cache	<WACache>#+END_EXAMPLE*** WAUnidirectionalCache#+BEGIN_EXAMPLEWACache subclass: #WAUnidirectionalCacheI support only key -> value mappings and never forget anything.#+END_EXAMPLE** Callback#+BEGIN_EXAMPLETODO what uses these? Where are they documented?#+END_EXAMPLE*** WACallback#+BEGIN_EXAMPLEWAObject subclass: #WACallbackA WACallback is xxxxxxxxx.Instance Variables	key:		<Object>key	- xxxxx#+END_EXAMPLE*** WAActionCallback#+BEGIN_EXAMPLEWACallback subclass: #WAActionCallbackA WAActionCallback is xxxxxxxxx.Instance Variables	block:		<Object>block	- xxxxx#+END_EXAMPLE*** WACancelActionCallback#+BEGIN_EXAMPLEWAActionCallback subclass: #WACancelActionCallbackA WACancelActionCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WADefaultActionCallback#+BEGIN_EXAMPLEWAActionCallback subclass: #WADefaultActionCallbackA WADefaultActionCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAImageCallback#+BEGIN_EXAMPLEWAActionCallback subclass: #WAImageCallbackA WAImageCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WADispatchCallback#+BEGIN_EXAMPLEWACallback subclass: #WADispatchCallbackA WADispatchCallback is xxxxxxxxx.Instance Variables	callbacks:		<Object>callbacks	- xxxxx#+END_EXAMPLE*** WAValueCallback#+BEGIN_EXAMPLEWACallback subclass: #WAValueCallbackA WAValueCallback is xxxxxxxxx.Instance Variables	block:		<Object>block	- xxxxx#+END_EXAMPLE*** WAAllValuesCallback#+BEGIN_EXAMPLEWAValueCallback subclass: #WAAllValuesCallbackWAAllValuesCallback is a special WAValueCallback that whos value is a sequenceable collection of values.#+END_EXAMPLE*** WAAllEmailsCallback#+BEGIN_EXAMPLEWAAllValuesCallback subclass: #WAAllEmailsCallbackA WAAllEmailsCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAAllUrlsCallback#+BEGIN_EXAMPLEWAAllValuesCallback subclass: #WAAllUrlsCallbackA WAAllUrlsCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAEmailCallback#+BEGIN_EXAMPLEWAValueCallback subclass: #WAEmailCallbackA WAEmailCallback is a callback for email input fields.#+END_EXAMPLE*** WAMapCallback#+BEGIN_EXAMPLEWAValueCallback subclass: #WAMapCallbackA WAMapCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAUploadCallback#+BEGIN_EXAMPLEWAValueCallback subclass: #WAUploadCallbackA WAAllUploadsCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAAllUploadsCallback#+BEGIN_EXAMPLEWAUploadCallback subclass: #WAAllUploadsCallbackA WAAllUploadsCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAUrlCallback#+BEGIN_EXAMPLEWAValueCallback subclass: #WAUrlCallbackA WAEmailCallback is a callback for url input fields. #+END_EXAMPLE*** WAValuesCallback#+BEGIN_EXAMPLEWAValueCallback subclass: #WAValuesCallbackA WAValuesCallback is xxxxxxxxx.Instance Variables	values:		<Object>values	- xxxxx#+END_EXAMPLE*** WAMultipleValuesCallback#+BEGIN_EXAMPLEWAValuesCallback subclass: #WAMultipleValuesCallbackA WAMultipleValuesCallback is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WACallbackRegistry#+BEGIN_EXAMPLEWAObject subclass: #WACallbackRegistryA WACallbackRegistry is xxxxxxxxx.Instance Variables	callbacks:		<Object>	nextKey:		<Object>callbacks	- xxxxxnextKey	- xxxxx#+END_EXAMPLE** Canvas#+BEGIN_EXAMPLEA Canvas is a WARenderer#+END_EXAMPLE** Codec*** GRCodec#+BEGIN_EXAMPLEA codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding) and back outside the image (encoding). The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.#+END_EXAMPLE*** GRNullCodec#+BEGIN_EXAMPLEGRObject subclass: #GRCodecThe null codec always returns the original streams. It assumes that the outside world uses the same encoding as the inside world. This is highly efficient as no transformation is applied to the data, but has its drawbacks.#+END_EXAMPLE*** GRPharoLating1Codec#+BEGIN_EXAMPLEGRNullCodec subclass: #GRPharoLatin1CodecA GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).#+END_EXAMPLE*** GRPharoGenericCodec#+BEGIN_EXAMPLEGRCodec subclass: #GRPharoGenericCodec:nocomment:#+END_EXAMPLE*** GRPharoUtf8Codec#+BEGIN_EXAMPLEGRCodec subclass: #GRPharoUtf8CodecA WAUtf8Codec is a WACodec optimized for UTF-8.#+END_EXAMPLE** Configuration#+BEGIN_EXAMPLESystem and User configurations classes are grouped below .Those not belonging tothose classifications are here.#+END_EXAMPLE*** WAConfiguration#+BEGIN_EXAMPLEWAObject subclass: #WAConfigurationA configuration for a Seaside application contains attributes which can be used by Seaside and the application. WAConfiguration hierarchy uses the composite pattern.Subclasses of WASystemConfiguration define and configure related groups of attributes. See WASystemConfiguration class comment for information on defining your own attributes.WAUserConfiguration is a composite of configurations. The set of configurations contained in WAUserConfiguration is called the ancestors. Attribute values in a configuration override the attribute values in the ancestors. WAUserConfiguration also holds the non-default values of attributes.Seaside applications start with a WAUserConfiguration (see WAApplication>>configuration) a single parent: WARenderLoopConfiguration. The full ancestry also includes WASessionConfiguration WAGlobalConfiguration. Other configurations can be added to an application on the Seaside configuration page for the application or in your application. Values for the attributes can be given in either location. See Seaside documentation (http://www.seaside.st/documentation) on configuration and preferences (http://www.seaside.st/documentation/Configuration%20and%20Preferences) for more information.Example of setting attributes and adding configurations in codeASubclassOfWAComponent class>>initialize	"self initialize"	| application |	application := self registerAsApplication: 'GlorpExample'.	"set a standard attribute"	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession. 	"add a configuration"	application configuration addParent: GlorpConfiguration new.	application preferenceAt: #databaseLogin put: 'foo'. "set attribute defined in GlorpConfiguration"Subclasses must implement the following messages:	name		return the name of the configuration	localValueAt:ifAbsent:		return the value of the attribute given as first argument#+END_EXAMPLE*** WAUserConfiguration#+BEGIN_EXAMPLEWAConfiguration subclass: #WAUserConfigurationWAUserConfiguration is a composite of configurations.  This composite of configurations is stored in the field "parents". WAUserConfiguration provides methods to dynamically provide non-default values for attributes. WAUserConfiguration inherits attributes and values defined in its ancestors. If WAUserConfiguration does not have a value for an attribute it will search its ancestors for a value, stopping when it finds a value.An instance of WAUserConfiguration is the first configuration added to a Seaside application (WAApplication). All other configurations added to the application are added as ancestors of this instance. When a value for an attribute is set either by the standard Seaside component configuration page or in code the value is added to the "values" dictionary in WAUserConfiguration.Instance Variables:	parents	<Collection of: WAConfiguration>	 hierarchy of configurations defining all attributes for this instance of WAUserConfiguration	values	<Dictionary>	the dictionary key is an attribute key, dictionary value is value of that attribute #+END_EXAMPLE*** WASharedConfiguration#+BEGIN_EXAMPLEWAUserConfiguration subclass: #WASharedConfigurationno comment#+END_EXAMPLE*** WAAttributeSearchContext#+BEGIN_EXAMPLEWAObject subclass: #WAAttributeSearchContextThis class makes attribute searching more efficient by traversing the ancestry once and caching which Configurations hold the attribute. It is then passed through search functions which cache values for the attribute.#+END_EXAMPLE*** WAAttributeVisitor#+BEGIN_EXAMPLEWAVisitor subclass: #WAAttributeVisitorA visitor of attributesThis entry duplicated in the Visitor section below#+END_EXAMPLE*** WAConfigurationDescription#+BEGIN_EXAMPLEWAObject subclass: #WAConfigurationDescriptionI hold a collection of attributes and present methods to construct new methods, providing an interface a bit like WACanvas and #renderContentOn: to WASystemConfiguration>>addAttributes:.I can use any kind of collection class and handle setting the #configuration: parameter of the attribute appropriately on addition. If my collection is a Dictionary, I will store the attributes by their keys.#+END_EXAMPLE*** WAConfigurationElement#+BEGIN_EXAMPLEWAObject subclass: #WAConfigurationElementA WAConfigurationElement is xxxxxxxxx.Instance Variables	key:		<Object>key	- xxxxx#+END_EXAMPLE*** WAAttribute#+BEGIN_EXAMPLEWAConfigurationElement subclass: #WAAttributeA WAAttribute represents a value of a specified type in a Seaside configuration. Some attributes are needed by Seaside for application parameters like deployment Mode and session timeout. Optional attributes like a database login may be used internally by the application.Each subclass of WAAttribute handles one type (Number, Boolean, etc) of attribute. The "group" of the attribute is used to place all attributes in the same group together on the Seaside configuration page. The "key" of the attribute identifies the attribute. Attribute keys must be globally unique so use namespacing where required to ensure uniqueness. See WAConfiguration for example of accessing a configuration attribute. Subclasses may implement their own configuration options depending on their needs.Subclasses must implement the following messages:	valueFromString: aString		convert "aString" into type represented by the class, return result of the conversion		accept: aVisitor with: anObject		Typical implementation is:			aVisitor visitXXXAttribute: self with: anObject		where XXX is the type of this attribute. The method visitXXXAttribute:with: must be implemented in all visitors, in particular WAUserConfigurationEditorVisitor which creates the configuration page for Seaside applications.Instance Variables:	configuration	<WAConfiguration>	The configuration object that defined the attribute	group			<Symbol>				name of the group the attribute belongs to	key				<Symbol>				key or name of the attribute, used to look up the attribute	comment		<String> 				a full length description of the attribute for displaying in the configuration interface	label			<String>				a short field label used in the user interface. If not specified, a label is constructed from the key.	default			<Object>				The default value for the attribute.#+END_EXAMPLE*** WABooleanAttribute#+BEGIN_EXAMPLEWAAttribute subclass: #WABooleanAttributeWABooleanAttribute  represents a boolean attribute. It converts between text entered on the configuration page and boolean values.#+END_EXAMPLE*** WAListAttribute#+BEGIN_EXAMPLEWAAttribute subclass: #WAListAttributeWAListAttribute is an attribute that is restricted to a list of values. Instance Variables:	options	<Block>	A block returning a list of possible values for the attribute#+END_EXAMPLE*** WAClassBindingAttribute#+BEGIN_EXAMPLEWAListAttribute subclass: #WAClassBindingAttributeA WAClassBindingAttribute is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAClassBindingCollectionAttribute#+BEGIN_EXAMPLEWAListAttribute subclass: #WAClassBindingCollectionAttributeA WAClassBindingCollectionAttribute is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAClassListAttribute#+BEGIN_EXAMPLEWAListAttribute subclass: #WAClassListAttributeWAClassListAttribute is an attribute that is restricted to a list of classes. The value will be an instance of the given class created with #new. #+END_EXAMPLE*** WACollectionAttribute#+BEGIN_EXAMPLEWAListAttribute subclass: #WACollectionAttributeA WACollectionAttribute is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WANumberAttribute#+BEGIN_EXAMPLEWAAttribute subclass: #WANumberAttributeWANumberAttribute represents a number attribute. It converts between text entered on the configuration page and numbers.#+END_EXAMPLE*** WAIntegerAttribute#+BEGIN_EXAMPLEWANumberAttribute subclass: #WAIntegerAttributeA WAIntegerAttribute is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAPasswordAttribute#+BEGIN_EXAMPLEWAAttribute subclass: #WAPasswordAttributeWAPasswordAttribute represents a password attribute. When set from a string, it records a hashed value. On the Seaside configuration page it does not display its current value.#+END_EXAMPLE*** WAStringAttribute#+BEGIN_EXAMPLEWAAttribute subclass: #WAStringAttributeWAStringAttribute represents a string attribute. It does the trivial conversion between text entered on the Seaside configuration page and a string.#+END_EXAMPLE*** WAUrlAttribute#+BEGIN_EXAMPLEWAAttribute subclass: #WAUrlAttributeWAUrlAttribute represents a URL attribute. It converts between text entered on the configuration page and WAUrl instances.#+END_EXAMPLE*** WAAttributeExpression#+BEGIN_EXAMPLEWAConfigurationElement subclass: #WAAttributeExpressionA WAAttributeExpression is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAAddRemoveExpression#+BEGIN_EXAMPLEWAAttributeExpression subclass: #WAAddRemoveExpressionA WAAddRemoveExpression is xxxxxxxxx.Instance Variables	additions:		<Object>	removals:		<Object>additions	- xxxxxremovals	- xxxxx#+END_EXAMPLE*** WAValueExpression#+BEGIN_EXAMPLEWAAttributeExpression subclass: #WAValueExpressionA WAValueExpression is xxxxxxxxx.Instance Variables	value:		<Object>value	- xxxxx#+END_EXAMPLE** Configuration System*** WASystemConfiguratino#+BEGIN_EXAMPLEWAConfiguration subclass: #WASystemConfigurationYou should subclass WASystemConfiguration to define new attributes. The method #describeOn: is passed an instance of WAConfigurationDescription which can be used to create new attributes. The attributes can be configured to specify their default value, label, and so on. See the methods on WAAttribute and its subclasses to see what options are available.If a configuration needs to override the value of another WASystemConfiguration or depends on its attributes, implement the method "parents", returning a collection of configuration objects.WASystemConfiguration subclasses are "read-only" in that their attributes, parents, and default values are all specified in code. Users and applications that want to configure values for attributes should create a WAUserConfiguration and specify the WASystemConfiguration in its ancestry.WASystemConfiguration classes are singleton. You should use #instance on the class side to get the current instance. You cannot call #copy on a WASystemConfiguration.Subclasses should implement the following messages:	describeOn:		They may also want to implement:	parents#+END_EXAMPLE*** WAApplicationConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAApplicationConfigurationWAApplicationConfiguration defines attributes required by WAApplication. All applications should include this configuration (this is done by default for new applications).See #addAttributes: for details on provided attributes.#+END_EXAMPLE*** WAAuthConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAAuthConfigurationWAAuthConfiguration defines attributes to store a username and password for an application. It is used by WAApplication to provide a basic single-account authentication mechanism for applications like the Seaside Configuration application. It changes to mainClass for the session to WAAuthMain, which adds a Decoration to check for authentication before displaying the root component.You can implement your own authentication mechanism without using this configuration by subclassing WAApplication and implementing #verifyPassword:forUser: to lookup account details from a database or similar. You can then manually set WAAuthMain as your main class.#+END_EXAMPLE*** WACacheConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WACacheConfigurationI am the configuration of WAHashCache.This entry is duplicated in Cache area.#+END_EXAMPLE*** WAConfigurationMock#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAConfigurationMockA WAConfigurationMock is xxxxxxxxx.Instance Variables	describeBlock:		<Object>	parentsBlock:		<Object>describeBlock	- xxxxxparentsBlock	- xxxxx#+END_EXAMPLE*** WADevelopmentConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WADevelopmentConfigurationA WADevelopmentConfiguration is xxxxxxxxx.#+END_EXAMPLE*** WAEmailConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAEmailConfigurationA configuration for email#+END_EXAMPLE*** WAExceptionFilterConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAExceptionFilterConfigurationA WAExceptionFilterConfiguration is xxxxxxxxx.#+END_EXAMPLE*** WAFileHandlerConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAFileHandlerConfigurationA WAFileHandlerConfiguration is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WARegistryConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARegistryConfigurationA WARegistryConfiguration is xxxxxxxxx.#+END_EXAMPLE*** WARenderLoopConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARenderLoopConfigurationWARenderLoopConfiguration defines attributes required by the Render Loop classes (see the Seaside-Core-RenderLoop category). Any application using these classes should include this configuration (this is done by default for new applications).See #addAttributes: for details on provided attributes.#+END_EXAMPLE*** WARequestHandlingConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARequestHandlingConfigurationThis configuration class holds attributes needed by classes in the Request Handling layer.#+END_EXAMPLE*** WARestfulConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARestfulConfigurationA WARestfulConfiguration is xxxxxxxxx.#+END_EXAMPLE** Configuration User#+BEGIN_EXAMPLEWAConfiguration has two main trees: System and User.User is presented here#+END_EXAMPLE** Context*** WAContextTest*** WARequestContext#+BEGIN_EXAMPLE  WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)  WARequestContext encapsulates all the knowledge that should be available while processing a single request.   It does not matter if this is a request to a static file,   an AJAX request,   a long Comet request   or a normal Seaside requestion.  The request context is valid only during the request that caused it.   It should not be stored.   Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.   In both cases this might lead to memory leaks.#+END_EXAMPLE** Continuation*** WAContinuation#+BEGIN_EXAMPLEGRObject subclass: #WAContinuationA WAContinuation is the Squeak implementation of a continuation. It serializes the whole stack into an arrayInstance Variables	values:		<Array<ContextPart>>values	- an Array of ContextPart and the values they store#+END_EXAMPLE*** WAPartialContinuation#+BEGIN_EXAMPLEGRObject subclass: #WAPartialContinuationA WAPartialContinuation is xxxxxxxxx.Instance Variables	values:		<Object>values	- xxxxx#+END_EXAMPLE** Cookie*** WACookie#+BEGIN_EXAMPLEI represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.You can never trust information in a cookie, the client is free to edit it.I model only a part of the full cookie specification.Browser support:http://www.mnot.net/blog/2006/10/27/cookie_funNetscape spechttp://cgi.netscape.com/newsref/std/cookie_spec.htmlCookie spechttp://tools.ietf.org/html/rfc2109Cookie 2 spechttps://tools.ietf.org/html/rfc6265HttpOnlyhttp://msdn2.microsoft.com/en-us/library/ms533046.aspxhttps://bugzilla.mozilla.org/show_bug.cgi?id=178993Compared to WARequestCookie I represent the information that is sent to the user agent.#+END_EXAMPLE*** WARequestCookie#+BEGIN_EXAMPLEA WARequestCookie is the cookie the user agent sent to the server.Instance Variables	domain:			<String>	key:			<String>	path:			<String>	pathEncoded:	<String>	ports:			<Collection<Integer>>	value:			<String>	version:			<Integer>domain	- xxxxxkey	- xxxxxpath	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:  1.  Let uri-path be the path portion of the request-uri if such a       portion exists (and empty otherwise).  For example, if the       request-uri contains just a path (and optional query string),       then the uri-path is that path (without the %x3F ("?") character       or query string), and if the request-uri contains a full       absoluteURI, the uri-path is the path component of that URI.   2.  If the uri-path is empty or if the first character of the uri-       path is not a %x2F ("/") character, output %x2F ("/") and skip       the remaining steps.   3.  If the uri-path contains no more than one %x2F ("/") character,       output %x2F ("/") and skip the remaining step.   4.  Output the characters of the uri-path from the first character up       to, but not including, the right-most %x2F ("/").ports	- xxxxxvalue	- xxxxxversion	- the version of the cookie specification supported, currently only 1 is known#+END_EXAMPLE** DocumentA Seaside Document is basically a wrapper on a Stream and a Codec.*** WADocument#+BEGIN_EXAMPLEWAObject subclass: #WADocumentA WADocument combines an output stream and an instance of root. The root is responsible to render header and footer if necessary.#+END_EXAMPLE*** WAJsonDocument#+BEGIN_EXAMPLEWADocument subclass: #WAJsonDocumentI add the possibility to generate JSON.#+END_EXAMPLE*** WAXmlDocument#+BEGIN_EXAMPLEWADocument subclass: #WAXmlDocumentA WAXmlDocument is adds the possibility to generate XML tags and knows encoders for XML text and URLs.#+END_EXAMPLE*** WAHtmlDocument#+BEGIN_EXAMPLEWAXmlDocument subclass: #WAHtmlDocumentA WAHtmlDocument controls how a string is created from a series of brushes.#+END_EXAMPLE*** WAPrettyPrintedDocument#+BEGIN_EXAMPLEWAHtmlDocument subclass: #WAPrettyPrintedDocumentThis Document can be used in place of a WAHtmlDocument and will display a pretty version of the HTML source that would have been generated by the WAHtmlDocument.The technique here is that: - anything we are asked to output raw (i.e. #nextPut: and #nextPutAll:) we encode with entities - anything we are asked to entity encode (i.e. via #xmlEncoder) we double-encode, by wrapping the two WAXmlEncoders around each other - anything we want to output ourselves (i.e. prettiness) we do using a WAHtmlCanvas that we create ourselves#+END_EXAMPLE*** WAUnescapedDocument#+BEGIN_EXAMPLEWAXmlDocument subclass: #WAUnescapedDocumentA WAUnescapedDocument does not do any escaping.#+END_EXAMPLE*** WAHtmlAttributes#+BEGIN_EXAMPLEGRSmallDictionary subclass: #WAHtmlAttributesI represent the attributes of a (X)(HT)ML tag. Compared to my superclass I ignore requests to add a nil-values. I also don't throw an exception when accessing a key that doesn't exist, but instead return nil.#+END_EXAMPLE*** WAConcatenatedHtmlAttributeValue#+BEGIN_EXAMPLEWAObject subclass: #WAConcatenatedHtmlAttributeValueI am used to represent html attribute values that can be sent separately to a brush but eventually need to be printed as a single attribute string. I was introduced to optimize html rendering where String concatentation is slow. See https://github.com/seasidest/seaside/issues/816E.g. in the following code, multiple values for 'class' are sent to the anchor brush and they are eventually concatenated in the outputhtml anchor   class: 'mycss-strong';   class: 'mycss-bold';   class: 'mycss-alignright';   with: 'some text'#+END_EXAMPLE*** WAEncoder#+BEGIN_EXAMPLEWAObject subclass: #WAEncoderI encode everything that is written to myself using #nextPut: and #nextPutAll: onto the wrapped stream.#+END_EXAMPLE*** WATableBasedEncoder#+BEGIN_EXAMPLEWAEncoder subclass: #WATableBasedEncoderI encode everything that is written to myself using #nextPut: and #nextPutAll: onto the wrapped stream. The specific encoding that is done is determined by my subclasses (the conversion of a single character is defined in the class-side method #encode:on:).To be efficient, each subclass uses a cached encoding table to transform the most used characters from the UTF Basic Multilingual Plane.#+END_EXAMPLE*** WAUrlEncoder#+BEGIN_EXAMPLEWATableBasedEncoder subclass: #WAUrlEncoderI do percent-encoding of parts (e.g. path segments and arguments) of a URI.Additionally, a Codec is given the chance to encode the characters into bytes before being percent-encoded(see http://tools.ietf.org/html/rfc3986#section-2.5). This allows extended characters to be represented in URIs in, for example, UTF-8.#+END_EXAMPLE*** WAXmlEncoder#+BEGIN_EXAMPLEWAEncoder subclass: #WAXmlEncoderI encode XHTML text.#+END_EXAMPLE** Document Elements*** WAHtmlElement#+BEGIN_EXAMPLEWAObject subclass: #WAHtmlElementRoot class of all elements inside a <head> section.#+END_EXAMPLE*** WABaseElement#+BEGIN_EXAMPLEWAHtmlElement subclass: #WABaseElementIn HTML, links and references to external images, applets, form-processing programs, style sheets, etc. are always specified by a URI. Relative URIs are resolved according to a base URI, which may come from a variety of sources. The BASE element allows authors to specify a document's base URI explicitly.When present, the BASE element must appear in the HEAD section of an HTML document, before any element that refers to an external source. The path information specified by the BASE element only affects URIs in the document where the element appears.For example, given the following BASE declaration and A declaration:updateRoot: html	super updateRoot: html.	html base url: 'http://www.aviary.com/products/intro.html'renderContentOn: html	html anchor		url: '../cages/birds.gif';		with: 'Bird Cages'the relative URI "../cages/birds.gif" would resolve to:http://www.aviary.com/cages/birds.gif#+END_EXAMPLE*** WAContentElement#+BEGIN_EXAMPLEWAHtmlElement subclass: #WAContentElementCommon superclass of all elements inside a <head> that can have content. Either between the start and end tag or a (mime) document pointed to by an URL.#+END_EXAMPLE*** WALinkElement#+BEGIN_EXAMPLEWAContentElement subclass: #WALinkElementDefines either a link or style sheet rules. If it has children then it defines style sheet rules, else it defines a link.= if link =This element defines a link. Unlike A, it may only appear in the HEAD section of a document, although it may appear any number of times. Although LINK has no content, it conveys relationship information that may be rendered by user agents in a variety of ways (e.g., a tool-bar with a drop-down menu of links).= style sheet rules =The STYLE element allows authors to put style sheet rules in the head of the document. HTML permits any number of STYLE elements in the HEAD section of a document.User agents that don't support style sheets, or don't support the specific style sheet language used by a STYLE element, must hide the contents of the STYLE element. It is an error to render the content as part of the document's text. Some style sheet languages support syntax for hiding the content from non-conforming user agents.#+END_EXAMPLE*** WAScriptElement#+BEGIN_EXAMPLEWAContentElement subclass: #WAScriptElementThe SCRIPT element places a script within a document. This element may appear any number of times in the HEAD of an HTML document.The script may be defined within the contents of the SCRIPT element or in an external file. If the src attribute is not set, user agents must interpret the contents of the element as the script. If the src has a URI value, user agents must ignore the element's contents and retrieve the script via the URI. Note that the charset attribute refers to the character encoding of the script designated by the src attribute; it does not concern the content of the SCRIPT element.#+END_EXAMPLE*** WAMetaElement#+BEGIN_EXAMPLEWAHtmlElement subclass: #WAMetaElementThe META element can be used to identify properties of a document (e.g., author, expiration date, a list of key words, etc.) and assign values to those properties. This specification does not define a normative set of properties.Each META element specifies a property/value pair. The name attribute identifies the property and the content attribute specifies the property's value.For example, the following declaration sets a value for the Author property:<META name="Author" content="Dave Raggett">The lang attribute can be used with META to specify the language for the value of the content attribute. This enables speech synthesizers to apply language dependent pronunciation rules.In this example, the author's name is declared to be French:htm meta	name: 'Author'; language: 'fr'; content: 'Arnaud Le Hors'	Note. The META element is a generic mechanism for specifying meta data. However, some HTML elements and attributes already handle certain pieces of meta data and may be used by authors instead of META to specify those pieces: the TITLE element, the ADDRESS element, the INS and DEL elements, the title attribute, and the cite attribute.Note. When a property specified by a META element takes a value that is a URI, some authors prefer to specify the meta data via the LINK element. Thus, the following meta data declaration:html meta      name: 'DC.identifier';      content: 'http://www.ietf.org/rfc/rfc1866.txt'might also be written:html link         relationship: 'DC.identifier';         type: 'text/plain';         url: 'http://www.ietf.org/rfc/rfc1866.txt'The http-equiv attribute can be used in place of the name attribute and has a special significance when documents are retrieved via the Hypertext Transfer Protocol (HTTP). HTTP servers may use the property name specified by the http-equiv attribute to create an [RFC822]-style header in the HTTP response. Please see the HTTP specification ([RFC2616]) for details on valid HTTP headers.The following sample META declaration:htttp meta         responseHeaderName: 'Expires';         content: 'Tue, 20 Aug 1996 14:25:27 GMT'will result in the HTTP header:Expires: Tue, 20 Aug 1996 14:25:27 GMTThis can be used by caches to determine when to fetch a fresh copy of the associated document.Note. Some user agents support the use of META to refresh the current page after a specified number of seconds, with the option of replacing it by a different URI. Authors should not use this technique to forward users to different pages, as this makes the page inaccessible to some users. Instead, automatic page forwarding should be done using server-side redirects.html meta         redirectAfter: 5 to: 'http://www.google.com/'#+END_EXAMPLE*** WAStyleElement#+BEGIN_EXAMPLEWAHtmlElement subclass: #WAStyleElementThe style element allows style information to be embedded in documents.#+END_EXAMPLE*** WAConditionalComment#+BEGIN_EXAMPLEWAObject subclass: #WAConditionalCommentA WAConditionalComment is an implementation of Downlevel-hidden Conditional Comments:http://msdn2.microsoft.com/en-us/library/ms537512.aspxThese are only visible for the IE family of browsers.See also WAOpeningConditionalComment and WAClosingConditionalComment.#+END_EXAMPLE*** WARevealedConditionalComment#+BEGIN_EXAMPLEWAConditionalComment subclass: #WARevealedConditionalCommentA WAConditionalComment is an implementation of Downlevel-revealed Conditional Comments:http://msdn2.microsoft.com/en-us/library/ms537512.aspxNon-IE family browsers see them always.See also WAOpeningRevealedConditionalComment and WARevealedConditionalComment.#+END_EXAMPLE*** WAOpeningConditionalComment#+BEGIN_EXAMPLEWAObject subclass: #WAOpeningConditionalCommentOpens a WAConditionalComment and encodes the condition.#+END_EXAMPLE*** WAOpeningRevealedConditionalComment#+BEGIN_EXAMPLEWAOpeningConditionalComment subclass: #WAOpeningRevealedConditionalCommentOpens a WARevealedConditionalComment and encodes the condition.#+END_EXAMPLE*** WAClosingConditionalComment#+BEGIN_EXAMPLEWAObject subclass: #WAClosingConditionalCommentCloses a WAConditionalComment.#+END_EXAMPLE*** WAClosingRevealedConditionalComment#+BEGIN_EXAMPLEWAObject subclass: #WAClosingRevealedConditionalCommentCloses a WARevealedConditionalComment.#+END_EXAMPLE** Error *** WAError#+BEGIN_EXAMPLEGRError subclass: #WAErrorCommon superclass for Seaside errorsMy subclasses are:WAAuthConfigurationError WAConfigurationError WAIllegalStateException WAInvalidHeaderValueError WAInvalidUrlSyntaxError WAMaximumNumberOfSessionsExceededError WARequestContextNotFound WAUnhandledNotificationError WAUnregisteredHandlerError WAArgumentNotFoundError WAJsonSyntaxError WAChildComponentShouldNotBeSelfError WATaskNotDelegated WAMissingResponseError WAAttributeNotFound#+END_EXAMPLE** Exception Handling*** WAExceptionHandler#+BEGIN_EXAMPLEWAObject subclass: #WAExceptionHandlerException handlers are invoked when an error in a Seaside application occurs. Request handlers can use the class-side method #handleExceptionsDuring: to set up exception handlers around a block of code.== Catching ==Exception handlers can configure which exceptions they want to catch by overriding the class-side method #exceptionsToCatch. They may also choose to override #handleExceptionsDuring: on the class-side directly, if they need more complex behaviour.== Handling ==Handling behaviour is implemented on the instance side by implementing #handleException:. This method should return a suitable seaside response (usually an instance of WAResponse) if it returns.== Internal Errors ==Internal errors are typically errors that occur while trying to execute one of the other error handlers and should be as basic as possible to ensure they don't have any trouble executing. Request handlers can ask for an internal error response by calling #internalError: on the class-side of an exception handler.== HTML Responses ==See WAWalkbackErrorHandler in the development packages for examples of how to do rendering with the canvas API.#+END_EXAMPLE*** WAErrorHandler#+BEGIN_EXAMPLEWAExceptionHandler subclass: #WAErrorHandlerWAErrorHandler catches Errors and Warnings and provides two methods for handling each type of exception:handleError:handleWarning:If either method is not implemented, the default implementation will call #handleDefault:, which can be used to provide common behaviour for both exception types.#+END_EXAMPLE** Filter#+BEGIN_EXAMPLEWARequestFilter is an implementation for the chain-of-responsibility and decorator pattern for request handlers. #+END_EXAMPLE*** WARequestFilter#+BEGIN_EXAMPLEWAObject subclass: #WARequestFilterWARequestFilter is an implementation for the chain-of-responsibility and decorator pattern for request handlers. Request filters are a way of hooking into the request handling. There is no limit on what they can do, examples include - preprocess the request - postprocess the response - set up thread locals or expection handlers - return a different response (eg. from cache or access denied) This functionality is also known as servlet filters, WSGI infrastructure or rack infrastructure.Instance Variables:	next	<WAValueHolder<WARequestFilter>>		next	- The next filter in the chain.#+END_EXAMPLE*** WAAbstractProtectionFilter#+BEGIN_EXAMPLEWARequestFilter subclass: #WAAbstractProtectionFilterA protection filter protects the wrapped request handler, mostly useful to protect against session hijacking. See subclasses for different strategies.#+END_EXAMPLE*** WARemoteAddressProtectionFilter#+BEGIN_EXAMPLEWAAbstractProtectionFilter subclass: #WARemoteAddressProtectionFilterThe remote address protection filter ensures that the wrapped request handler only accepts requests from the same IP. Do add this filter to a WASession for example to avoid session hijacking, do not add it to static request handlers such as WAApplication or WADispatcher as this might restrict access to the handler if your IP changes.Note that checking for IP addresses is not bullet proof and should never be used as the sole security measure for a web application as IP addresses can be easily spoofed.#+END_EXAMPLE*** WASessionCookieProtectionFilter#+BEGIN_EXAMPLEWAAbstractProtectionFilter subclass: #WASessionCookieProtectionFilterThe session cookie protection filter ensures that the wrapped request handler only accepts requests from the same browser session. This filter is specifically useful to protect session hijacking when using the (default) query field session tracking strategy.Because WAQueryFieldHandlerTrackingStrategy puts the Seaside session key in the url, a session can be easily hijacked by copying the url. This request filter prevents this by requiring a browser session cookie associated to the Seaside session. As a result, a copied Seaside url can only be used in the same browser session.The use of this filter, in combination with WAQueryFieldHandlerTrackingStrategy, keeps the ability for a user to open multiple sessions of the same Seaside application in a single browser, while removing easy session hijacking. A malicious user that wants to hijack the session now needs both the url and the cookie.The appropriate use of this filter is to add it to the session in the `initializeFilters` method of your session class. Only in this way, the session is protected from the first rendered application page onwards. See WASessionCookieProtectedSession class as an example.#+END_EXAMPLE*** WAAuthenticationFilter#+BEGIN_EXAMPLEWARequestFilter subclass: #WAAuthenticationFilterWAAuthenticationFilter protects a request handler with username and password using the standard HTTP basic authentication. This passes username and password in clear-text, unless used over an encripted HTTPS connection. You should set the authenticator, and object that is able to validate usernames and passwords by implementing #verifyPassword:forUser:.#+END_EXAMPLE*** WACORSFilter#+BEGIN_EXAMPLEWARequestFilter subclass: #WACORSFilterImplements a WARequestFilter that adds support to handle CORS requests.CORS = Cross Origin Resource Sharing#+END_EXAMPLE*** WAConfiguredRequestFilter#+BEGIN_EXAMPLEWARequestFilter subclass: #WAConfiguredRequestFilterA WAConfiguredRequestFilter is xxxxxxxxx.Instance Variables	configuration:		<Object>configuration	- xxxxx#+END_EXAMPLE*** WAExceptionFilter#+BEGIN_EXAMPLEWAConfiguredRequestFilter subclass: #WAExceptionFilterA WAExceptionFilter is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WATrailingSlashFilter#+BEGIN_EXAMPLEWARequestFilter subclass: #WATrailingSlashFilterEnforces a trailing slash on the wrapped request handler.#+END_EXAMPLE*** WATransactionFilter#+BEGIN_EXAMPLEWARequestFilter subclass: #WATransactionFilterThis filter provides the implementation of WAComponent>>#isolate:. It rejects all requests as soon as the filter has been closed.#+END_EXAMPLE*** WAAuthConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAAuthConfigurationWAAuthConfiguration defines attributes to store a username and password for an application. It is used by WAApplication to provide a basic single-account authentication mechanism for applications like the Seaside Configuration application. It changes to mainClass for the session to WAAuthMain, which adds a Decoration to check for authentication before displaying the root component.You can implement your own authentication mechanism without using this configuration by subclassing WAApplication and implementing #verifyPassword:forUser: to lookup account details from a database or similar. You can then manually set WAAuthMain as your main class.#+END_EXAMPLE*** WACurrentExceptionHandler#+BEGIN_EXAMPLEWADynamicVariable subclass: #WACurrentExceptionHandlerI hold a reference to the current WAExceptionHandler. This may be needed when nesting exception handlers so that the look up of an exception handler from within an exception handler block still succeeds.#+END_EXAMPLE*** WAExceptionFilterConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAExceptionFilterConfigurationA WAExceptionFilterConfiguration is xxxxxxxxx.Instance Variables#+END_EXAMPLE** GRObject#+BEGIN_EXAMPLEObject subclass: #GRObjectA common superclass that ensures consistent initialization behaviour on all platforms and provides #error: methods that signal an instance of WAPlatformError.Packages that are using Seaside-Platform should normally subclass GRObject instead of Object.immediate subclasses are:GRCodec GRDelayedSend GRDelayedSendMessage GRDelegatingStream GRInflector GRPackage GRPlatform GRPrinter GRSmallDictionary GRSmallDictionary2 GRSmallOrderedSet GRVersion GRPharoRandomProvider GRObjectStubWAAbstractContinuation WAObject WAContinuation WAPartialContinuation #+END_EXAMPLEz** Http#+BEGIN_EXAMPLEThis section contains HTTP specific classes.Some ,like Cookie, Request and Response, havebeen pulled out into their own sections to aid concptualizingSeaside parts as a whole.#+END_EXAMPLE*** WAEmailAddres#+BEGIN_EXAMPLE#+END_EXAMPLE*** WAFile#+BEGIN_EXAMPLEWAObject subclass: #WAFileI represent a file that was uploaded by the user via #fileInput.Instance Variables	contents:		<ByteArray>	contentType:	<WAMimeType>	fileName:		<String>contents	- the contents of the file, binarycontentType	- the content type of the file	fileName	- The name of the file the user agent uploaded. This is locale name on the machine of the client. The instance variable might include the full path on the file system, the accessor will never return the path.#+END_EXAMPLE*** WAHeaderFields#+BEGIN_EXAMPLEGROrderedMultiMap subclass: #WAHeaderFieldsI am the headers dictionary of an HTTP request or response.GROrderedMultiMap is...I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.#+END_EXAMPLE*** WAHttpVersion#+BEGIN_EXAMPLEWAObject subclass: #WAHttpVersionA WAHttpVersion is xxxxxxxxx.Instance Variables	major:		<Object>	minor:		<Object>major	- xxxxxminor	- xxxxx#+END_EXAMPLE*** WALocale#+BEGIN_EXAMPLEWAObject subclass: #WALocaleA WALocale defines a users langauge and country.Instance Variables	country:		<String>	language:		<String>country	- either an ISO 2 or ISO 3 country codelanguage	- either an ISO 2 or ISO 3 language code#+END_EXAMPLE*** WAMergedRequestFields#+BEGIN_EXAMPLEWAObject subclass: #WAMergedRequestFieldsProvides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.#+END_EXAMPLE*** WAMimeDocument#+BEGIN_EXAMPLEWAObject subclass: #WAMimeDocumentME: notice this is not  a subclass of WADocument.WAMimeDocument is the abstract base class for mime documents. It is intended as a very basic, mime documents. Implementations are free to use more advance, native implementations as long as they conform to the protocol.Instance Variables	contentType:		<WAMimeType>mimeType	- the mime type of this document#+END_EXAMPLE*** WAMimeType#+BEGIN_EXAMPLEWAObject subclass: #WAMimeTypeA WAMimeType abstracts a Internet media type, it is a two-part identifier for file formats on the Internet.Instance Variables	main:			<String>	parameters:	<GRSmallDictionary>	sub:			<String>main	- the main typeparameters	- a lazily initialized dictionary of optional parameterssub	- the subtype#+END_EXAMPLE*** WAQualifiedValue#+BEGIN_EXAMPLEWAObject subclass: #WAQualifiedValueA WAQualifiedValue is an Object with an assigned quality value.Instance Variables	quality:		<Float>	value:		<Object>quality	- between 0.0 and 1.0 or Float infinity if no value is givenvalue	- the qualified object#+END_EXAMPLE*** WAAccept#+BEGIN_EXAMPLEWAQualifiedValue subclass: #WAAcceptA WAAccept is a WAQualifiedValue with a value that is an instance of WAMimeType. It represents how much a user agent prefers a certain mime type.#+END_EXAMPLE*** WAAcceptCharset#+BEGIN_EXAMPLEWAQualifiedValue subclass: #WAAcceptCharsetA WAAcceptCharset is a WAQualifiedValue with a value that is an instance of String. It represents how much a user agent prefers a certain character set for the response.#+END_EXAMPLE*** WAAcceptEncoding#+BEGIN_EXAMPLEWAQualifiedValue subclass: #WAAcceptEncodingA WAAcceptCharset is a WAQualifiedValue with a value that is an instance of String. It represents how much a user agent prefers a certain encoding for the response.#+END_EXAMPLE*** WAAcceptLanguage#+BEGIN_EXAMPLEWAQualifiedValue subclass: #WAAcceptLanguageA WAAcceptLanguage is a WAQualifiedValue with a value that is an instance of WALocale. It represents how much a user agent prefers a certain locale.#+END_EXAMPLE** Handlers#+BEGIN_EXAMPLELook at the implementors of 'createHandlers'createHandlers Array with: WARedirectingApplication new		cache: WAUnidirectionalCache new;		yourself.createHandlers	| dispatcher application session root |	root := WADispatcher new.	dispatcher := root register: WADispatcher new at: 'rails'.	application := dispatcher register: WAApplication new at: 'homepage'.	session := WASession new.	application register: session.	^ super createHandlers, (Array with: root with: dispatcher with: application with: session)createHandlers	| handler |	handler := WARequestHandler new.	handler preferenceAt: #charSet put: 'utf-16'.	^ Array with: handlercreateHandlers	| handler |	handler := WARequestHandler new.	handler preferenceAt: #charSet put: 'utf-16'.	^ Array with: handlercreateHandlers	^ #()createHandlers	| application session |	application := WAApplication new		cache: WAPredictableCache new;		yourself.	session := WASession new		documentHandlers: WAPredictableCache new;		yourself.	application register: session.	^ Array		with: application		with: sessioncreateHandlers	^ Array with: (WARegistry new		 cache: WAPredictableCache new;		yourself)createHandlers	^ Array with: WARequestHandler new#+END_EXAMPLE** Key Generator*** WAKeyGenerator                       #+BEGIN_EXAMPLEWAObject subclass: #WAKeyGenerator:nocomment:#+END_EXAMPLE*** WAPrecomputedKeyGenerator              #+BEGIN_EXAMPLEWAKeyGenerator subclass: #WAPrecomputedKeyGenerator:nocomment:#+END_EXAMPLE** Layer#+BEGIN_EXAMPLEWhat are the Layers?This comment in WARequestHandlingConfiguration,"This configuration class holds attributes needed by classes in the Request Handling layer."tells me the application is divided into layers#+END_EXAMPLE** Library#+BEGIN_EXAMPLESeaside serves static files using WAFileLibrary subclasses. WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server. WAFileHandler is registered with the default WADispatcher automatically.#+END_EXAMPLE*** WAAbstractFileLibrary#+BEGIN_EXAMPLEWAObject subclass: #WAAbstractFileLibraryAbstract superclass for Seaside file libraries#+END_EXAMPLE*** WAFileLibrary#+BEGIN_EXAMPLEWAAbstractFileLibrary subclass: #WAFileLibraryWhat does FileLibrary do=============================It allows to serve static files directly from seaside without the need for a standalone server like Apache or to configure Kom. These files can reference each other (say a CSS references an image) and can be distrubuted the same way as normal Smalltalk code (Monticello, SqueakMap, ...).Each file in a file library is represented by a method. The method name is created from the file name, the dot is removed and the first letter of the suffix in capitalized. This puts certain limitations to the allowed filenames. Eg. 'main.css' becomes #mainCss.Like Script- and StyleLibraries FileLibraries can be added to an application so that they automatically include themselves in the document root. Implement #selectorsToInclude and return the selectors you whish to be added to the document root.How to create a FileLibrary================================- First create the static files and put them in some directory.   From there they can reference the other files in the same directory normally with their filenames.- Make sure you have a "Files" entry that serves your files.   This is a normal entry point type that you can find in your /seaside/config application.   If you don't already have one, you can create it if you select "Files" in the type field of the "add entry point" dialog.   For the rest of this text we assume you chose "files" as the path.- Create a subclass of WAFileLibrary, for the rest of this text I assume its name is MyFileLibrary.- To add the files to your file library there are two ways.1. Programmatically with MyFileLibrary class >> #addAllFilesIn: / #addFileNamed:.    For example MyFileLibrary addAllFilesIn: '/path/to/directory/with/files' or MyFileLibrary addFileNamed: '/path/to/background.png'.2. Via the web interface.    Go to your /seaside/config application and there click configure for your "Files".    Click "configure" behind MyFileLibrary.    There you can add a file by uploading it (select the file, then click "Add")Note that a "Files" can consist of several file libraries and can even have tradional script or style libraries.How to integrate a FileLibrary into your application=============================================================Files from a FileLibrary are ingetrated the same way other static files are integrated. They have a constant path that is '/seaside/<Static File Library>/<FileLibrary class name>/<filename>' so for example '/seaside/files/MyFileLibrary/background.png'. These can be conveniently generated by 'MyFileLibrary / #aSelector' where #aSelector is the name of the method representing that file. For example 'MyFileLibrary / #backgroundPng'.How to get back the files in a FileLibrary=================================================The contents of a file library can be written out to disk. Writing out a file library first makes a folder with the name of the file library in the folder of your Smallatlk image. Then a file for each file in the file library is created in this folder. Writing out to disk can happen in three ways1. MyFileLibrary default deployFiles2. Via the configuration interface of the file library.    On the same page where you can add files to your file library there is also a button 'write to disk' which will write out all the files in this library.3. Via the configuration interface of your application.    In the section where you can add libraries to your application there is a a button 'write to disk' which will write out all the libraries of this application.Examples:==========The following code uses WAFileLibrary to add a CSS file to a page.updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot stylesheet 		url: WAFileLibraryDemo / #mainCss		The folllowing code uses WAFileLibrary to display an image.renderContentOn: html	html image		url: WAFileLibraryDemo / #mainJpg		Trouble Shooting:==========Earlier versions would create methods without a time stamp. You can fix this by recompiling these methods by adapting the following codeSUAllTestLibrary basicNew in: [ :library |	#(demologoGif headerGif backgroundGif demoGif logoGif menuGif) do: [ :each |		library class			addFileNamed: (library asFilename: each)			contents: (library perform: each) ] ]#+END_EXAMPLE*** WAFileMetadataLibrary#+BEGIN_EXAMPLEWAAbstractFileLibrary subclass: #WAFileMetadataLibraryI seek to address the following WAFileLibrary related issues:-""Arbitrary support for filenames"" JQuery-UI theme libraries contain currently unsupported filenames such as "e6e6e6_40x100_textures_02_glass_75.png".-""Arbitrary directories for files"" JQuery-UI (and Twitter Bootstrap) expects certain JavaScript files, images etc in a subdirectory, such as "ui/i18n/ui.datepicker-de.js".-""Arbitrary mime-types for files"" Currently mime-types are determined from the file-extension, sometimes it would be good to have some more control.WAAbstractFileLibrary has been introduced which acts as a base for the old file libraries derived from WAFileLibrary and introduces a new subclass WAFileMetadataLibrary. WAFileMetadataLibrary supports resources with paths, which is handy when, for example, the javascript or css in a file library expects its supporting images to be in subdirectories such as img/xxxx.png. WAFileMetadataLibrary also records the original filenames so that when you #deployFiles from the file library on a production server, the exported files will maintain their original names and paths.There's a new method for recursing a sub-directory tree to add all the files and record their relative paths:=MYWAFileMetadataDerivedFileLibrary recursivelyAddAllFilesIn: '/var/www/files/twitterbootstrap'#+END_EXAMPLE*** WAFileHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WAFileHandlerSeaside serves static files using WAFileLibrary subclasses. WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server. WAFileHandler is registered with the default WADispatcher automatically.#+END_EXAMPLE*** WAFileHandlerConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WAFileHandlerConfigurationA WAFileHandlerConfiguration is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAFileHandlerListing#+BEGIN_EXAMPLEWAObject subclass: #WAFileHandlerListingA WAFileHandlerListing is xxxxxxxxx.Instance Variables	context:		<Object>	handler:		<Object>context	- xxxxxhandler	- xxxxx#+END_EXAMPLE*** WAForbiddenFileHandlerListing#+BEGIN_EXAMPLEWAFileHandlerListing subclass: #WAForbiddenFileHandlerListingA WAForbiddenFileHandlerListing is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WATextFileHandlerListing#+BEGIN_EXAMPLEWAFileHandlerListing subclass: #WATextFileHandlerListingA WATextFileHandlerListing is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAFileLibraryResource#+BEGIN_EXAMPLEWAObject subclass: #WAFileLibraryResourceA resource within a Seaside file library#+END_EXAMPLE** Mutex*** WAMutex#+BEGIN_EXAMPLEWAObject subclass: #WAMutexWAMutex provides mutual exclusion properties.Only one process at a time can execute code within its #critical: method. Other processes attempting to call #critical: will block until the first process leaves the critical section. The process that owns the mutex (the one currently in the critical section), however, may call #critical: repeatedly without fear of blocking.The process currently inside the critical section can be terminated by calling #terminateOwner. This will result in the process being unwound and the critical section being freed.#+END_EXAMPLE** WAObject#+BEGIN_EXAMPLEGRObject subclass: #WAObjectA WAObject is the base class for all portable Seaside classes. It provides convenience methods for accessing the current request context, session and application.Its default error class is WAErrorapplication	"Answer the current seaside application, instance of WAApplication or a subclass."		^ self requestContext applicationrequestContext	"Answer the current WARequestContext instance."	^ WACurrentRequestContext value                  "WACurrentRequestContext is a dynamic variable."session	"Answer the current seaside session, instance of WASession or a subclass."		^ self requestContext session#+END_EXAMPLE** Painter #+BEGIN_EXAMPLEPainters are Visitors#+END_EXAMPLE*** WAPainterVisitor#+BEGIN_EXAMPLEWAVisitor subclass: #WAPainterVisitorAn implementation of the Visitor pattern for Painter subclasses.#+END_EXAMPLE*** WAHaloVisitor                             #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAHaloVisitor#+END_EXAMPLE*** WAInitialRequestVisitor                             #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAInitialRequestVisitor#+END_EXAMPLE*** WAPluggablePresenterVisitor                         #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAPluggablePresenterVisitorNO CLASS COMMENT#+END_EXAMPLE*** WAPresenterGuide#+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAPresenterGuideWAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations. Along the way, they will ask their client to visit each Painter they come across.This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.#+END_EXAMPLE*** WARenderingGuide#+BEGIN_EXAMPLEWAPresenterGuide subclass: #WARenderingGuideCurrently an empty class but still present for clarity and to allow customization of Rendering behaviour.#+END_EXAMPLE*** WAVisiblePresenterGuide#+BEGIN_EXAMPLEWAPresenterGuide subclass: #WAVisiblePresenterGuideVisit the tree of all Presenters and their registered #children. Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.#+END_EXAMPLE*** WAAllPresenterGuide#+BEGIN_EXAMPLEWAVisiblePresenterGuide subclass: #WAAllPresenterGuideVisit the tree of all Presenters and their registered #children.#+END_EXAMPLE*** WARenderVisitor  #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WARenderVisitorA visitor that renders Painters. It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.#+END_EXAMPLE*** WATaskVisitor                #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WATaskVisitor#+END_EXAMPLE*** WAUpdateRootVisitor#+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAUpdateRootVisitorA visitor which asks Painters to update a WARoot subclass using #updateRoot:.This is used to update the root of the Document stored on a WARenderContext.#+END_EXAMPLE*** WAUpdateStatesVisitor  #+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAUpdateStatesVisitorA visitor which asks Painters to update a WARoot subclass using #updateRoot:.This is used to update the root of the Document stored on a WARenderContext.#+END_EXAMPLE*** WAUpdateUrlVisitor#+BEGIN_EXAMPLEWAPainterVisitor subclass: #WAUpdateUrlVisitorA visitor which asks Painters to update a WAUrl subclass using #updateRoot:.This is used to update the base URL stored on a WARenderContext.#+END_EXAMPLE** ProcessSpecificVariables#+BEGIN_EXAMPLEObject subclass: #ProcessSpecificVariableMy subclasses (not instances of them) keep state specific to the current process.There are two kinds of process-specific variables: process-local (state availablefor read and write in all methods inside the process), and dynamic variables(implementing dynamic scope).#+END_EXAMPLE*** DynamicVariable#+BEGIN_EXAMPLE#+END_EXAMPLE*** GRDynamicVariable#+BEGIN_EXAMPLEDynamicVariable subclass: #GRDynamicVariableA GRDynamicVariable is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WADynamicVariable#+BEGIN_EXAMPLEGRDynamicVariable subclass: #WADynamicVariableI exist for legacy purposes. You should subclass GRDynamicVariable.#+END_EXAMPLE*** WACurrentCallbackProcessingActionContinuation#+BEGIN_EXAMPLEWADynamicVariable subclass: #WACurrentCallbackProcessingActionContinuationA WACurrentCallbackProcessingActionContinuation is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WACurrentExceptionHandler#+BEGIN_EXAMPLEWADynamicVariable subclass: #WACurrentExceptionHandlerI hold a reference to the current WAExceptionHandler. This may be needed when nesting exception handlers so that the look up of an exception handler from within an exception handler block still succeeds.#+END_EXAMPLE*** WACurrentRequestContext#+BEGIN_EXAMPLEWADynamicVariable subclass: #WACurrentRequestContextA WACurrentRequestContext is a thread local variable that points to the current WARequestContext.WARequestContext >> push: anObject during: aBlock invokes my use: anObject during: aBlockinvokes DynamicVariable value: anObject during: aBlock#+END_EXAMPLE** Registry#+BEGIN_EXAMPLEsee WARegistry under WARequestHandlerduplicated here.#+END_EXAMPLE*** WARegistry#+BEGIN_EXAMPLEWARequestHandler subclass: #WARegistryWARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd. WARegistry checks incoming request URLs for a key and looks for a matching active request handler. If one exists, the request is sent to the proper handler. If not, the request is either a new request (in which case #handleDefaultRequest: is called) or a request to a now-inactive handler (in which case #handleExpiredRequest: is called). These two methods allow subclasses to properly handle these requests.Subclasses must implement the following messages:	handleDefaultRequest:		Handle a request without a session key, ie a new request.	handlerField		The URL parameter in which to store the request handler key.Instance Variables:	cache - an instance of WACache to hold the stored request handlers#+END_EXAMPLE*** WARegistryConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARegistryConfigurationA WARegistryConfiguration is xxxxxxxxx.#+END_EXAMPLE** Renderer#+BEGIN_EXAMPLEA Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.Renderer are typically controlled by a Painter.#+END_EXAMPLE*** WARenderer#+BEGIN_EXAMPLEWAObject subclass: #WARendererA Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.Renderer are typically controlled by a Painter (Painters are Visitors).#+END_EXAMPLE#+BEGIN_EXAMPLEWAObject subclass: #WARendererA Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.Renderer are typically controlled by a Painter.javascript-core and jquery-core have methods in me.I provide the nextid and lastid and render method (verify this)#+END_EXAMPLE*** WACanvas#+BEGIN_EXAMPLEWARenderer subclass: #WACanvasThis is the superclass of all canvas. It's a rendering interface that generates brushes (see WABrush).Subclass WAXmlCanvas, if you want to generate an XML dialect.#+END_EXAMPLE*** WAJsonCanvas#+BEGIN_EXAMPLEWACanvas subclass: #WAJsonCanvasI am a  specific canvas to render JSON output.#+END_EXAMPLE*** WATagCanvas#+BEGIN_EXAMPLEWACanvas subclass: #WATagCanvasI am the abstract superclass for tag based canvases.#+END_EXAMPLE*** WAHtmlCanvas#+BEGIN_EXAMPLEWATagCanvas subclass: #WAHtmlCanvasI'm a canvas for building HTML.#+END_EXAMPLE*** WAXmlCanvas#+BEGIN_EXAMPLEI'm an abstract canvas base class for building canvas for custom XML dialects.WATagCanvas subclass: #WAXmlCanvas#+END_EXAMPLE** Render Context*** WARenderContext #+BEGIN_EXAMPLE WAObject subclass: #WARenderContext A WARenderContext provides all the state needed by a Renderer to do its work. It is a decoupling device between whatever is initiating rendering and the Renderer itself. #+END_EXAMPLE** Request*** WARequest#+BEGIN_EXAMPLEWAObject subclass: #WARequest  has no childrenI am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.Instance Variables	method:			<String>	uri:					<WAUrl>	version:				<WAHttpVersion>	remoteAddress:	<String>	headers:			<Dictionary<String, String>>	cookies:			<Collection<WARequestCookie>>	body:				<String>	postFields:			<WARequestFields>	sslSessionId:		<String>			method	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		uri	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.	version	- The version of this request.	remoteAddress	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.headers	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.	cookies	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.	body	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.	postFields	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.	sslSessionId	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.#+END_EXAMPLE** Request Handling and  Continuation#+BEGIN_EXAMPLEThis is a mess taken from the category Seaside-Core-RequestHandling and the class hierarchies.This will be refactored into something conceptually useful#+END_EXAMPLE*** WARequestHandler#+BEGIN_EXAMPLEWAObject subclass: #WARequestHandlerWARequestHandler is an abstract class whose subclasses handle http requests. Most of the methods are either empty or return a default value. Subclasses must implement the following messages:	handleFiltered:	process the requestBelow are the Handlers/registries.#+END_EXAMPLE*** WADispatcher#+BEGIN_EXAMPLEWARequestHandler subclass: #WADispatcherexplore: WADispatcher defaultThis is the entry point for Seaside.see WAApplication , which is stored in the WADisplatcher.WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc). WADispatcher class>>default is the top level dispatcher. When a Seaside application is registered as "foo" the application is added to the top level dispatcher. The application is added to the entryPoints of the dispatcher at the key "foo". If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo". That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".   When a http request is received it is sent to WADispatcher class>>default to find the correct handler for the request. If a handler exists for the request is sent to that handler. Otherwise the request is sent to the not found response generator.The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class>>default. One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming). Instance Variables:	defaultName	<String>	entryPoints	<(Dictionary of: WAEntryPoint)>	 the keys are strings, which are the names and URL path segments for the handler at that key#+END_EXAMPLE*** WADocumentHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WADocumentHandlerWADocumentHandler handles requests for images, text documents and binary files (byte arrays). This class is not normally used directly. A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler. Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document, registers the handler with a Registry, and adds the correct url in the tag for the document.Instance Variables:	document	<WAMimeDocument>	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.#+END_EXAMPLE*** WAFileHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WAFileHandlerSeaside serves static files using WAFileLibrary subclasses. WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server. WAFileHandler is registered with the default WADispatcher automatically.#+END_EXAMPLE*** WAPathConsumer#+BEGIN_EXAMPLEWAObject subclass: #WAPathConsumerA WAPathConsumer keeps track of the unconsumed path elements in request handling.Image the following request path:/start/middle/endand a dispatcher mapped at 'start' and an application mapped at 'middle'.First nothing at all would be consumed so the unconsumed path would be #('start' 'middle' 'end').Then the dispatcher consumes 'start' and delegates to the application so the unconsumed path would be #('middle' 'end').Then the application consumes 'middle' so the unconsumed path would be #('end').In that caseself requestContext consumer peekinside an #initialRequest: should answer 'end'.Instance Variables	path:		<Collection<String>>path	- the collection of unconsumed path elements#+END_EXAMPLE*** WALegacyRedirectionHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WALegacyRedirectionHandlerI provide compatibility with old Seaside URLs that have Seaside in the path (eg. '/seaside/examples/counter') by simply removing it.#+END_EXAMPLE*** WANextUnconsumedPathElementRequestHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WANextUnconsumedPathElementRequestHandler:nocomment:#+END_EXAMPLE*** WARegistry#+BEGIN_EXAMPLEWARequestHandler subclass: #WARegistryWARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd. WARegistry checks incoming request URLs for a key and looks for a matching active request handler. If one exists, the request is sent to the proper handler. If not, the request is either a new request (in which case #handleDefaultRequest: is called) or a request to a now-inactive handler (in which case #handleExpiredRequest: is called). These two methods allow subclasses to properly handle these requests.Subclasses must implement the following messages:	handleDefaultRequest:		Handle a request without a session key, ie a new request.	handlerField		The URL parameter in which to store the request handler key.Instance Variables:	cache - an instance of WACache to hold the stored request handlers#+END_EXAMPLE*** WARegistryConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARegistryConfigurationA WARegistryConfiguration is xxxxxxxxx.#+END_EXAMPLE*** WARequestHandlingConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARequestHandlingConfigurationThis configuration class holds attributes needed by classes in the Request Handling layer.#+END_EXAMPLE*** WAApplication#+BEGIN_EXAMPLE WARegistry subclass: #WAApplicationWAApplication is the starting point for a Seaside application. When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher.   (explore: WADispatcher default)The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application. "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)If you change the cache configuration  you need to send #initializeCache for the changes to take effect."libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.Registering an Application.	An application can be registered with a dispatcher by using the Seaside configuration page or via code. Below MyComponent is a subclass of WAComponent. The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration. MyComponent class>>initialize	"self initialize"	| application |	application := self registerAsApplication: 'sample'.	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.	application addLibrary: SampleLibrary.	application configuration addAncestor: GlorpConfiguration new.	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.	application preferenceAt: #databaseServer put: '127.0.0.1'.	application preferenceAt: #databaseConnectString put: 'glorptests'.MyComponent>>someInstanceMethod	"example of how to access attributes (preferences)"	self session application preferenceAt: #glorpDatabasePlatform#+END_EXAMPLE*** WARedirectingApplication#+BEGIN_EXAMPLEWAApplication subclass: #WARedirectingApplicationI revert to the old < 3.3.0 behavior which is easier for tests.#+END_EXAMPLE*** WARedirectingRegistry#+BEGIN_EXAMPLEWARegistry subclass: #WARedirectingRegistryI revert to the old < 3.3.0 behavior which is easier for tests.#+END_EXAMPLE*** WARestfulHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WARestfulHandler:nocomment:#+END_EXAMPLE*** WACORSResourceExample#+BEGIN_EXAMPLEWARestfulHandler subclass: #WACORSResourceExample:nocomment:#+END_EXAMPLE*** WASession#+BEGIN_EXAMPLEWARequestHandler subclass: #WASessionI am a Seaside session. A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.This class is intended to be subclasses by applications that need global state, like a user. Custom state can be added by creating instance variables and storing it there. The session can be retrieved by #session if inside a component or task or by evaluating: WACurrentRequestContext sessionIf the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system. To manually expire a session call #expire.A good way to clear all sessions is the following code:WARegistry clearAllHandlers.WAPlatform current garbageCollect#+END_EXAMPLE*** WAExpirySession#+BEGIN_EXAMPLEWASession subclass: #WAExpirySession:nocomment:#+END_EXAMPLE*** WASessionCookieProtectedSession#+BEGIN_EXAMPLEWASession subclass: #WASessionCookieProtectedSessionI am a session with a WASessionCookieProtectionFilter.provide a link here#+END_EXAMPLE*** WATestSession#+BEGIN_EXAMPLEWASession subclass: #WATestSession:nocomment:#+END_EXAMPLE*** WASessionContinuation#+BEGIN_EXAMPLEWARequestHandler subclass: #WASessionContinuationI represent a continuation as part of the flow of pages within a session. I am not a real continuation (as compared to those used in #call: and #answer:), I only represent a specific point in the session. I reference the root component and a memory snapshot of backtracked objects.#+END_EXAMPLE*** WANullSessionContinuation#+BEGIN_EXAMPLEWASessionContinuation subclass: #WANullSessionContinuation:nocomment:#+END_EXAMPLE*** WARenderLoopContinuation#+BEGIN_EXAMPLEWASessionContinuation subclass: #WARenderLoopContinuation:nocomment:#+END_EXAMPLE*** WAActionPhaseContinuation#+BEGIN_EXAMPLEWARenderLoopContinuation subclass: #WAActionPhaseContinuation:nocomment:#+END_EXAMPLE*** WACallbackProcessingActionContinuation#+BEGIN_EXAMPLEWAActionPhaseContinuation subclass: #WACallbackProcessingActionContinuation:nocomment:#+END_EXAMPLE*** WAInitialRenderLoopContinuation#+BEGIN_EXAMPLEWAActionPhaseContinuation subclass: #WAInitialRenderLoopContinuationI'm the initial continuation of a render loop. I just render the initial page. Subclasses may want to override #shouldRedirect and answer true so that a redirect happens before displaying the first page.#+END_EXAMPLE*** WAPluggableActionContinuation#+BEGIN_EXAMPLEWAActionPhaseContinuation subclass: #WAPluggableActionContinuationThis continuation executes an action (any class that implements #value or #value:). If possible, the renderContext is passed in as an argument. When the action is complete, if a response hasn't been returned, control is passed to a render continuation.'Instance Variables:	action	<BlockClosure | BlockContext | GRDelayedSend | MessageSend | WAContinuation | WAPartialContinuation>:important:#+END_EXAMPLE*** WARenderPhaseContinuation#+BEGIN_EXAMPLEWARenderLoopContinuation subclass: #WARenderPhaseContinuation:nocomment:#+END_EXAMPLE*** WAFlushingRenderPhaseContinuation#+BEGIN_EXAMPLEWARenderPhaseContinuation subclass: #WAFlushingRenderPhaseContinuation:nocomment:#+END_EXAMPLE*** WATestNoopRequestHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WATestNoopRequestHandler:nocomment:#+END_EXAMPLE*** WATestNoopSessionHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WATestNoopSessionHandler:nocomment:#+END_EXAMPLE*** WARequestContext#+BEGIN_EXAMPLE  WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)  WARequestContext encapsulates all the knowledge that should be available while processing a single request.   It does not matter if this is a request to a static file,   an AJAX request,   a long Comet request   or a normal Seaside requestion.  The request context is valid only during the request that caused it.   It should not be stored.   Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.   In both cases this might lead to memory leaks.#+END_EXAMPLE** Response*** WAResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse . I have childrenA WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.See class side initialize protocol for all the responses from the server.#+END_EXAMPLE*** WABufferedResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WABufferedResponseA WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.Instance Variables	contentsStream:		<WriteStream> The contents of this message.Basically a wrapper on a stream that obtains its headers from the parent.#+END_EXAMPLE*** WAComboResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WAComboResponseWAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:renderContentOn: aCanvas	"Render the search page"	self renderSearchLabelOn: aCanvas.	self requestContext request flush. "flush before starting search to give immediate feedback"	self searchResultsDo: [ :result |		self renderSearchResult: result on: aCanvas.		self requestContext request flush "flush after each search result" ]After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.on the TODO, I will investigate this more, later#+END_EXAMPLE*** WAStreamedResponse#+BEGIN_EXAMPLEWAObject subclass: #WAResponse subclass: WAStreamedResponseA WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.Instance Variables	committed:		<Boolean>	Whether the status and header was written to the stream.	externalStream:		<WriteStream>	The external stream to write to.#+END_EXAMPLE*** WAResponseGenerator#+BEGIN_EXAMPLEWAObject subclass: #WAResponseGeneratorThe response generator configures the response of the provided request context according to the called generation method. This class can be subclassed to provide custom response templates.#+END_EXAMPLE*** WAHtmlResponseGenerator#+BEGIN_EXAMPLEWAResponseGenerator subclass: #WAHtmlResponseGeneratorThis subclass overrides certain generation methods to create prettier HTML responses, instead of plain text.#+END_EXAMPLE** Root*** WARoot#+BEGIN_EXAMPLEWAObject subclass: #WARootA WARoot is the root of a document. It is responsible to generate header and footer of a document.#+END_EXAMPLE*** WAHtmlRoot#+BEGIN_EXAMPLEWARoot subclass: #WAHtmlRootA WAHtmlRoot is the root element of an HTML Document (<html>).Instance Variables	bodyAttrs:		<WAHtmlAttributes>	context:			<WARenderContext>	docType:		<String>	headAttrs:		<WAHtmlAttributes>	headElements:	<OrderedCollection<WAHtmlElement>>	htmlAttrs:		<WAHtmlAttributes>	scripts:			<Set<String>>	styles:			<Set<String>>	title:			<String>bodyAttrs	- the attributes of the <body> elementcontext	- the context used to render the contents of the <body> elementdocType	- the document typeheadAttrs	- the attributes of the <head> elementheadElements	- the elements inside the <head> sectionhtmlAttrs	- the attributes of the <html> elementscripts	- contains the strings returned by WAPresenter >> #scriptstyles	- contains the strings returned by WAPresenter >> #styletitle	- the title of the HTML document, the contents of the <title> elementwriteHeadOn: aDocument	aDocument nextPutAll: docType.	aDocument openTag: 'html' attributes: htmlAttrs.	aDocument openTag: 'head' attributes: headAttrs.	self writeElementsOn: aDocument.	self writeStylesOn: aDocument.	self writeScriptsOn: aDocument.	aDocument closeTag: 'head'.	aDocument openTag: 'body' attributes: bodyAttrs#+END_EXAMPLE*** WAXmlRoot#+BEGIN_EXAMPLEWARoot subclass: #WAXmlRootNo comment.writePreambleOn: aDocument	aDocument nextPutAll: '<?xml version="1.0" encoding="'; nextPutAll: self charSet; nextPutAll: '"?>'#+END_EXAMPLE** ScriptGenerator*** WAScriptGenerator#+BEGIN_EXAMPLEWAObject subclass: #WAScriptGeneratorI am responsible to render the loadscripts and make them run on page load. See subclasses for different strategies.#+END_EXAMPLE*** WADefaultScriptGenerator#+BEGIN_EXAMPLEWAScriptGenerator subclass: #WADefaultScriptGeneratorA WADefaultScriptGenerator uses the onLoad event on the body to trigger the load scripts. Events handlers are directly inlined with the respective elements. Both techniques are considered outdated and should be avoided if possible.#+END_EXAMPLE*** WANullScriptGenerator#+BEGIN_EXAMPLEWAScriptGenerator subclass: #WANullScriptGeneratorA script generator that does not support any load scripts. This results in cleaner HTML and should result in slightly faster page loads.#+END_EXAMPLE** Server*** WAServerAdaptor#+BEGIN_EXAMPLEA WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol: - #codec - #usesSmalltalkEncodingInstance Variables	codec:		<WACodec>codec	- the codec used for response conversion from characters to bytes#+END_EXAMPLE*** WATestServerAdapator#+BEGIN_EXAMPLEWAServerAdaptor subclass: #WATestServerAdaptorA WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager#+END_EXAMPLE*** WAWebServerAdaptor                             #+BEGIN_EXAMPLEWAServerAdaptor subclass: #WAWebServerAdaptorWhat does this thing do?It holds a reference to its WAServerManagera porta requestHandlera codeca server of class WebServer from WebClient-Core in squeaka certName#+END_EXAMPLE*** WAServerManager#+BEGIN_EXAMPLEA server manager cares on the available Seaside server adopters#+END_EXAMPLE*** WebServer#+BEGIN_EXAMPLENot a part of Seaside in Squeak, but part of WebClient-CoreI wonder if other WebClient-Core classes are used within the WA framework...WebClient provides a simple yet complete HTTP server implementation.To view the documentation evaluate:	HelpBrowser openOn: WebServerHelp.Does Pharo use a different class?#+END_EXAMPLE** Snapshot#+BEGIN_EXAMPLEClass references show WASessionContinuation and WAUpdateStatesVisitor#+END_EXAMPLE*** WASnapshot#+BEGIN_EXAMPLEWAObject subclass: #WASnapshotI represent a memory snapshot of objects. Objects can be registered by sending the message #register:. All object snapshots are updated by sending #snapshot and restored by sending #restore. To have specific snapshot and restore actions for particular classes, override #snapshotCopy and #restoreFromSnapshot: in your classes.#+END_EXAMPLE** Strategy#+BEGIN_EXAMPLEA Strategy defines a set of algorithms that can be used interchangeably. Modes of transportation to an airport is an example of a Strategy. Several options exist such as driving one's own car, taking a taxi, an airport shuttle, a city bus, or a limousine service. https://sourcemaking.com/design_patterns/strategy#+END_EXAMPLE*** WAHandlerTrackingStrategy#+BEGIN_EXAMPLEWAObject subclass: #WAHandlerTrackingStrategyI am a strategy of how request handlers should be tracked by a WARegistry or subclass.One important thing to remember a WARegistry can contain all kinds of request handlers. The most common case is a WAApplication that contains both WADocumentHandlers and WASessions. Some tracking methods may not be appropriate for some kinds of handlers (eg. a WADocumentHandler should never be tracked using a cookie). Some requests may have multiple keys (eg. a query field for a WADocumentHandler and a cookie for a WASession). It's the job of the strategy to take this into consideration.The 'public' protocol contains the methods that a tracking strategy must implement. The 'private' protocol contains some utility methods that may be helpful implementing these methods.#+END_EXAMPLE*** WAQueryFieldHandlerTrackingStrategy#+BEGIN_EXAMPLEWAHandlerTrackingStrategy subclass: #WAQueryFieldHandlerTrackingStrategyI track request handlers using a query field. This results in URLs looking like this:/tests/functional?_s=de379kaie13This is a very simple and robust approach. It is also very convenient for development. Just remove the _s and you have a new session.However there are some drawbacks. The smallest is aesthetical, the URL in the address bar of the browser is less "clean". Second because the session id is part of the request URL it shows up in all kinds of places. For example server logs. Not only the log of the server running the application but also very web site visited from there because it shows up in the Referer HTTP header. The danger of this is that when somebody knows the session id of somebody else he can take over his session. Most of these problems can be mitigated by adding a WARemoteAddressProtectionFilter or WASessionCookieProtectionFilter to every session. Mind that WARemoteAddressProtectionFilter creates new problems for users with changing IPs (eg. mobile devices) and WASessionCookieProtectionFilter requires cookies.#+END_EXAMPLE*** WASessionTrackingStrategy#+BEGIN_EXAMPLEWAHandlerTrackingStrategy subclass: #WASessionTrackingStrategyI am the abstract base class for tracking strategies that track sessions differently from other request handlers (mostly WADocumentHandlers).Concrete implementsions have to take care that expired document handlers don't expire sessions.#+END_EXAMPLE*** WACookieForBrowserIPForCrawlerTrackingStrategy#+BEGIN_EXAMPLEWASessionTrackingStrategy subclass: #WACookieForBrowserIPForCrawlerTrackingStrategyWACookieForBrowserIPForCrawlerTrackingStrategy uses cookie based session tracking for browsers and IPs for crawlers (they don't support cookies). This way there is never a session key in any URL.This is inspired by:http://www.tomcatexpert.com/blog/2011/05/18/crawler-session-manager-valve#+END_EXAMPLE*** WACookieSessionTrackingStrategy#+BEGIN_EXAMPLEWASessionTrackingStrategy subclass: #WACookieSessionTrackingStrategyI am the abstract base class for tracking strategies that use cookies to track sessions and query fields to track everything else.#+END_EXAMPLE*** WACookieIfSupportedSessionTrackingStrategy#+BEGIN_EXAMPLEWACookieSessionTrackingStrategy subclass: #WACookieIfSupportedSessionTrackingStrategyI use cookies to track sessions if the browser supports it and use query fields (?_s=key) otherwise. I keep adding the session cookie and the session query field until the session cookie shows up in the request. Then I stop adding the query field.#+END_EXAMPLE*** WAEnterpriseAuberginesStrategy#+BEGIN_EXAMPLEWACookieIfSupportedSessionTrackingStrategy subclass: #WAEnterpriseAuberginesStrategyI implement a session tracking strategy that emulates common JavaEE application servers (Tomcat, WildFly AS). I am similar to WACookieIfSupportedSessionTrackingStrategy.I will do the following- add a cookie named JSESSIONID- add a path parameter named jsessionid until we see a cookie, eg. /;jsessionid=1234?_k=5678#+END_EXAMPLE*** WACookieOnlySessionTrackingStrategy#+BEGIN_EXAMPLEWACookieSessionTrackingStrategy subclass: #WACookieOnlySessionTrackingStrategyI track sessions using cookies and everything else using query fields. This works fine as long as the client accepts cookies. This breaks for web crawlers (they don't accept cookies).#+END_EXAMPLE*** WAInvisibleSessionTrackingStrategy#+BEGIN_EXAMPLEWASessionTrackingStrategy subclass: #WAInvisibleSessionTrackingStrategyI am the abstract base class for classes that that use some request attribute that is present on every request for tracking sessions. For document handlers query fields are used.#+END_EXAMPLE*** WAIPSessionTrackingStrategy#+BEGIN_EXAMPLEWAInvisibleSessionTrackingStrategy subclass: #WAIPSessionTrackingStrategyI track sessions using the remote address of a client. Usually you don't want to use this because it causes troubles when multiple users share the same IP (eg. several users from the same company). That's why I'm marked as abstract.There are some special cases like crawlers where it can work though.#+END_EXAMPLE*** WASslSessionTrackingStrategy#+BEGIN_EXAMPLEWAInvisibleSessionTrackingStrategy subclass: #WASslSessionTrackingStrategyI track sessions using the SSL session id. This has the advantage that the session id never shows up in the request as a parameter or cookie.Special server configuration to set the life time of an SSL session may be required.http://www.roseindia.net/javacertification/ibm-287/http_sessions.shtmlhttp://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Frzatz%2F51%2Fprogram%2Fsesdeci.htmhttp://en.wikipedia.org/wiki/Session_fixation#Solution:_Utilize_SSL_.2F_TLS_Session_identifier#+END_EXAMPLE** Url*** WAUrl#+BEGIN_EXAMPLEI represent all portions of an URL as described by the RFC 1738 and updated by RFC 3986. I include scheme, userinfo, host, port, path, parameter, query, and fragment.Instance Variables	scheme:			<String> or nil	user:				<String> or nil	password:			<String> or nil	host:				<String> or nil	port:				<Integer> or nil	path:				<OrderedCollection> or nil	slash:				<Boolean>	queryFields:		<WARequestFields> or nil	fragment:			<String> or nil	pathParameters:	<GROrderedMultiMap> or nil		A Primer on URL encoding:http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding		Path Parameters:http://doriantaylor.com/policy/http-url-path-parameter-syntaxyou can have multiple name without values/path/name;param1;p2;p3or names with multiple values;param=val1,val2,val3#+END_EXAMPLE** Visitor*** WAVisitor#+BEGIN_EXAMPLEWAObject subclass: #WAVisitorCommon superclass for all visitors (visitor pattern)#+END_EXAMPLE*** WAAttributeVisitor#+BEGIN_EXAMPLEWAVisitor subclass: #WAAttributeVisitorA visitor of attributes#+END_EXAMPLE*** WAUserConfigurationEditorVisitor                             #+BEGIN_EXAMPLEWAAttributeVisitor subclass: #WAUserConfigurationEditorVisitor#+END_EXAMPLE** ValueHolder*** WAValueHolder#+BEGIN_EXAMPLEWAObject subclass: #WAValueHolderI wrap a single object. I am like value holder except that I am portable and don't include the Model cruft in Squeak.#+END_EXAMPLE** HOWTO#+BEGIN_EXAMPLEan assortment of howtos follows#+END_EXAMPLE*** Clear Sessions#+BEGIN_EXAMPLETo manually expire a session call #expire.A good way to clear all sessions is the following code:WARegistry clearAllHandlers.WAPlatform current garbageCollectHere is another one:https://discord.com/channels/223421264751099906/311419918631305218/940852922776948746how to end a session and redirect.#+END_EXAMPLE** Bibliography#+BEGIN_EXAMPLE  https://github.com/gettimothy/Doc-Seaside  https://github.com/seasidest  https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration  https://sourcemaking.com/design_patterns/strategy  http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding#+END_EXAMPLE