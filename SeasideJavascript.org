*  SeasideJavascript#+STARTUP: content align#+FILETAGS: :programming:#+TAGS:pharo:squeak:nocomment:important:** Introduction #+BEGIN_EXAMPLEWorking Notes of an "in depth" study of the Seaside guts and patterns.This documentation lives here:   https://github.com/gettimothy/Doc-SeasideJavascript#+END_EXAMPLE** Todo#+BEGIN_EXAMPLEBe able to generate any javascript from these classes.#+END_EXAMPLE** Javascript Events#+BEGIN_EXAMPLE((WABuilder on: WAHtmlCanvas)	rootClass: WAHtmlRoot;	documentClass: WAHtmlDocument)		render:[:h | h div onClick:'dude']((WABuilder on: WAHtmlCanvas)	rootClass: WAHtmlRoot;	documentClass: WAHtmlDocument)		render:[:h | h div onMouseOut:'dude']      ((WABuilder on: WAHtmlCanvas)	rootClass: WAHtmlRoot;	documentClass: WAHtmlDocument)		render:[:h | h div onKeyUp:'dude'] #+END_EXAMPLE                      ** JS Hierarchy*** JSObject#+BEGIN_EXAMPLEWAObject subclass: #JSObjectI represent the abstract root of all JavaScript objects in the Smalltalk world. My subclasses provide accessors and action methods to configure instances of myself and implement the method #javascriptContentOn: to emit valid JavaScript code for my presentation.Instance Variables	decoration:		<JSObject|JSDecoration>	renderContext:		<WARenderContext>	rendererClass:		<WARenderer>#+END_EXAMPLE*** JSJoin#+BEGIN_EXAMPLE#+END_EXAMPLE*** JSJson#+BEGIN_EXAMPLE#+END_EXAMPLE*** JSLogger#+BEGIN_EXAMPLE#+END_EXAMPLE*** JSScript#+BEGIN_EXAMPLEJSObject subclass: #JSScriptI am a bucket, javascript statements are added to me.I represent a sequence of JavaScript statements.#+END_EXAMPLE#+BEGIN_EXAMPLE(JSScript new javascript) = (JSScript new)(JSScript new javascript)	alert: 'Hello'#+END_EXAMPLE*** JSFunction#+BEGIN_EXAMPLE#+END_EXAMPLE*** JSDecoration#+BEGIN_EXAMPLE#+END_EXAMPLE** JQuery  Hierarchy#+BEGIN_EXAMPLEJQuery Core Libraries look like they were created by hand.All they do is wrap the javascript.#+END_EXAMPLE** JQAjax Hierarchy** JQWidget  Hierarchy** Javascript HOWTO#+BEGIN_EXAMPLEan assortment of howtos follows#+END_EXAMPLE** Bibliography#+BEGIN_EXAMPLE  https://github.com/gettimothy/Doc-Seaside  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference    https://stackoverflow.com/questions/29756591/smalltalk-seaside-jquery-ajax-callback  I represent the JSON object (www.json.org) that is supported by most modern web browsers. For older browsers I require WAJsonDeploymentLibrary or WAJsonDevelopmentLibrary to be included.#+END_EXAMPLE** RenderOnAStream#+BEGIN_EXAMPLE	Given....	((WABuilder on: WAHtmlCanvas)		rootClass: WAHtmlRoot;		documentClass: WAHtmlDocument)			render:[:h | h div onKeyUp:'dude']	render: anObject on: aStream		"Render anObject and return the contents of the resulting Document as a String.		anObject must understand #renderOn:. Commonly anObject will be a one-argument		block, which will be evaluated with the appropriate renderer."		| context document renderer |		document := self documentClass on: aStream codec: self codec.    "instantiate a WAHtmlDocument on the stream with a codec from the request context; GRNullCodec if not found"										  set the xmlEncoder and urlEncoder from GRPlatform		document scriptGenerator: self scriptGeneratorClass new.          "set the 'defunct' script generator. "		context := WARenderContext new.                                    "create a WARenderContext. Callbacks dictionary is instantiated here."		self rendererClass configureRenderContext: context.                 "The WAHtmlCanvas (A WARenderer) configres the new WARenderContext....											 WARenderContext visitor is set to a WARenderVisitor   (this will be replaced two steps later)											 The WArenderContext is wrapped in a WARenderingGuide (Sublclass of WAPresenterGuide) and then											 Assigned to WARenderContext visitor, replacing the WARenderVisitor.  (Kinda cool model)		context document: document.                                         "assign the WAHtmlDocument to the WARenderContext"		context actionUrl: self actionUrl; resourceUrl: self resourceUrl.   "if actionUrl is nil, give it a WAUrl new"		renderer := self rendererClass context: context.                     "calls WAHtmlCanvas(WARenderer) basicNew initalizeSWithContext: aRenderContext; yourself gives a WAHtmlCanvas with "		self openDocument: document context: context.                        "if WABuilder fullDocument returns 'false' the WAbuilder is returned. it looks like the fullDocument has to be explicitly set"		renderer render: anObject; flush.                                     "WAHtmlCanvas render:  if anObject is a block BlockClosure >> renderOn: is sent:   	renderOn: aRenderer                                                                                                                                                                         		self numArgs = 0                                                                                                                                                                        			ifTrue: [ self value ]                                                                                                                                                                        			ifFalse: [ self value: aRenderer ]"                                                                                       if we walk into the Block we meet :h a WAHtmlCanvas  <---this is very important in here.		self closeDocument: document#+END_EXAMPLE#+BEGIN_EXAMPLEThe WABuilder in render: anObject on: aStream  ...configures the document, context and renderer then...openDocumentrenderer render: anObject; flush.closeDocument.#+END_EXAMPLE