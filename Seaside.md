# Table of Contents1.  [Seaside](#orgf3b1c56)    1.  [Introduction](#orged8e2fe)    2.  [Followups](#org17218cb)    3.  [Cache](#org7744515)        1.  [WACache](#org1560633)        2.  [WABidirectionalCache](#org3d2211c)        3.  [WAPredictableCache](#org69f0ea5)    4.  [Codec](#org9330e91)        1.  [GRCodec](#org6a07321)        2.  [GRNullCodec](#org8ab35be)        3.  [GRGenericCodec](#orga63b3a5)        4.  [GRPharoLating1Codec](#orga3aca18)        5.  [GRPharoUtf8Codec](#org593e019)    5.  [Context](#org63b1131)        1.  [WAContextTest](#org3bf8267)        2.  [WARequestContext](#org5163367)    6.  [KeyGenerator](#orgbd496c9)        1.  [WAKeyGenerator](#orgefa028c)        2.  [WAPrecomputedKeyGenerator](#org1089791)    7.  [Rendering](#org75d63f4)        1.  [WARenderContext](#orgaa37d16)    8.  [Request](#orga1162f2)        1.  [WARequest](#orgb6e080a)    9.  [RequestHandler](#org6964f6d)        1.  [WARequestHandler](#org9df20b9)        2.  [WADispatcher](#org51d815d)        3.  [WADocumentHandler](#org58487a6)        4.  [WAFileHandler](#orgaf0e06b)        5.  [WALegacyRedirectionHandler](#org5c33f94)        6.  [WANextUnconsumedPathElementRequestHandler](#org9b8da92)        7.  [WARegistry](#org2870621)        8.  [WARedirectingRegistry](#orgb0e5cc3)        9.  [](#orgcf49d1e)    10. [Response](#org1f0b5e1)        1.  [WAResponse](#orgfd8e114)        2.  [WABufferedResponse](#org70be876)        3.  [WAComboResponse](#orgaef32a9)        4.  [WAStreamedResponse](#orgb31ccdf)    11. [Server](#orga908990)        1.  [WAServerAdaptor](#orgb71b0da)        2.  [WATestServerAdapator](#orgd956c7b)        3.  [WAWebServerAdaptor](#orge2747cc)        4.  [WAServerManager](#org505bcbd)        5.  [WebServer](#orgb27892d)    12. [Visitor](#org2e84845)        1.  [WARenderVisitor](#orgb0d3b60)        2.  [WAUserConfigurationEditorVisitor](#orgd4acbef)        3.  [WAPainterVisitor](#org697b563)        4.  [WAHaloVisitor](#org34580a6)        5.  [WAInitialRequestVisitor](#org439775d)        6.  [WAPluggablePresenterVisitor](#org35fa8e0)        7.  [WAPresenterGuide](#org71714f9)        8.  [WARenderingGuide](#org4f2419a)        9.  [WAVisiblePresenterGuide](#org0ed8579)        10. [WAAllPresenterGuide](#orgb21fba2)        11. [WARenderVisitor](#org8cacaf6)        12. [WATaskVisitor](#org1486690)        13. [WAUpdateRootVisitor](#org3c3e10e)        14. [WAUpdateStatesVisitor](#org3aadac5)        15. [WAUpdateUrlVisitor](#org407d7f9)    13. [Todo below here](#org215a704)    14. [Errors](#org29fc9fb)        1.  [WAError](#org32da376)        2.  [WAAuthConfigurationError](#org9724299)    15. [GRPlatform](#orge90aec1)        1.  [GRPharoPlatform](#org2dfc16f)        2.  [GRSqueakPlatform](#org6aa9b8c)    16. [Transient Value Holder](#org037c9c0)        1.  [WAValueHolder](#org894950e)    17. [WADynamic Variable](#orgb59c29c)    18. [WAKeyGenerator](#orgcc6e025)    19. [WAMutex](#org2c1afd2)    20. [WAVisitor](#org6aef979)    21. [WACookie](#org5273bd5)    22. [WARequestCookie](#orgee7e765)    23. [WAMergedRequestFields](#org09111d8)    24. [Bibliography](#orgdda2068)<a id="orgf3b1c56"></a># Seaside<a id="orged8e2fe"></a>## Introduction    Working Notes of an "in depth" study of the Seaside guts and patterns.<a id="org17218cb"></a>## Followups    Standardize no class comment for search    Squeak uses WebServer, does Pharo use Kom thing?    Write a mockups of     WAComboResponse    WAStreamedResponse    get a sense of the things WAVisitor children do.<a id="org7744515"></a>## Cache<a id="org1560633"></a>### WACache    WAObject subclass: #WACache            WACacheis the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCache.        >>keySize returns 16        All other instance methods implement self subclassResponsibility<a id="org3d2211c"></a>### WABidirectionalCache    WACache subclass: #WABidirectionalCache        I support key -> value and value -> key mappings and never forget anything.        I also implement serveral methods of Dictionary.<a id="org69f0ea5"></a>### WAPredictableCache    WABidirectionalCache subclass: #WAPredictableCache        A WAPredictableCache is a WACache that uses incrementing numbers as cache keys. This way the keys are predictable.     This is useful for tests.1.  test        test<a id="org9330e91"></a>## Codec    When a WAServerAdaptor is spun up, it has a GRNullCodec as its default.        the codec used for response conversion from characters to bytes    DECODING: Outside Data Converted Into the Image    ENCODING: Image data sent to outside the Image<a id="org6a07321"></a>### GRCodec            A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding)     and back outside the image (encoding).         The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.<a id="org8ab35be"></a>### GRNullCodec    GRObject subclass: #GRCodec        The null codec always returns the original streams.     It assumes that the outside world uses the same encoding as the inside world.     This is highly efficient as no transformation is applied to the data, but has its drawbacks.<a id="orga63b3a5"></a>### GRGenericCodec    GRCodec subclass: #GRPharoGenericCodec<a id="orga3aca18"></a>### GRPharoLating1Codec    GRNullCodec subclass: #GRPharoLatin1Codec            A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).<a id="org593e019"></a>### GRPharoUtf8Codec    GRCodec subclass: #GRPharoUtf8Codec        A WAUtf8Codec is a WACodec optimized for UTF-8.<a id="org63b1131"></a>## Context<a id="org3bf8267"></a>### WAContextTest<a id="org5163367"></a>### WARequestContext    WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)    WARequestContext encapsulates all the knowledge that should be available while processing a single request.     It does not matter if this is a request to a static file,     an AJAX request,     a long Comet request     or a normal Seaside requestion.        The request context is valid only during the request that caused it.     It should not be stored.     Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.     In both cases this might lead to memory leaks.<a id="orgbd496c9"></a>## KeyGenerator<a id="orgefa028c"></a>### WAKeyGenerator    WAObject subclass: #WAKeyGenerator<a id="org1089791"></a>### WAPrecomputedKeyGenerator    WAKeyGenerator subclass: #WAPrecomputedKeyGenerator<a id="org75d63f4"></a>## Rendering<a id="orgaa37d16"></a>### WARenderContext    WAObject subclass: #WARenderContext        A WARenderContext provides all the state needed by a Renderer to do its work.        It is a decoupling device between whatever is initiating rendering and the Renderer itself.<a id="orga1162f2"></a>## Request<a id="orgb6e080a"></a>### WARequest        WAObject subclass: #WARequest  has no children        I am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.        Instance Variables    	method:			<String>    	uri:					<WAUrl>    	version:				<WAHttpVersion>    	remoteAddress:	<String>    	headers:			<Dictionary<String, String>>    	cookies:			<Collection<WARequestCookie>>    	body:				<String>    	postFields:			<WARequestFields>    	sslSessionId:		<String>    			    method    	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		        uri    	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.    	    version    	- The version of this request.    	    remoteAddress    	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.        headers    	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.    	    cookies    	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.    	    body    	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.    	    postFields    	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.    	    sslSessionId    	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.<a id="org6964f6d"></a>## RequestHandler<a id="org9df20b9"></a>### WARequestHandler        WAObject subclass: #WARequestHandler        WARequestHandler is an abstract class whose subclasses handle http requests.     Most of the methods are either empty or return a default value.         Subclasses must implement the following messages:    	handleFiltered:	process the request<a id="org51d815d"></a>### WADispatcher    WARequestHandler subclass: #WADispatcher        explore: WADispatcher default    This is the entry point for Seaside.        see WAApplication , which is stored in the WADisplatcher.            WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc).         WADispatcher class>>default is the top level dispatcher.         When a Seaside application is registered as "foo" the application is added to the top level dispatcher.     The application is added to the entryPoints of the dispatcher at the key "foo".     If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo".     That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".           When a http request is received it is sent to WADispatcher class>>default to find the correct handler for the request.     If a handler exists for the request is sent to that handler.     Otherwise the request is sent to the not found response generator.        The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class>>default.     One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming).         Instance Variables:    	defaultName	<String>    	entryPoints	<(Dictionary of: WAEntryPoint)>	 the keys are strings, which are the names and URL path segments for the handler at that key<a id="org58487a6"></a>### WADocumentHandler    WARequestHandler subclass: #WADocumentHandler            WADocumentHandler handles requests for images,     text documents and     binary files (byte arrays).     This class is not normally used directly.     A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler.     Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document,     registers the handler with a Registry,     and adds the correct url in the tag for the document.        Instance Variables:    	document	<WAMimeDocument>	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.<a id="orgaf0e06b"></a>### WAFileHandler    WARequestHandler subclass: #WAFileHandler            Seaside serves static files using WAFileLibrary subclasses.     WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server.     WAFileHandler is registered with the default WADispatcher automatically.<a id="org5c33f94"></a>### WALegacyRedirectionHandler    WARequestHandler subclass: #WALegacyRedirectionHandler        I provide compatibility with old Seaside URLs that have Seaside in the path (eg. '/seaside/examples/counter') by simply removing it.<a id="org9b8da92"></a>### WANextUnconsumedPathElementRequestHandler    WARequestHandler subclass: #WANextUnconsumedPathElementRequestHandler        :nocomment:<a id="org2870621"></a>### WARegistry    WARequestHandler subclass: #WARegistry        WARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd.     WARegistry checks incoming request URLs for a key and looks for a matching active request handler.     If one exists, the request is sent to the proper handler.     If not, the request is either a new request (in which case #handleDefaultRequest: is called)     or a request to a now-inactive handler (in which case #handleExpiredRequest: is called).         These two methods allow subclasses to properly handle these requests.        Subclasses must implement the following messages:    	handleDefaultRequest:    		Handle a request without a session key, ie a new request.    	handlerField    		The URL parameter in which to store the request handler key.        Instance Variables:    	cache - an instance of WACache to hold the stored request handlers1.  WAApplication                 WARegistry subclass: #WAApplication                        WAApplication is the starting point for a Seaside application.                 When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher.   (explore: WADispatcher default)                The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application.                 "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)        If you change the cache configuration  you need to send #initializeCache for the changes to take effect.                "libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.                Registering an Application.        	An application can be registered with a dispatcher by using the Seaside configuration page or via code.         Below MyComponent is a subclass of WAComponent.         The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration.                 MyComponent class>>initialize        	"self initialize"        	| application |        	application := self registerAsApplication: 'sample'.        	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.        	application addLibrary: SampleLibrary.        	application configuration addAncestor: GlorpConfiguration new.        	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.        	application preferenceAt: #databaseServer put: '127.0.0.1'.        	application preferenceAt: #databaseConnectString put: 'glorptests'.                MyComponent>>someInstanceMethod        	"example of how to access attributes (preferences)"        	self session application preferenceAt: #glorpDatabasePlatform        1.  WARedirectingApplication                WAApplication subclass: #WARedirectingApplication                        I revert to the old < 3.3.0 behavior which is easier for tests.<a id="orgb0e5cc3"></a>### WARedirectingRegistry    WARegistry subclass: #WARedirectingRegistry        I revert to the old < 3.3.0 behavior which is easier for tests.<a id="orgcf49d1e"></a>###     WARequestHandler subclass: #WARestfulHandler<a id="org1f0b5e1"></a>## Response<a id="orgfd8e114"></a>### WAResponse                WAObject subclass: #WAResponse . I have children                A WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.    See class side initialize protocol for all the responses from the server.<a id="org70be876"></a>### WABufferedResponse                WAObject subclass: #WAResponse subclass: WABufferedResponse            A WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.        Instance Variables    	contentsStream:		<WriteStream> The contents of this message.            Basically a wrapper on a stream that obtains its headers from the parent.<a id="orgaef32a9"></a>### WAComboResponse                WAObject subclass: #WAResponse subclass: WAComboResponse        WAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:        renderContentOn: aCanvas    	"Render the search page"        	self renderSearchLabelOn: aCanvas.    	self requestContext request flush. "flush before starting search to give immediate feedback"        	self searchResultsDo: [ :result |    		self renderSearchResult: result on: aCanvas.    		self requestContext request flush "flush after each search result" ]        After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.        Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.        on the TODO, I will investigate this more, later<a id="orgb31ccdf"></a>### WAStreamedResponse    WAObject subclass: #WAResponse subclass: WAStreamedResponse        A WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.        Instance Variables    	committed:		<Boolean>	Whether the status and header was written to the stream.    	externalStream:		<WriteStream>	The external stream to write to.<a id="orga908990"></a>## Server<a id="orgb71b0da"></a>### WAServerAdaptor    A WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol:     - #codec     - #usesSmalltalkEncoding        Instance Variables    	codec:		<WACodec>        codec    	- the codec used for response conversion from characters to bytes<a id="orgd956c7b"></a>### WATestServerAdapator    WAServerAdaptor subclass: #WATestServerAdaptor    A WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager<a id="orge2747cc"></a>### WAWebServerAdaptor    WAServerAdaptor subclass: #WAWebServerAdaptor                What does this thing do?    It holds     a reference to its WAServerManager    a port    a requestHandler    a codec    a server of class WebServer from WebClient-Core in squeak    a certName<a id="org505bcbd"></a>### WAServerManager    A server manager cares on the available Seaside server adopters<a id="orgb27892d"></a>### WebServer    Not a part of Seaside in Squeak, but part of WebClient-Core    I wonder if other WebClient-Core classes are used within the WA framework...            WebClient provides a simple yet complete HTTP server implementation.        To view the documentation evaluate:        	HelpBrowser openOn: WebServerHelp.            Does Pharo use a different class?<a id="org2e84845"></a>## Visitor<a id="orgb0d3b60"></a>### WARenderVisitor    A visitor that renders Painters.     It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.<a id="orgd4acbef"></a>### WAUserConfigurationEditorVisitor    WAAttributeVisitor subclass: #WAUserConfigurationEditorVisitor<a id="org697b563"></a>### WAPainterVisitor    WAVisitor subclass: #WAPainterVisitor            An implementation of the Visitor pattern for Painter subclasses.<a id="org34580a6"></a>### WAHaloVisitor    WAPainterVisitor subclass: #WAHaloVisitor<a id="org439775d"></a>### WAInitialRequestVisitor        WAPainterVisitor subclass: #WAInitialRequestVisitor<a id="org35fa8e0"></a>### WAPluggablePresenterVisitor    WAPainterVisitor subclass: #WAPluggablePresenterVisitor    NO CLASS COMMENT<a id="org71714f9"></a>### WAPresenterGuide    WAPainterVisitor subclass: #WAPresenterGuide        WAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations.     Along the way, they will ask their client to visit each Painter they come across.    This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.<a id="org4f2419a"></a>### WARenderingGuide    WAPresenterGuide subclass: #WARenderingGuide        Currently an empty class but still present for clarity and to allow customization of Rendering behaviour.<a id="org0ed8579"></a>### WAVisiblePresenterGuide    WAPresenterGuide subclass: #WAVisiblePresenterGuide        Visit the tree of all Presenters and their registered #children.     Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.<a id="orgb21fba2"></a>### WAAllPresenterGuide    WAVisiblePresenterGuide subclass: #WAAllPresenterGuide        Visit the tree of all Presenters and their registered #children.<a id="org8cacaf6"></a>### WARenderVisitor        WAPainterVisitor subclass: #WARenderVisitor        A visitor that renders Painters.     It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.<a id="org1486690"></a>### WATaskVisitor    WAPainterVisitor subclass: #WATaskVisitor<a id="org3c3e10e"></a>### WAUpdateRootVisitor    WAPainterVisitor subclass: #WAUpdateRootVisitor        A visitor which asks Painters to update a WARoot subclass using #updateRoot:.        This is used to update the root of the Document stored on a WARenderContext.<a id="org3aadac5"></a>### WAUpdateStatesVisitor    WAPainterVisitor subclass: #WAUpdateStatesVisitor<a id="org407d7f9"></a>### WAUpdateUrlVisitor    WAPainterVisitor subclass: #WAUpdateUrlVisitor        A visitor which asks Painters to update a WAUrl subclass using #updateRoot:.        This is used to update the base URL stored on a WARenderContext.<a id="org215a704"></a>## Todo below here<a id="org29fc9fb"></a>## Errors<a id="org32da376"></a>### WAError        GRError subclass: #WAError        Common superclass for Seaside errors<a id="org9724299"></a>### WAAuthConfigurationError    WAError subclass: #WAAuthConfigurationError        A WAAuthConfigurationError is signaled when no WAAuthConfiguration was added to an application that is behind a WAAuthenticationFilter.<a id="orge90aec1"></a>## GRPlatform<a id="org2dfc16f"></a>### GRPharoPlatform    GRPlatform subclass: #GRPharoPlatform        A GRPharoPlatform is the Pharo implementation of GRPlatform, the Grease class that provides functionality that can not be implemented in a platform independent way.<a id="org6aa9b8c"></a>### GRSqueakPlatform    GRPharoPlatform subclass: #GRSqueakPlatform<a id="org037c9c0"></a>## Transient Value Holder<a id="org894950e"></a>### WAValueHolder    WAObject subclass: #WAValueHolder        I wrap a single object.     I am like value holder except that I am portable and don't include the Model cruft in Squeak.<a id="orgb59c29c"></a>## WADynamic Variable<a id="orgcc6e025"></a>## WAKeyGenerator<a id="org2c1afd2"></a>## WAMutex<a id="org6aef979"></a>## WAVisitor<a id="org5273bd5"></a>## WACookie                I represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.    You can never trust information in a cookie, the client is free to edit it.    I model only a part of the full cookie specification.        Browser support:    http://www.mnot.net/blog/2006/10/27/cookie_fun        Netscape spec    http://cgi.netscape.com/newsref/std/cookie_spec.html        Cookie spec    http://tools.ietf.org/html/rfc2109        Cookie 2 spec    https://tools.ietf.org/html/rfc6265        HttpOnly    http://msdn2.microsoft.com/en-us/library/ms533046.aspx    https://bugzilla.mozilla.org/show_bug.cgi?id=178993        Compared to WARequestCookie I represent the information that is sent to the user agent.<a id="orgee7e765"></a>## WARequestCookie    A WARequestCookie is the cookie the user agent sent to the server.        Instance Variables    	domain:			<String>    	key:			<String>    	path:			<String>    	pathEncoded:	<String>    	ports:			<Collection<Integer>>    	value:			<String>    	version:			<Integer>        domain    	- xxxxx        key    	- xxxxx        path    	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:      1.  Let uri-path be the path portion of the request-uri if such a           portion exists (and empty otherwise).  For example, if the           request-uri contains just a path (and optional query string),           then the uri-path is that path (without the %x3F ("?") character           or query string), and if the request-uri contains a full           absoluteURI, the uri-path is the path component of that URI.           2.  If the uri-path is empty or if the first character of the uri-           path is not a %x2F ("/") character, output %x2F ("/") and skip           the remaining steps.           3.  If the uri-path contains no more than one %x2F ("/") character,           output %x2F ("/") and skip the remaining step.           4.  Output the characters of the uri-path from the first character up           to, but not including, the right-most %x2F ("/").        ports    	- xxxxx        value    	- xxxxx        version    	- the version of the cookie specification supported, currently only 1 is known<a id="org09111d8"></a>## WAMergedRequestFields        Provides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.<a id="orgdda2068"></a>## Bibliography    https://github.com/seasidest