# Table of Contents1.  [Seaside](#orged6feea)    1.  [Introduction](#orga69d7bd)    2.  [Todo](#org103b2fa)    3.  [JSCore](#org435eb4e)        1.  [JSJoin](#org079a930)        2.  [JSJson](#org9bc8ef1)        3.  [JSLogger](#orgfc40ae4)        4.  [JSScript](#org613af59)        5.  [JSFunction](#orga3cb296)    4.  [JSDecoration](#org5b60e2d)    5.  [JQuery](#orgccd347b)    6.  [JQ](#orgb9adfaa)    7.  [JQAjax](#orgc3c2369)    8.  [JQWidget](#orgf671fa4)    9.  [Authentication](#org5bf9ad4)    10. [Brush](#org91a788e)        1.  [WACompund](#orgddb3576)        2.  [WAJsonBrush](#orgc8b93d1)        3.  [WAJsonArrayBrush](#org76eb923)        4.  [WAJsonElementBrush](#orge1ba9da)        5.  [WAJsonKeyValueBrush](#orgbc15b34)        6.  [WAJsonValueBrush](#orgc0222cc)        7.  [WAJsonObjectBrush](#orgf0baf37)        8.  [WATagBrush](#org43287e6)        9.  [WAGenericTag](#orgbe4ed5c)        10. [WARadioGroup](#org0e4bba0)    11. [Builder](#orgbf8f569)        1.  [Builder HTML Canvas](#org254b093)        2.  [Builder Json Canvas](#orga4c2cab)        3.  [Builder XML Canvas](#org0af6a7c)    12. [Cache](#org1225e34)        1.  [WACache](#orga0c3ee0)        2.  [WABidirectionalCache](#org563f708)        3.  [WAPredictableCache](#orga5fb89e)        4.  [WAExpiringCache](#org47e3bb8)        5.  [WABulkReapingCache](#org5d339e4)        6.  [WABulkReapingCacheEntry](#org2a4f32f)        7.  [WAReducedConflictCounter](#orgeb8b1c4)        8.  [WAHashCache](#orgd4bc83c)        9.  [WACacheKeyEntry](#org68d6d55)        10. [WACacheListEntry](#org2eb3550)        11. [WAHashTableSizes](#orga8ebcae)        12. [WACacheConfiguration](#org1fadfc5)        13. [WAMutualExclusionCache](#orgbba1b5e)        14. [WAUnidirectionalCache](#orga3bd07b)    13. [Callback](#orga833a4b)        1.  [WACallback](#orgf250972)        2.  [WAActionCallback](#org952b619)        3.  [WACancelActionCallback](#org14f3bc4)        4.  [WADefaultActionCallback](#org1813040)        5.  [WAImageCallback](#org3c8ddf4)        6.  [WADispatchCallback](#org552e00b)        7.  [WAValueCallback](#org32982f4)        8.  [WAAllValuesCallback](#org0f761ae)        9.  [WAAllEmailsCallback](#orgc7f43d5)        10. [WAAllUrlsCallback](#org4ab65db)        11. [WAEmailCallback](#orge5847fc)        12. [WAMapCallback](#org10951ed)        13. [WAUploadCallback](#org2a3bf84)        14. [WAAllUploadsCallback](#orgfc9f884)        15. [WAUrlCallback](#org5b26133)        16. [WAValuesCallback](#org2b57f18)        17. [WAMultipleValuesCallback](#orgd817a14)        18. [WACallbackRegistry](#orgf756353)    14. [Canvas](#orgb77b43d)    15. [Codec](#org3a4d693)        1.  [GRCodec](#org1043f1d)        2.  [GRNullCodec](#orgf90058c)        3.  [GRPharoLating1Codec](#orge5026ec)        4.  [GRPharoGenericCodec](#orgaa82d60)        5.  [GRPharoUtf8Codec](#org62e9964)    16. [Configuration](#orgf51ae1e)        1.  [WAConfiguration](#org8c8e4ec)        2.  [WAUserConfiguration](#org1f3a969)        3.  [WASharedConfiguration](#orga0d0197)        4.  [WAAttributeSearchContext](#org61f8bdb)        5.  [WAAttributeVisitor](#orgbc3ea03)        6.  [WAConfigurationDescription](#org4545a2f)        7.  [WAConfigurationElement](#orga5d4cf1)        8.  [WAAttribute](#org1815c63)        9.  [WABooleanAttribute](#org0b90405)        10. [WAListAttribute](#org88abfb0)        11. [WAClassBindingAttribute](#orga6b959e)        12. [WAClassBindingCollectionAttribute](#org2cbf000)        13. [WAClassListAttribute](#orgd1caa72)        14. [WACollectionAttribute](#org75ef724)        15. [WANumberAttribute](#org8319b39)        16. [WAIntegerAttribute](#org0d10a72)        17. [WAPasswordAttribute](#org7e2036b)        18. [WAStringAttribute](#orgd03edf7)        19. [WAUrlAttribute](#orgad7af61)        20. [WAAttributeExpression](#orgdba6711)        21. [WAAddRemoveExpression](#orgb348aad)        22. [WAValueExpression](#org4d6fff1)    17. [Configuration System](#org5b618ca)        1.  [WASystemConfiguratino](#org3fe4905)        2.  [WAApplicationConfiguration](#org3a1100d)        3.  [WAAuthConfiguration](#org57ff921)        4.  [WACacheConfiguration](#orgcd3f367)        5.  [WAConfigurationMock](#org32a12dd)        6.  [WADevelopmentConfiguration](#orgb152401)        7.  [WAEmailConfiguration](#org0c40de6)        8.  [WAExceptionFilterConfiguration](#org5a38be7)        9.  [WAFileHandlerConfiguration](#org0bbea7b)        10. [WARegistryConfiguration](#org2efb1a0)        11. [WARenderLoopConfiguration](#org0728cf8)        12. [WARequestHandlingConfiguration](#orgdbb5b0e)        13. [WARestfulConfiguration](#org932f0a7)    18. [Configuration User](#org1f133de)    19. [Context](#orgd8470fc)        1.  [WAContextTest](#org2db1ea6)        2.  [WARequestContext](#org238f0db)    20. [Continuation](#org45a3f8e)        1.  [WAContinuation](#org72b6b42)        2.  [WAPartialContinuation](#org9ccf7bd)    21. [Cookie](#org7af161f)        1.  [WACookie](#orgae1b851)        2.  [WARequestCookie](#org5aa63f8)    22. [Document](#org55f2282)        1.  [WADocument](#org809e6d9)        2.  [WAJsonDocument](#orgade82f9)        3.  [WAXmlDocument](#orgb678614)        4.  [WAHtmlDocument](#org43b9bf8)        5.  [WAPrettyPrintedDocument](#org5cf8eee)        6.  [WAUnescapedDocument](#org90668ab)        7.  [WAHtmlAttributes](#org8292e7e)        8.  [WAConcatenatedHtmlAttributeValue](#org1286da7)        9.  [WAEncoder](#org10ba52e)        10. [WATableBasedEncoder](#org2d626fe)        11. [WAUrlEncoder](#org3c133c6)        12. [WAXmlEncoder](#org26f4962)    23. [Document Elements](#org83fe487)        1.  [WAHtmlElement](#org9ebc69c)        2.  [WABaseElement](#orge043725)        3.  [WAContentElement](#orgc7681fa)        4.  [WALinkElement](#org1bb5e3f)        5.  [WAScriptElement](#orge425bfc)        6.  [WAMetaElement](#orgd4b4a46)        7.  [WAStyleElement](#org1bea78b)        8.  [WAConditionalComment](#orge5cc09a)        9.  [WARevealedConditionalComment](#orge5ecdec)        10. [WAOpeningConditionalComment](#orge777fa5)        11. [WAOpeningRevealedConditionalComment](#org47d5d3c)        12. [WAClosingConditionalComment](#org18285b1)        13. [WAClosingRevealedConditionalComment](#org78b7690)    24. [Error](#orgdcfb885)        1.  [WAError](#orgf332db3)    25. [Exception Handling](#org9cfc982)        1.  [WAExceptionHandler](#orgd01c110)        2.  [WAErrorHandler](#org3c2949d)    26. [Filter](#orgd4f396e)        1.  [WARequestFilter](#orga83455b)        2.  [WAAbstractProtectionFilter](#orga998b74)        3.  [WARemoteAddressProtectionFilter](#org1c4b1b2)        4.  [WASessionCookieProtectionFilter](#org64dde94)        5.  [WAAuthenticationFilter](#org0422176)        6.  [WACORSFilter](#org42d1e11)        7.  [WAConfiguredRequestFilter](#orgb991550)        8.  [WAExceptionFilter](#org5a87b39)        9.  [WATrailingSlashFilter](#org3af3aa0)        10. [WATransactionFilter](#org2fb2a17)        11. [WAAuthConfiguration](#org7d4ed19)        12. [WACurrentExceptionHandler](#orga6ef12c)        13. [WAExceptionFilterConfiguration](#org706e6ad)    27. [GRObject](#orge9b7a4f)        1.  [WAEmailAddres](#org8589756)        2.  [WAFile](#org70e5e8f)        3.  [WAHeaderFields](#orga9d7117)        4.  [WAHttpVersion](#org0b8d644)        5.  [WALocale](#orgee081a2)        6.  [WAMergedRequestFields](#orgd48d514)        7.  [WAMimeDocument](#orgd334658)        8.  [WAMimeType](#orgcb615a5)        9.  [WAQualifiedValue](#orgbae4a72)        10. [WAAccept](#orgd4fe7c8)        11. [WAAcceptCharset](#orgfd91847)        12. [WAAcceptEncoding](#org7aff255)        13. [WAAcceptLanguage](#org780cef5)    28. [Handlers](#orgcd81f0a)    29. [Key Generator](#orgcacb597)        1.  [WAKeyGenerator](#orgac50c37)        2.  [WAPrecomputedKeyGenerator](#org9cb8105)    30. [Layer](#org6513fe2)    31. [Library](#org15c66de)        1.  [WAAbstractFileLibrary](#org46194fe)        2.  [WAFileLibrary](#orgb4ba4bb)        3.  [WAFileMetadataLibrary](#org9f24dc8)        4.  [WAFileHandler](#org75b4847)        5.  [WAFileHandlerConfiguration](#org5bb26af)        6.  [WAFileHandlerListing](#org51ebdbb)        7.  [WAForbiddenFileHandlerListing](#org06da601)        8.  [WATextFileHandlerListing](#orge1e8205)        9.  [WAFileLibraryResource](#org3489011)    32. [Mutex](#org2d32481)        1.  [WAMutex](#org42d2297)    33. [WAObject](#org6d4108d)    34. [Painter](#orgdbb2bb4)        1.  [WAPainterVisitor](#org7ed1930)        2.  [WAHaloVisitor](#org366f29f)        3.  [WAInitialRequestVisitor](#orge744ba4)        4.  [WAPluggablePresenterVisitor](#org82cd49a)        5.  [WAPresenterGuide](#org3211a25)        6.  [WARenderingGuide](#org36850d8)        7.  [WAVisiblePresenterGuide](#orge72daaf)        8.  [WAAllPresenterGuide](#org6366ca6)        9.  [WARenderVisitor](#org579ee65)        10. [WATaskVisitor](#org5547d2f)        11. [WAUpdateRootVisitor](#orgb4dde51)        12. [WAUpdateStatesVisitor](#org612a56e)        13. [WAUpdateUrlVisitor](#orga68d150)    35. [ProcessSpecificVariables](#org03bc222)        1.  [DynamicVariable](#orgc64acdb)        2.  [GRDynamicVariable](#org68c0953)        3.  [WADynamicVariable](#orgc62b917)        4.  [WACurrentCallbackProcessingActionContinuation](#orga979d5f)        5.  [WACurrentExceptionHandler](#org5e8e85c)        6.  [WACurrentRequestContext](#orgfc18d54)    36. [Registry](#orgf0acff9)        1.  [WARegistry](#org52cfc57)        2.  [WARegistryConfiguration](#org25dde5f)    37. [Renderer](#orgc519f4a)        1.  [WARenderer](#orgbd5c305)        2.  [WACanvas](#org6ae2816)        3.  [WAJsonCanvas](#org2fa318a)        4.  [WATagCanvas](#org5a9c63e)        5.  [WAHtmlCanvas](#orgebc0312)        6.  [WAXmlCanvas](#orgaaefbf9)    38. [Render Context](#org7554954)        1.  [WARenderContext](#orgd4822d6)    39. [Request](#org0870fbb)        1.  [WARequest](#org5011584)    40. [Request Handling and  Continuation](#org941e5b9)        1.  [WARequestHandler](#org86102b8)        2.  [WADispatcher](#org45a69fe)        3.  [WADocumentHandler](#orga88fa05)        4.  [WAFileHandler](#org805c2b2)        5.  [WAPathConsumer](#org6da91b7)        6.  [WALegacyRedirectionHandler](#org4df9865)        7.  [WANextUnconsumedPathElementRequestHandler](#orgc239a83)        8.  [WARegistry](#orgd9ce377)        9.  [WARegistryConfiguration](#org2821861)        10. [WARequestHandlingConfiguration](#org498fb35)        11. [WAApplication](#org280492a)        12. [WARedirectingApplication](#orgce6ac22)        13. [WARedirectingRegistry](#org0f97a70)        14. [WARestfulHandler](#org7a78cc4)        15. [WACORSResourceExample](#org2549dc3)        16. [WASession](#org0099fbb)        17. [WAExpirySession](#org08bca89)        18. [WASessionCookieProtectedSession](#org7927e05)        19. [WATestSession](#org9988324)        20. [WASessionContinuation](#orgd82bc1d)        21. [WANullSessionContinuation](#orgc2bb264)        22. [WARenderLoopContinuation](#orgf3ed612)        23. [WAActionPhaseContinuation](#orgd398cf9)        24. [WACallbackProcessingActionContinuation](#orgac020df)        25. [WAInitialRenderLoopContinuation](#org2be19ef)        26. [WAPluggableActionContinuation](#org249f9e3)        27. [WARenderPhaseContinuation](#orgd20f641)        28. [WAFlushingRenderPhaseContinuation](#org0379ac3)        29. [WATestNoopRequestHandler](#orgd49ead2)        30. [WATestNoopSessionHandler](#org8d0d5a2)        31. [WARequestContext](#orge60a595)    41. [Response](#org1dfd06a)        1.  [WAResponse](#org474fcb8)        2.  [WABufferedResponse](#orgfeb3fac)        3.  [WAComboResponse](#org8aac07e)        4.  [WAStreamedResponse](#orgab341d1)        5.  [WAResponseGenerator](#orga25d5da)        6.  [WAHtmlResponseGenerator](#org41e5f88)    42. [Root](#org7c241c6)        1.  [WARoot](#org1b64564)        2.  [WAHtmlRoot](#orgb2a5000)        3.  [WAXmlRoot](#org59e1fde)    43. [ScriptGenerator](#orgbbfac7f)        1.  [WAScriptGenerator](#orgd6ec355)        2.  [WADefaultScriptGenerator](#org607fb8e)        3.  [WANullScriptGenerator](#orgf2b0a2d)    44. [Server](#org4c88513)        1.  [WAServerAdaptor](#orgfca99f5)        2.  [WATestServerAdapator](#orga3a1331)        3.  [WAWebServerAdaptor](#org904d69d)        4.  [WAServerManager](#org9b5e2b1)        5.  [WebServer](#orgf692ce6)    45. [Snapshot](#orgd3f4989)        1.  [WASnapshot](#org8973ffd)    46. [Strategy](#orgacb4c12)        1.  [WAHandlerTrackingStrategy](#orgc3227e1)        2.  [WAQueryFieldHandlerTrackingStrategy](#orgf8eece6)        3.  [WASessionTrackingStrategy](#orgea2fb47)        4.  [WACookieForBrowserIPForCrawlerTrackingStrategy](#org355f8c6)        5.  [WACookieSessionTrackingStrategy](#org24759ed)        6.  [WACookieIfSupportedSessionTrackingStrategy](#org8b89ac7)        7.  [WAEnterpriseAuberginesStrategy](#org49aaf25)        8.  [WACookieOnlySessionTrackingStrategy](#org578b34c)        9.  [WAInvisibleSessionTrackingStrategy](#org1a4fea9)        10. [WAIPSessionTrackingStrategy](#org72e9c3e)        11. [WASslSessionTrackingStrategy](#org0ad1989)    47. [Url](#org901187a)        1.  [WAUrl](#org46387f5)    48. [Visitor](#orgf7fc2e4)        1.  [WAVisitor](#org2307234)        2.  [WAAttributeVisitor](#orga7d6863)        3.  [WAUserConfigurationEditorVisitor](#org855cf69)    49. [ValueHolder](#org87f4ab3)        1.  [WAValueHolder](#orgd04319d)    50. [HOWTO](#org8a7440b)        1.  [Clear Sessions](#orgd733956)    51. [Bibliography](#orgfb711c4)<a id="orged6feea"></a># Seaside<a id="orga69d7bd"></a>## Introduction    Working Notes of an "in depth" study of the Seaside guts and patterns.        This documentation lives here:   https://github.com/gettimothy/Doc-Seaside<a id="org103b2fa"></a>## Todo            Update Doc to handle TAGS and ignore #Startup etc.    Squeak uses WebServer, does Pharo use Kom thing?    Get examples/strategies/use-cases of WAExpiringCache    see if we can hack Seaside using examples from:         https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration        Write a mockups of     WAComboResponse    WAStreamedResponse        get a sense of the things WAVisitor children do.    WACallback look like convenience things.            In the WANumberAttribute, possibility of deploying a complex or float attribute    for didadict purposes.        WARequestFilter and other    WACORSFilter examples.                WAFileLibrary handles requests for static files. Read its class comment        WAExceptionHandler examples        Build out robust examples of the Strategy stuff. fascinating.            Image the following request path:    /start/middle/end    and a dispatcher mapped at 'start' and an application mapped at 'middle'.        The above, from WAPathConsumer provides important insight.    Dispatcher->App->thing<a id="org435eb4e"></a>## JSCore<a id="org079a930"></a>### JSJoin<a id="org9bc8ef1"></a>### JSJson<a id="orgfc40ae4"></a>### JSLogger<a id="org613af59"></a>### JSScript        JSObject subclass: #JSScript        I represent a sequence of JavaScript statements.<a id="orga3cb296"></a>### JSFunction<a id="org5b60e2d"></a>## JSDecoration<a id="orgccd347b"></a>## JQuery<a id="orgb9adfaa"></a>## JQ<a id="orgc3c2369"></a>## JQAjax<a id="orgf671fa4"></a>## JQWidget<a id="org5bf9ad4"></a>## Authentication    See         WAAuthConfiguration<a id="org91a788e"></a>## Brush    WAObject subclass: #WABrush    I represent a brush to be used on a *WACanvas*.        Instance Variables    	canvas:		The canvas instance I am used with.    	parent:		The parent brush I am used within.    	closed:		Wether I have been closed/flushed yet.        I have three immediate subclasses:    WACompound    WAJsonBrush    WATagBrush<a id="orgddb3576"></a>### WACompund    WABrush subclass: #WACompound        I am the superclass for stuff that is not html element but you still want to access via the canvas API.        I have two subclasses and do not appear to be very popular.<a id="orgc8b93d1"></a>### WAJsonBrush    WABrush subclass: #WAJsonBrush        A brush to generate JSON<a id="org76eb923"></a>### WAJsonArrayBrush        WAJsonBrush subclass: #WAJsonArrayBrush            Brush for a JSON array<a id="orge1ba9da"></a>### WAJsonElementBrush    WAJsonBrush subclass: #WAJsonElementBrush            Abstract superclass for JSON elements<a id="orgbc15b34"></a>### WAJsonKeyValueBrush        WAJsonElementBrush subclass: #WAJsonKeyValueBrush            A JSON key value<a id="orgc0222cc"></a>### WAJsonValueBrush        WAJsonElementBrush subclass: #WAJsonValueBrush        A JSON value<a id="orgf0baf37"></a>### WAJsonObjectBrush    WAJsonBrush subclass: #WAJsonObjectBrush                A brush to generate a JSON object<a id="org43287e6"></a>### WATagBrush    WABrush subclass: #WATagBrush            This is the superclass for all XML element classes. Its main additions are    - element name (#tag)    - attributes (instance of WAHtmlAttributes)    - common events (onXXX), this is a hack and would better be solved with traits            My subclasses are:        WAAnchorTag     WABasicFormTag     WABreakTag     WACanvasTag     WACollectionTag     WACommandTag     WADetailsTag     WAEmbedTag     WAEventSourceTag     WAFieldSetTag     WAFormInputTag     WAGenericTag     WAHeadingTag     WAHorizontalRuleTag     WAIframeTag     WAImageTag     WAKeyGeneratorTag     WALabelTag     WAMediaElementTag     WAMenuTag     WAMeterTag     WAObjectTag     WAOptionGroupTag     WAOptionTag     WAOptionalBreakTag     WAOutputTag     WAParameterTag     WAProgressTag     WARubyTextTag     WAScriptTag     WASourceTag     WATableCellTag     WATableTag     WATimeTag     WATrackTag     WAImageMapTag     WAPopupAnchorTag     WAFormTag     WADatalistTag     WAListTag     WASelectTag     WAAbstractTextAreaTag     WAButtonTag     WACheckboxTag     WAFileUploadTag     WAHiddenInputTag     WARadioButtonTag     WASubmitButtonTag     WAEditTag ZurbIFrameTag     WAAudioTag     WAVideoTag     WATableColumnGroupTag     WATableDataTag     WAOrderedListTag     WAUnorderedListTag     WAMultiSelectTag     WAColorInputTag     WAEmailInputTag     WASearchInputTag     WASteppedTag     WATelephoneInputTag     WATextAreaTag     WATextInputTag     WAUrlInputTag     WACancelButtonTag     WAImageButtonTag     WATableColumnTag     WATableHeadingTag     WAClosedRangeTag     WADateInputTag     WADateTimeInputTag     WADateTimeLocalInputTag     WAMonthInputTag     WAWeekInputTag     WAPasswordInputTag     WANumberInputTag     WARangeInputTag     WATimeInputTag        With the Zurb framework, I include        ZurbAnchorTag     ZurbArticleTag     ZurbButtonTag     ZurbCalloutTag     ZurbCellTag     ZurbCloseButtonTag     ZurbDivTag     ZurbFieldSetTag     ZurbFlexGridTag     ZurbFloatGridTag     ZurbFooterTag     ZurbGenericButtonTag     ZurbListItemTag     ZurbMenuTag     ZurbNavTag     ZurbResetButtonTag     ZurbSpanTag     ZurbSubmitButtonTag     ZurbTableTag     ZurbTabsTag <a id="orgbe4ed5c"></a>### WAGenericTag        WATagBrush subclass: #WAGenericTag        A WAGenericTag is the class for all tags that do not have a class of their own.        Instance Variables    	tag:		<String>        tag    	- the name of the tag<a id="org0e4bba0"></a>### WARadioGroup    WAObject subclass: #WARadioGroup        A WARadioGroup is a container for several related radio buttons. It must be used to create radio buttons.        Example:    | group |    group := html radioGroup.    group radioButton    	selected: aBoolean;    	callback: [ self someThing ].<a id="orgbf8f569"></a>## Builder    This is a convenience class which provides a result of a rendering operation as a string. It is expected to be used like this:            WAHtmlCanvas builder render: [ :html |    	html anchor    		url: 'htttp://www.seaside.st';    		with: 'Seaside Homepage' ]        See WABuilderCanvasTest for more examples.<a id="org254b093"></a>### Builder HTML Canvas        	.            ((WABuilder on: WAHtmlCanvas)    	rootClass: WAHtmlRoot;    	documentClass: WAHtmlDocument)    		render:[:h |    			h inspect.    			h anchor    					url:'http://www.seaside.st' ;    					with:'Seaside Home Page'].     '<a href="http://www.seaside.st">Seaside Home Page</a>' <a id="orga4c2cab"></a>### Builder Json Canvas        "Json Canvas"         ((WABuilder on: WAJsonCanvas)    	documentClass: WAJsonDocument)    		render: [:json | json array:[    						json object: [json key:'name' value:'dude']]]            ((WABuilder on: WAJsonCanvas)    	documentClass: WAJsonDocument)    		render: [:json | 	json array: [    		GRPackage grPackages do:[ :grPackage |    			json object: [     				json key: 'name' value: grPackage name.    				json key: 'dependencies' value: [      					json array: [ grPackage dependencies do: [ :dep |    						json value: [ json string: dep name ] ] ] ] ] ] ]]<a id="org0af6a7c"></a>### Builder XML Canvas            "XML Canvas"        ((WABuilder on: WAXmlCanvas)    	documentClass: WAXmlDocument;    	rootClass: WAXmlRoot)    		render: [:xml | xml cdata: 'dude']<a id="org1225e34"></a>## Cache<a id="orga0c3ee0"></a>### WACache    WAObject subclass: #WACache            WACacheis the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCache.        >>keySize returns 16        All other instance methods implement self subclassResponsibility<a id="org563f708"></a>### WABidirectionalCache    WACache subclass: #WABidirectionalCache        I support key -> value and value -> key mappings and never forget anything.        I also implement serveral methods of Dictionary.<a id="orga5fb89e"></a>### WAPredictableCache    WABidirectionalCache subclass: #WAPredictableCache        A WAPredictableCache is a WACache that uses incrementing numbers as cache keys. This way the keys are predictable.     This is useful for tests.<a id="org47e3bb8"></a>### WAExpiringCache    WACache subclass: #WAExpiringCache        I am the abstract base class for caches that remove entries. Subclasses are intended to use to track sessions.            Instance Variables    	maximumSize			<Integer>    	maximumRelativeAge		<Integer>    	maximumAbsoluteAge	<Integer>    	overflowAction			<Symbol>    				    maximumSize:    	Number of sessions supported. When this limit is reached the overflow action is run. 0 for no maximum size. Has to be positive.        maximumRelativeAge:    	After so many seconds of inactivity a session is considered expired. 0 for no limit. Has to be positive.        maximumAbsoluteAge:    	After so many seconds after its creation a session is considered expired no matter when it was last accessed. 0 for no limit. Has to be positive.        overflowAction:    	What to do when the maximum number of sessions is reached. Only matters when the maximum size is bigger than 0.    	Possible values:    		#removeRelativeOldest remove the entry that hasn't been accessed for the longest time    		#removeAbsoluteOldest remove the entry that has been created the longest time ago    		#signalError signal WAMaximumNumberOfSessionsExceededError<a id="org5d339e4"></a>### WABulkReapingCache    WAExpiringCache subclass: #WABulkReapingCache        I am a cache that reaps all elements at once instead of incrementally.        I am intended to be used in GemStone/S instead of WAHashCache. A background process should send #reap to me.            Instance Variables    	dictionary:		<Dictionary><a id="org2a4f32f"></a>### WABulkReapingCacheEntry    WAObject subclass: #WABulkReapingCacheEntry        I am a value in a WABulkReapingCache. It's important that my values are not concurrently updated in order to avoid commit conflicts on GemStone/S.        accessTime:		only set by reaper    creationTime:	immutable, set only once    value:			immutable, set only once    lastCount:		only set by reaper    count:			updated concurrently but this is not an issue since we use a WAReducedConflictCounter            Instance Variables    	count:			<WAReducedConflictCounter>    	lastCount:		<Integer>    	creationTime:	<Integer>    	accessTime:		<Integer>    	value:			<Object><a id="orgeb8b1c4"></a>### WAReducedConflictCounter    WAObject subclass: #WAReducedConflictCounter        I am a fake implementation of RcCounter,     which is a Gemstone Smalltalk class that provides a counter object with reduced transaction conflicts.<a id="orgd4bc83c"></a>### WAHashCache    WAExpiringCache subclass: #WAHashCache        WAHashCache is a hash table based implementation of WACache.        The characteristics of WAHashCache are:    - supports both absolute and relative timeouts at the same time https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration    - supports a maximum size with definable overflow action (expire oldest, expire least recently used, signal exception)    - access by key is fast (O(1) average case O(n) worst case)    - reaping expired sessions is proportional (O(n)) to the number of expired session and independent of the total number of sessions (O(1))    - creating a new session independent of the total number of sessions    - does not guard against hash collision attacks, you should not use user generated keys        Instance Variables:    	keyTable 				<Array<WACacheKeyEntry>>    	size					<Integer>    	byAccessStart			<WACacheListEntry>    	byAccessEnd			<WACacheListEntry>    	byCreationStart		<WACacheListEntry>    	byCreationEnd			<WACacheListEntry>        keyTable:    	Open hash table of  WACacheKeyEntry        byAccessStart    	Head of the linked list sorted by access time        byAccessEnd	    	Tail of the linked list sorted by access time        byCreationStart    	Head of the linked list sorted by creation time        byCreationEnd    	Tail of the linked list sorted by creation time            The implementation is a combination of:    - an open hash table, used for look ups by key     - a linked list of cache entries sorted by creation time, used for reaping by absolute age    - a linked list of cache entries sorted by access time, used for reaping by relative age        For every cache entry there is a node in the hash table and a node in both of the linked lists. It is possible to navigate from every node for a key to every other node of the same key. This is required for removing and updating entries.<a id="org68d6d55"></a>### WACacheKeyEntry        WAObject subclass: #WACacheKeyEntry        I am an entry in the table of WAHashCache.        Besides keys and values I keep track of linked list entries so they can be removed without scanning the list.         Internal Representation and Key Implementation Points.            Instance Variables    	byAccessListEntry:		<WACacheListEntry>    	byCreationListEntry:		<WACacheListEntry>    	key:		<Object>    	keyHash:		<Integer>    	next:		<WACacheKeyEntry>    	value:		<Object><a id="org2eb3550"></a>### WACacheListEntry    WAObject subclass: #WACacheListEntry            I am a node in a sorted linked list in WAHashCache.            Instance Variables    	cacheEntry:		<WACacheKeyEntry>    	next:		<WACacheListEntry>    	previous:		<WACacheListEntry>    	time:		<Integer>            time:    	timestamp in seconds, could be the creation time or access time depending on with of the two linked lists it is<a id="orga8ebcae"></a>### WAHashTableSizes    WAObject subclass: #WAHashTableSizes            WAHashTableSizes is a helper class, used by hashedCollections to determine sizes for hash tables.        Public protocol is all class-side:        #goodSizeAtLeast: anInteger       answers a "good" integer greater than or equal to the given integer.        An integer is not "good" as a hash table size if it is any of:    - Not prime    - Divides 256**k +- a, for small k and a    - Close to a power of two    - Close to dividing the hashMultiply constant        See Andres Valloud's hashing book, and Knuth TAOCP vol. 3.        This class caches a table of selected good primes within the positive SmallInteger range. When this table must be rebuilt, it uses an instance to compute the table. Primes are selected to keep the table fairly small, with approximately five entries per power of two.        The cached table is ordered, and is searched with a binary search to find the closest good size >= the requested size.        Original implementation by Martin McClure<a id="org1fadfc5"></a>### WACacheConfiguration        WASystemConfiguration subclass: #WACacheConfiguration        I am the configuration of WAHashCache.            This entgry is duplicated in Configuration System<a id="orgbba1b5e"></a>### WAMutualExclusionCache    WACache subclass: #WAMutualExclusionCache        WAMutualExclusionCacheNG is a wrapper around a WACacheNG that wraps all messages in a mutex.        Instance Variables:    	mutex	<WAMutex>    	cache	<WACache><a id="orga3bd07b"></a>### WAUnidirectionalCache    WACache subclass: #WAUnidirectionalCache        I support only key -> value mappings and never forget anything.<a id="orga833a4b"></a>## Callback        TODO what uses these?     Where are they documented?<a id="orgf250972"></a>### WACallback        WAObject subclass: #WACallback            A WACallback is xxxxxxxxx.        Instance Variables    	key:		<Object>        key    	- xxxxx<a id="org952b619"></a>### WAActionCallback            WACallback subclass: #WAActionCallback        A WAActionCallback is xxxxxxxxx.        Instance Variables    	block:		<Object>        block    	- xxxxx<a id="org14f3bc4"></a>### WACancelActionCallback        WAActionCallback subclass: #WACancelActionCallback            A WACancelActionCallback is xxxxxxxxx.        Instance Variables<a id="org1813040"></a>### WADefaultActionCallback        WAActionCallback subclass: #WADefaultActionCallback        A WADefaultActionCallback is xxxxxxxxx.        Instance Variables<a id="org3c8ddf4"></a>### WAImageCallback        WAActionCallback subclass: #WAImageCallback            A WAImageCallback is xxxxxxxxx.        Instance Variables<a id="org552e00b"></a>### WADispatchCallback        WACallback subclass: #WADispatchCallback            A WADispatchCallback is xxxxxxxxx.        Instance Variables    	callbacks:		<Object>        callbacks    	- xxxxx<a id="org32982f4"></a>### WAValueCallback    WACallback subclass: #WAValueCallback        A WAValueCallback is xxxxxxxxx.        Instance Variables    	block:		<Object>        block    	- xxxxx<a id="org0f761ae"></a>### WAAllValuesCallback    WAValueCallback subclass: #WAAllValuesCallback        WAAllValuesCallback is a special WAValueCallback that whos value is a sequenceable collection of values.<a id="orgc7f43d5"></a>### WAAllEmailsCallback    WAAllValuesCallback subclass: #WAAllEmailsCallback        A WAAllEmailsCallback is xxxxxxxxx.        Instance Variables<a id="org4ab65db"></a>### WAAllUrlsCallback        WAAllValuesCallback subclass: #WAAllUrlsCallback            A WAAllUrlsCallback is xxxxxxxxx.        Instance Variables<a id="orge5847fc"></a>### WAEmailCallback    WAValueCallback subclass: #WAEmailCallback        A WAEmailCallback is a callback for email input fields.<a id="org10951ed"></a>### WAMapCallback    WAValueCallback subclass: #WAMapCallback        A WAMapCallback is xxxxxxxxx.        Instance Variables<a id="org2a3bf84"></a>### WAUploadCallback        WAValueCallback subclass: #WAUploadCallback            A WAAllUploadsCallback is xxxxxxxxx.        Instance Variables<a id="orgfc9f884"></a>### WAAllUploadsCallback        WAUploadCallback subclass: #WAAllUploadsCallback        A WAAllUploadsCallback is xxxxxxxxx.        Instance Variables<a id="org5b26133"></a>### WAUrlCallback    WAValueCallback subclass: #WAUrlCallback        A WAEmailCallback is a callback for url input fields. <a id="org2b57f18"></a>### WAValuesCallback    WAValueCallback subclass: #WAValuesCallback        A WAValuesCallback is xxxxxxxxx.        Instance Variables    	values:		<Object>        values    	- xxxxx<a id="orgd817a14"></a>### WAMultipleValuesCallback        WAValuesCallback subclass: #WAMultipleValuesCallback                A WAMultipleValuesCallback is xxxxxxxxx.        Instance Variables<a id="orgf756353"></a>### WACallbackRegistry    WAObject subclass: #WACallbackRegistry        A WACallbackRegistry is xxxxxxxxx.        Instance Variables    	callbacks:		<Object>    	nextKey:		<Object>        callbacks    	- xxxxx        nextKey    	- xxxxx<a id="orgb77b43d"></a>## Canvas    A Canvas is a WARenderer<a id="org3a4d693"></a>## Codec<a id="org1043f1d"></a>### GRCodec            A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding)     and back outside the image (encoding).         The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.<a id="orgf90058c"></a>### GRNullCodec    GRObject subclass: #GRCodec        The null codec always returns the original streams.     It assumes that the outside world uses the same encoding as the inside world.     This is highly efficient as no transformation is applied to the data, but has its drawbacks.<a id="orge5026ec"></a>### GRPharoLating1Codec    GRNullCodec subclass: #GRPharoLatin1Codec            A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).<a id="orgaa82d60"></a>### GRPharoGenericCodec    GRCodec subclass: #GRPharoGenericCodec        :nocomment:<a id="org62e9964"></a>### GRPharoUtf8Codec    GRCodec subclass: #GRPharoUtf8Codec        A WAUtf8Codec is a WACodec optimized for UTF-8.<a id="orgf51ae1e"></a>## Configuration    System and User configurations classes     are grouped below .Those not belonging to    those classifications are here.<a id="org8c8e4ec"></a>### WAConfiguration    WAObject subclass: #WAConfiguration        A configuration for a Seaside application contains attributes which can be used by Seaside and the application.     WAConfiguration hierarchy uses the composite pattern.        Subclasses of WASystemConfiguration define and configure related groups of attributes.     See WASystemConfiguration class comment for information on defining your own attributes.        WAUserConfiguration is a composite of configurations.     The set of configurations contained in WAUserConfiguration is called the ancestors.     Attribute values in a configuration override the attribute values in the ancestors.     WAUserConfiguration also holds the non-default values of attributes.        Seaside applications start with a WAUserConfiguration (see WAApplication>>configuration)     a single parent: WARenderLoopConfiguration.     The full ancestry also includes WASessionConfiguration WAGlobalConfiguration.     Other configurations can be added to an application on the Seaside configuration page for the application or in your application.     Values for the attributes can be given in either location.         See Seaside documentation (http://www.seaside.st/documentation) on configuration and preferences     (http://www.seaside.st/documentation/Configuration%20and%20Preferences) for more information.        Example of setting attributes and adding configurations in code    ASubclassOfWAComponent class>>initialize    	"self initialize"    	| application |    	application := self registerAsApplication: 'GlorpExample'.    	"set a standard attribute"    	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.         	"add a configuration"    	application configuration addParent: GlorpConfiguration new.    	application preferenceAt: #databaseLogin put: 'foo'. "set attribute defined in GlorpConfiguration"        Subclasses must implement the following messages:    	name    		return the name of the configuration        	localValueAt:ifAbsent:    		return the value of the attribute given as first argument<a id="org1f3a969"></a>### WAUserConfiguration        WAConfiguration subclass: #WAUserConfiguration        WAUserConfiguration is a composite of configurations.  This composite of configurations is stored in the field "parents". WAUserConfiguration provides methods to dynamically provide non-default values for attributes. WAUserConfiguration inherits attributes and values defined in its ancestors. If WAUserConfiguration does not have a value for an attribute it will search its ancestors for a value, stopping when it finds a value.        An instance of WAUserConfiguration is the first configuration added to a Seaside application (WAApplication). All other configurations added to the application are added as ancestors of this instance. When a value for an attribute is set either by the standard Seaside component configuration page or in code the value is added to the "values" dictionary in WAUserConfiguration.        Instance Variables:    	parents	<Collection of: WAConfiguration>	 hierarchy of configurations defining all attributes for this instance of WAUserConfiguration    	values	<Dictionary>	the dictionary key is an attribute key, dictionary value is value of that attribute <a id="orga0d0197"></a>### WASharedConfiguration        WAUserConfiguration subclass: #WASharedConfiguration        no comment<a id="org61f8bdb"></a>### WAAttributeSearchContext    WAObject subclass: #WAAttributeSearchContext        This class makes attribute searching more efficient by traversing the ancestry once and caching which Configurations hold the attribute.     It is then passed through search functions which cache values for the attribute.<a id="orgbc3ea03"></a>### WAAttributeVisitor    WAVisitor subclass: #WAAttributeVisitor        A visitor of attributes        This entry duplicated in the Visitor section below<a id="org4545a2f"></a>### WAConfigurationDescription    WAObject subclass: #WAConfigurationDescription        I hold a collection of attributes and present methods to construct new methods,     providing an interface a bit like WACanvas and #renderContentOn: to WASystemConfiguration>>addAttributes:.        I can use any kind of collection class and handle setting the #configuration: parameter of the attribute appropriately on addition.         If my collection is a Dictionary, I will store the attributes by their keys.<a id="orga5d4cf1"></a>### WAConfigurationElement    WAObject subclass: #WAConfigurationElement            A WAConfigurationElement is xxxxxxxxx.        Instance Variables    	key:		<Object>        key    	- xxxxx<a id="org1815c63"></a>### WAAttribute        WAConfigurationElement subclass: #WAAttribute        A WAAttribute represents a value of a specified type in a Seaside configuration.     Some attributes are needed by Seaside for application parameters like deployment Mode and session timeout.     Optional attributes like a database login may be used internally by the application.        Each subclass of WAAttribute handles one type (Number, Boolean, etc) of attribute.     The "group" of the attribute is used to place all attributes in the same group together on the Seaside configuration page.     The "key" of the attribute identifies the attribute.     Attribute keys must be globally unique so use namespacing where required to ensure uniqueness.     See WAConfiguration for example of accessing a configuration attribute.         Subclasses may implement their own configuration options depending on their needs.        Subclasses must implement the following messages:    	valueFromString: aString    		convert "aString" into type represented by the class, return result of the conversion    	    	accept: aVisitor with: anObject    		Typical implementation is:    			aVisitor visitXXXAttribute: self with: anObject        		where XXX is the type of this attribute.         The method visitXXXAttribute:with: must be implemented in all visitors,     in particular WAUserConfigurationEditorVisitor which creates the configuration page for Seaside applications.        Instance Variables:    	configuration	<WAConfiguration>	The configuration object that defined the attribute    	group			<Symbol>				name of the group the attribute belongs to    	key				<Symbol>				key or name of the attribute, used to look up the attribute    	comment		<String> 				a full length description of the attribute for displaying in the configuration interface    	label			<String>				a short field label used in the user interface. If not specified, a label is constructed from the key.    	default			<Object>				The default value for the attribute.<a id="org0b90405"></a>### WABooleanAttribute    WAAttribute subclass: #WABooleanAttribute        WABooleanAttribute  represents a boolean attribute.     It converts between text entered on the configuration page and boolean values.<a id="org88abfb0"></a>### WAListAttribute        WAAttribute subclass: #WAListAttribute    WAListAttribute is an attribute that is restricted to a list of values.         Instance Variables:    	options	<Block>	A block returning a list of possible values for the attribute<a id="orga6b959e"></a>### WAClassBindingAttribute        WAListAttribute subclass: #WAClassBindingAttribute        A WAClassBindingAttribute is xxxxxxxxx.        Instance Variables<a id="org2cbf000"></a>### WAClassBindingCollectionAttribute        WAListAttribute subclass: #WAClassBindingCollectionAttribute        A WAClassBindingCollectionAttribute is xxxxxxxxx.        Instance Variables<a id="orgd1caa72"></a>### WAClassListAttribute        WAListAttribute subclass: #WAClassListAttribute        WAClassListAttribute is an attribute that is restricted to a list of classes.     The value will be an instance of the given class created with #new. <a id="org75ef724"></a>### WACollectionAttribute        WAListAttribute subclass: #WACollectionAttribute        A WACollectionAttribute is xxxxxxxxx.        Instance Variables<a id="org8319b39"></a>### WANumberAttribute    WAAttribute subclass: #WANumberAttribute            WANumberAttribute represents a number attribute.     It converts between text entered on the configuration page and numbers.<a id="org0d10a72"></a>### WAIntegerAttribute    WANumberAttribute subclass: #WAIntegerAttribute        A WAIntegerAttribute is xxxxxxxxx.        Instance Variables<a id="org7e2036b"></a>### WAPasswordAttribute        WAAttribute subclass: #WAPasswordAttribute            WAPasswordAttribute represents a password attribute.     When set from a string, it records a hashed value.         On the Seaside configuration page it does not display its current value.<a id="orgd03edf7"></a>### WAStringAttribute        WAAttribute subclass: #WAStringAttribute            WAStringAttribute represents a string attribute.     It does the trivial conversion between text entered on the Seaside configuration page and a string.<a id="orgad7af61"></a>### WAUrlAttribute    WAAttribute subclass: #WAUrlAttribute            WAUrlAttribute represents a URL attribute.     It converts between text entered on the configuration page and WAUrl instances.<a id="orgdba6711"></a>### WAAttributeExpression    WAConfigurationElement subclass: #WAAttributeExpression        A WAAttributeExpression is xxxxxxxxx.        Instance Variables<a id="orgb348aad"></a>### WAAddRemoveExpression    WAAttributeExpression subclass: #WAAddRemoveExpression            A WAAddRemoveExpression is xxxxxxxxx.        Instance Variables    	additions:		<Object>    	removals:		<Object>        additions    	- xxxxx        removals    	- xxxxx<a id="org4d6fff1"></a>### WAValueExpression        WAAttributeExpression subclass: #WAValueExpression        A WAValueExpression is xxxxxxxxx.        Instance Variables    	value:		<Object>        value    	- xxxxx<a id="org5b618ca"></a>## Configuration System<a id="org3fe4905"></a>### WASystemConfiguratino        WAConfiguration subclass: #WASystemConfiguration        You should subclass WASystemConfiguration to define new attributes.     The method #describeOn: is passed an instance of WAConfigurationDescription which can be used to create new attributes.     The attributes can be configured to specify their default value, label, and so on.     See the methods on WAAttribute and its subclasses to see what options are available.        If a configuration needs to override the value of another WASystemConfiguration or depends on its attributes,     implement the method "parents", returning a collection of configuration objects.        WASystemConfiguration subclasses are "read-only" in that their attributes, parents, and default values are all specified in code.     Users and applications that want to configure values for attributes should create a WAUserConfiguration and specify the WASystemConfiguration in its ancestry.        WASystemConfiguration classes are singleton.     You should use #instance on the class side to get the current instance.     You cannot call #copy on a WASystemConfiguration.        Subclasses should implement the following messages:    	describeOn:    		    They may also want to implement:    	parents<a id="org3a1100d"></a>### WAApplicationConfiguration        WASystemConfiguration subclass: #WAApplicationConfiguration            WAApplicationConfiguration defines attributes required by WAApplication. All applications should include this configuration (this is done by default for new applications).        See #addAttributes: for details on provided attributes.<a id="org57ff921"></a>### WAAuthConfiguration        WASystemConfiguration subclass: #WAAuthConfiguration            WAAuthConfiguration defines attributes to store a username and password for an application. It is used by WAApplication to provide a basic single-account authentication mechanism for applications like the Seaside Configuration application. It changes to mainClass for the session to WAAuthMain, which adds a Decoration to check for authentication before displaying the root component.        You can implement your own authentication mechanism without using this configuration by subclassing WAApplication and implementing #verifyPassword:forUser: to lookup account details from a database or similar. You can then manually set WAAuthMain as your main class.<a id="orgcd3f367"></a>### WACacheConfiguration    WASystemConfiguration subclass: #WACacheConfiguration            I am the configuration of WAHashCache.        This entry is duplicated in Cache area.<a id="org32a12dd"></a>### WAConfigurationMock        WASystemConfiguration subclass: #WAConfigurationMock            A WAConfigurationMock is xxxxxxxxx.        Instance Variables    	describeBlock:		<Object>    	parentsBlock:		<Object>        describeBlock    	- xxxxx        parentsBlock    	- xxxxx<a id="orgb152401"></a>### WADevelopmentConfiguration    WASystemConfiguration subclass: #WADevelopmentConfiguration        A WADevelopmentConfiguration is xxxxxxxxx.<a id="org0c40de6"></a>### WAEmailConfiguration        WASystemConfiguration subclass: #WAEmailConfiguration    A configuration for email<a id="org5a38be7"></a>### WAExceptionFilterConfiguration        WASystemConfiguration subclass: #WAExceptionFilterConfiguration        A WAExceptionFilterConfiguration is xxxxxxxxx.<a id="org0bbea7b"></a>### WAFileHandlerConfiguration        WASystemConfiguration subclass: #WAFileHandlerConfiguration        A WAFileHandlerConfiguration is xxxxxxxxx.        Instance Variables<a id="org2efb1a0"></a>### WARegistryConfiguration    WASystemConfiguration subclass: #WARegistryConfiguration        A WARegistryConfiguration is xxxxxxxxx.<a id="org0728cf8"></a>### WARenderLoopConfiguration        WASystemConfiguration subclass: #WARenderLoopConfiguration            WARenderLoopConfiguration defines attributes required by the Render Loop classes (see the Seaside-Core-RenderLoop category).     Any application using these classes should include this configuration (this is done by default for new applications).        See #addAttributes: for details on provided attributes.<a id="orgdbb5b0e"></a>### WARequestHandlingConfiguration    WASystemConfiguration subclass: #WARequestHandlingConfiguration            This configuration class holds attributes needed by classes in the Request Handling layer.<a id="org932f0a7"></a>### WARestfulConfiguration    WASystemConfiguration subclass: #WARestfulConfiguration            A WARestfulConfiguration is xxxxxxxxx.<a id="org1f133de"></a>## Configuration User    WAConfiguration has two main trees: System and User.        User is presented here<a id="orgd8470fc"></a>## Context<a id="org2db1ea6"></a>### WAContextTest<a id="org238f0db"></a>### WARequestContext    WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)    WARequestContext encapsulates all the knowledge that should be available while processing a single request.     It does not matter if this is a request to a static file,     an AJAX request,     a long Comet request     or a normal Seaside requestion.        The request context is valid only during the request that caused it.     It should not be stored.     Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.     In both cases this might lead to memory leaks.<a id="org45a3f8e"></a>## Continuation<a id="org72b6b42"></a>### WAContinuation        GRObject subclass: #WAContinuation        A WAContinuation is the Squeak implementation of a continuation.     It serializes the whole stack into an array        Instance Variables    	values:		<Array<ContextPart>>        values    	- an Array of ContextPart and the values they store<a id="org9ccf7bd"></a>### WAPartialContinuation    GRObject subclass: #WAPartialContinuation        A WAPartialContinuation is xxxxxxxxx.        Instance Variables    	values:		<Object>        values    	- xxxxx<a id="org7af161f"></a>## Cookie<a id="orgae1b851"></a>### WACookie                I represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.    You can never trust information in a cookie, the client is free to edit it.    I model only a part of the full cookie specification.        Browser support:    http://www.mnot.net/blog/2006/10/27/cookie_fun        Netscape spec    http://cgi.netscape.com/newsref/std/cookie_spec.html        Cookie spec    http://tools.ietf.org/html/rfc2109        Cookie 2 spec    https://tools.ietf.org/html/rfc6265        HttpOnly    http://msdn2.microsoft.com/en-us/library/ms533046.aspx    https://bugzilla.mozilla.org/show_bug.cgi?id=178993        Compared to WARequestCookie I represent the information that is sent to the user agent.<a id="org5aa63f8"></a>### WARequestCookie    A WARequestCookie is the cookie the user agent sent to the server.        Instance Variables    	domain:			<String>    	key:			<String>    	path:			<String>    	pathEncoded:	<String>    	ports:			<Collection<Integer>>    	value:			<String>    	version:			<Integer>        domain    	- xxxxx        key    	- xxxxx        path    	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:      1.  Let uri-path be the path portion of the request-uri if such a           portion exists (and empty otherwise).  For example, if the           request-uri contains just a path (and optional query string),           then the uri-path is that path (without the %x3F ("?") character           or query string), and if the request-uri contains a full           absoluteURI, the uri-path is the path component of that URI.           2.  If the uri-path is empty or if the first character of the uri-           path is not a %x2F ("/") character, output %x2F ("/") and skip           the remaining steps.           3.  If the uri-path contains no more than one %x2F ("/") character,           output %x2F ("/") and skip the remaining step.           4.  Output the characters of the uri-path from the first character up           to, but not including, the right-most %x2F ("/").        ports    	- xxxxx        value    	- xxxxx        version    	- the version of the cookie specification supported, currently only 1 is known<a id="org55f2282"></a>## DocumentA Seaside Document is basically a wrapper on a Stream and a Codec.<a id="org809e6d9"></a>### WADocument    WAObject subclass: #WADocument        A WADocument combines an output stream and an instance of root.         The root is responsible to render header and footer if necessary.<a id="orgade82f9"></a>### WAJsonDocument        WADocument subclass: #WAJsonDocument            I add the possibility to generate JSON.<a id="orgb678614"></a>### WAXmlDocument        WADocument subclass: #WAXmlDocument        A WAXmlDocument is adds the possibility to generate XML tags and knows encoders for XML text and URLs.<a id="org43b9bf8"></a>### WAHtmlDocument        WAXmlDocument subclass: #WAHtmlDocument        A WAHtmlDocument controls how a string is created from a series of brushes.<a id="org5cf8eee"></a>### WAPrettyPrintedDocument        WAHtmlDocument subclass: #WAPrettyPrintedDocument                This Document can be used in place of a WAHtmlDocument and will display a pretty version of the HTML source that would have been generated by the WAHtmlDocument.        The technique here is that:     - anything we are asked to output raw (i.e. #nextPut: and #nextPutAll:) we encode with entities     - anything we are asked to entity encode (i.e. via #xmlEncoder) we double-encode, by wrapping the two WAXmlEncoders around each other     - anything we want to output ourselves (i.e. prettiness) we do using a WAHtmlCanvas that we create ourselves<a id="org90668ab"></a>### WAUnescapedDocument    WAXmlDocument subclass: #WAUnescapedDocument        A WAUnescapedDocument does not do any escaping.<a id="org8292e7e"></a>### WAHtmlAttributes    GRSmallDictionary subclass: #WAHtmlAttributes        I represent the attributes of a (X)(HT)ML tag.     Compared to my superclass I ignore requests to add a nil-values.     I also don't throw an exception when accessing a key that doesn't exist, but instead return nil.<a id="org1286da7"></a>### WAConcatenatedHtmlAttributeValue    WAObject subclass: #WAConcatenatedHtmlAttributeValue            I am used to represent html attribute values that can be sent separately to a brush but eventually need to be printed as a single attribute string.     I was introduced to optimize html rendering where String concatentation is slow.     See https://github.com/seasidest/seaside/issues/816        E.g. in the following code, multiple values for 'class' are sent to the anchor brush and they are eventually concatenated in the output    html anchor       class: 'mycss-strong';       class: 'mycss-bold';       class: 'mycss-alignright';       with: 'some text'<a id="org10ba52e"></a>### WAEncoder    WAObject subclass: #WAEncoder        I encode everything that is written to myself using #nextPut: and #nextPutAll: onto the wrapped stream.<a id="org2d626fe"></a>### WATableBasedEncoder    WAEncoder subclass: #WATableBasedEncoder            I encode everything that is written to myself using #nextPut: and #nextPutAll: onto the wrapped stream.     The specific encoding that is done is determined by my subclasses     (the conversion of a single character is defined in the class-side method #encode:on:).        To be efficient, each subclass uses a cached encoding table to transform the most used characters from the UTF Basic Multilingual Plane.<a id="org3c133c6"></a>### WAUrlEncoder    WATableBasedEncoder subclass: #WAUrlEncoder            I do percent-encoding of parts (e.g. path segments and arguments) of a URI.        Additionally, a Codec is given the chance to encode the characters into bytes before being percent-encoded    (see http://tools.ietf.org/html/rfc3986#section-2.5).     This allows extended characters to be represented in URIs in, for example, UTF-8.<a id="org26f4962"></a>### WAXmlEncoder    WAEncoder subclass: #WAXmlEncoder            I encode XHTML text.<a id="org83fe487"></a>## Document Elements<a id="org9ebc69c"></a>### WAHtmlElement        WAObject subclass: #WAHtmlElement        Root class of all elements inside a <head> section.<a id="orge043725"></a>### WABaseElement        WAHtmlElement subclass: #WABaseElement        In HTML, links and references to external images, applets, form-processing programs, style sheets, etc. are always specified by a URI.     Relative URIs are resolved according to a base URI, which may come from a variety of sources.     The BASE element allows authors to specify a document's base URI explicitly.        When present, the BASE element must appear in the HEAD section of an HTML document, before any element that refers to an external source.     The path information specified by the BASE element only affects URIs in the document where the element appears.        For example, given the following BASE declaration and A declaration:    updateRoot: html    	super updateRoot: html.    	html base url: 'http://www.aviary.com/products/intro.html'        renderContentOn: html    	html anchor    		url: '../cages/birds.gif';    		with: 'Bird Cages'        the relative URI "../cages/birds.gif" would resolve to:    http://www.aviary.com/cages/birds.gif<a id="orgc7681fa"></a>### WAContentElement    WAHtmlElement subclass: #WAContentElement            Common superclass of all elements inside a <head> that can have content.     Either between the start and end tag or a (mime) document pointed to by an URL.<a id="org1bb5e3f"></a>### WALinkElement    WAContentElement subclass: #WALinkElement        Defines either a link or style sheet rules.     If it has children then it defines style sheet rules, else it defines a link.        = if link =    This element defines a link.     Unlike A, it may only appear in the HEAD section of a document, although it may appear any number of times.     Although LINK has no content, it conveys relationship information that may be rendered by user agents in a variety of ways     (e.g., a tool-bar with a drop-down menu of links).        = style sheet rules =    The STYLE element allows authors to put style sheet rules in the head of the document.     HTML permits any number of STYLE elements in the HEAD section of a document.        User agents that don't support style sheets, or don't support the specific style sheet language used by a STYLE element,     must hide the contents of the STYLE element.     It is an error to render the content as part of the document's text.     Some style sheet languages support syntax for hiding the content from non-conforming user agents.<a id="orge425bfc"></a>### WAScriptElement    WAContentElement subclass: #WAScriptElement        The SCRIPT element places a script within a document.     This element may appear any number of times in the HEAD of an HTML document.        The script may be defined within the contents of the SCRIPT element or in an external file.     If the src attribute is not set, user agents must interpret the contents of the element as the script.     If the src has a URI value, user agents must ignore the element's contents and retrieve the script via the URI.         Note that the charset attribute refers to the character encoding of the script designated by the src attribute;     it does not concern the content of the SCRIPT element.<a id="orgd4b4a46"></a>### WAMetaElement    WAHtmlElement subclass: #WAMetaElement            The META element can be used to identify properties of a document     (e.g., author, expiration date, a list of key words, etc.)     and assign values to those properties.     This specification does not define a normative set of properties.        Each META element specifies a property/value pair.     The name attribute identifies the property and the content attribute specifies the property's value.        For example, the following declaration sets a value for the Author property:    <META name="Author" content="Dave Raggett">        The lang attribute can be used with META to specify the language for the value of the content attribute.     This enables speech synthesizers to apply language dependent pronunciation rules.        In this example, the author's name is declared to be French:        htm meta    	name: 'Author'; language: 'fr'; content: 'Arnaud Le Hors'    	    Note. The META element is a generic mechanism for specifying meta data.     However, some HTML elements and attributes already handle certain pieces of meta data and may be used by authors instead of META to specify those pieces:     the TITLE element,     the ADDRESS element,     the INS and DEL elements,     the title attribute,     and the cite attribute.        Note. When a property specified by a META element takes a value that is a URI,     some authors prefer to specify the meta data via the LINK element. Thus, the following meta data declaration:    html meta          name: 'DC.identifier';          content: 'http://www.ietf.org/rfc/rfc1866.txt'        might also be written:    html link             relationship: 'DC.identifier';             type: 'text/plain';             url: 'http://www.ietf.org/rfc/rfc1866.txt'        The http-equiv attribute can be used in place of the name attribute and has a special significance when documents are retrieved via the Hypertext Transfer Protocol (HTTP).     HTTP servers may use the property name specified by the http-equiv attribute to create an [RFC822]-style header in the HTTP response.     Please see the HTTP specification ([RFC2616]) for details on valid HTTP headers.        The following sample META declaration:    htttp meta             responseHeaderName: 'Expires';             content: 'Tue, 20 Aug 1996 14:25:27 GMT'        will result in the HTTP header:    Expires: Tue, 20 Aug 1996 14:25:27 GMT        This can be used by caches to determine when to fetch a fresh copy of the associated document.        Note. Some user agents support the use of META to refresh the current page after a specified number of seconds, with the option of replacing it by a different URI.     Authors should not use this technique to forward users to different pages, as this makes the page inaccessible to some users.     Instead, automatic page forwarding should be done using server-side redirects.        html meta             redirectAfter: 5 to: 'http://www.google.com/'<a id="org1bea78b"></a>### WAStyleElement    WAHtmlElement subclass: #WAStyleElement            The style element allows style information to be embedded in documents.<a id="orge5cc09a"></a>### WAConditionalComment        WAObject subclass: #WAConditionalComment        A WAConditionalComment is an implementation of Downlevel-hidden Conditional Comments:    http://msdn2.microsoft.com/en-us/library/ms537512.aspx    These are only visible for the IE family of browsers.        See also WAOpeningConditionalComment and WAClosingConditionalComment.<a id="orge5ecdec"></a>### WARevealedConditionalComment        WAConditionalComment subclass: #WARevealedConditionalComment        A WAConditionalComment is an implementation of Downlevel-revealed Conditional Comments:    http://msdn2.microsoft.com/en-us/library/ms537512.aspx    Non-IE family browsers see them always.        See also WAOpeningRevealedConditionalComment and WARevealedConditionalComment.<a id="orge777fa5"></a>### WAOpeningConditionalComment    WAObject subclass: #WAOpeningConditionalComment        Opens a WAConditionalComment and encodes the condition.<a id="org47d5d3c"></a>### WAOpeningRevealedConditionalComment    WAOpeningConditionalComment subclass: #WAOpeningRevealedConditionalComment        Opens a WARevealedConditionalComment and encodes the condition.<a id="org18285b1"></a>### WAClosingConditionalComment        WAObject subclass: #WAClosingConditionalComment        Closes a WAConditionalComment.<a id="org78b7690"></a>### WAClosingRevealedConditionalComment    WAObject subclass: #WAClosingRevealedConditionalComment        Closes a WARevealedConditionalComment.<a id="orgdcfb885"></a>## Error<a id="orgf332db3"></a>### WAError        GRError subclass: #WAError        Common superclass for Seaside errors        My subclasses are:        WAAuthConfigurationError     WAConfigurationError     WAIllegalStateException     WAInvalidHeaderValueError     WAInvalidUrlSyntaxError     WAMaximumNumberOfSessionsExceededError     WARequestContextNotFound     WAUnhandledNotificationError     WAUnregisteredHandlerError     WAArgumentNotFoundError     WAJsonSyntaxError     WAChildComponentShouldNotBeSelfError     WATaskNotDelegated     WAMissingResponseError     WAAttributeNotFound<a id="org9cfc982"></a>## Exception Handling<a id="orgd01c110"></a>### WAExceptionHandler    WAObject subclass: #WAExceptionHandler        Exception handlers are invoked when an error in a Seaside application occurs.     Request handlers can use the class-side method #handleExceptionsDuring: to set up exception handlers around a block of code.        == Catching ==        Exception handlers can configure which exceptions they want to catch by overriding the class-side method #exceptionsToCatch.     They may also choose to override #handleExceptionsDuring: on the class-side directly, if they need more complex behaviour.            == Handling ==        Handling behaviour is implemented on the instance side by implementing #handleException:.     This method should return a suitable seaside response (usually an instance of WAResponse) if it returns.        == Internal Errors ==        Internal errors are typically errors that occur while trying to execute one of the other error handlers and should be as basic as possible to ensure they don't have any trouble executing.     Request handlers can ask for an internal error response by calling #internalError: on the class-side of an exception handler.        == HTML Responses ==        See WAWalkbackErrorHandler in the development packages for examples of how to do rendering with the canvas API.<a id="org3c2949d"></a>### WAErrorHandler        WAExceptionHandler subclass: #WAErrorHandler        WAErrorHandler catches Errors and Warnings and provides two methods for handling each type of exception:        handleError:    handleWarning:        If either method is not implemented, the default implementation will call #handleDefault:,     which can be used to provide common behaviour for both exception types.<a id="orgd4f396e"></a>## Filter    WARequestFilter is an implementation for the chain-of-responsibility and decorator pattern for request handlers. <a id="orga83455b"></a>### WARequestFilter    WAObject subclass: #WARequestFilter        WARequestFilter is an implementation for the chain-of-responsibility and decorator pattern for request handlers.     Request filters are a way of hooking into the request handling.     There is no limit on what they can do, examples include     - preprocess the request     - postprocess the response     - set up thread locals or expection handlers     - return a different response (eg. from cache or access denied)         This functionality is also known as servlet filters, WSGI infrastructure or rack infrastructure.        Instance Variables:    	next	<WAValueHolder<WARequestFilter>>    		    next    	- The next filter in the chain.<a id="orga998b74"></a>### WAAbstractProtectionFilter    WARequestFilter subclass: #WAAbstractProtectionFilter                A protection filter protects the wrapped request handler, mostly useful to protect against session hijacking. See subclasses for different strategies.<a id="org1c4b1b2"></a>### WARemoteAddressProtectionFilter    WAAbstractProtectionFilter subclass: #WARemoteAddressProtectionFilter        The remote address protection filter ensures that the wrapped request handler only accepts requests from the same IP.     Do add this filter to a WASession for example to avoid session hijacking,     do not add it to static request handlers such as WAApplication or WADispatcher as this might restrict access to the handler if your IP changes.            Note that checking for IP addresses is not bullet proof and should never be used as the sole security measure for a web application as IP addresses can be easily spoofed.<a id="org64dde94"></a>### WASessionCookieProtectionFilter    WAAbstractProtectionFilter subclass: #WASessionCookieProtectionFilter        The session cookie protection filter ensures that the wrapped request handler only accepts requests from the same browser session.     This filter is specifically useful to protect session hijacking when using the (default) query field session tracking strategy.        Because WAQueryFieldHandlerTrackingStrategy puts the Seaside session key in the url, a session can be easily hijacked by copying the url.     This request filter prevents this by requiring a browser session cookie associated to the Seaside session.     As a result, a copied Seaside url can only be used in the same browser session.        The use of this filter, in combination with WAQueryFieldHandlerTrackingStrategy,     keeps the ability for a user to open multiple sessions of the same Seaside application in a single browser, while removing easy session hijacking.     A malicious user that wants to hijack the session now needs both the url and the cookie.        The appropriate use of this filter is to add it to the session in the `initializeFilters` method of your session class.     Only in this way, the session is protected from the first rendered application page onwards.     See WASessionCookieProtectedSession class as an example.<a id="org0422176"></a>### WAAuthenticationFilter        WARequestFilter subclass: #WAAuthenticationFilter        WAAuthenticationFilter protects a request handler with username and password using the standard HTTP basic authentication.     This passes username and password in clear-text, unless used over an encripted HTTPS connection.     You should set the authenticator, and object that is able to validate usernames and passwords by implementing #verifyPassword:forUser:.<a id="org42d1e11"></a>### WACORSFilter        WARequestFilter subclass: #WACORSFilter        Implements a WARequestFilter that adds support to handle CORS requests.    CORS = Cross Origin Resource Sharing<a id="orgb991550"></a>### WAConfiguredRequestFilter    WARequestFilter subclass: #WAConfiguredRequestFilter            A WAConfiguredRequestFilter is xxxxxxxxx.        Instance Variables    	configuration:		<Object>        configuration    	- xxxxx<a id="org5a87b39"></a>### WAExceptionFilter        WAConfiguredRequestFilter subclass: #WAExceptionFilter        A WAExceptionFilter is xxxxxxxxx.        Instance Variables<a id="org3af3aa0"></a>### WATrailingSlashFilter    WARequestFilter subclass: #WATrailingSlashFilter            Enforces a trailing slash on the wrapped request handler.<a id="org2fb2a17"></a>### WATransactionFilter    WARequestFilter subclass: #WATransactionFilter        This filter provides the implementation of WAComponent>>#isolate:.         It rejects all requests as soon as the filter has been closed.<a id="org7d4ed19"></a>### WAAuthConfiguration        WASystemConfiguration subclass: #WAAuthConfiguration            WAAuthConfiguration defines attributes to store a username and password for an application.     It is used by WAApplication to provide a basic single-account authentication mechanism for applications like the Seaside Configuration application.     It changes to mainClass for the session to WAAuthMain, which adds a Decoration to check for authentication before displaying the root component.        You can implement your own authentication mechanism without using this configuration by subclassing WAApplication and implementing #verifyPassword:forUser: to lookup account details from a database or similar.     You can then manually set WAAuthMain as your main class.<a id="orga6ef12c"></a>### WACurrentExceptionHandler        WADynamicVariable subclass: #WACurrentExceptionHandler        I hold a reference to the current WAExceptionHandler.     This may be needed when nesting exception handlers so that the look up of an exception handler from within an exception handler block still succeeds.<a id="org706e6ad"></a>### WAExceptionFilterConfiguration    WASystemConfiguration subclass: #WAExceptionFilterConfiguration                A WAExceptionFilterConfiguration is xxxxxxxxx.        Instance Variables<a id="orge9b7a4f"></a>## GRObject    Object subclass: #GRObject            A common superclass that ensures consistent initialization behaviour on all platforms and provides #error: methods that signal an instance of WAPlatformError.        Packages that are using Seaside-Platform should normally subclass GRObject instead of Object.        immediate subclasses are:        GRCodec     GRDelayedSend     GRDelayedSendMessage     GRDelegatingStream     GRInflector     GRPackage     GRPlatform     GRPrinter     GRSmallDictionary     GRSmallDictionary2     GRSmallOrderedSet     GRVersion     GRPharoRandomProvider     GRObjectStub    WAAbstractContinuation     WAObject     WAContinuation     WAPartialContinuation z\*\* Http    This section contains HTTP specific classes.        Some ,like Cookie, Request and Response, have    been pulled out into their own sections to aid concptualizing    Seaside parts as a whole.<a id="org8589756"></a>### WAEmailAddres<a id="org70e5e8f"></a>### WAFile            WAObject subclass: #WAFile        I represent a file that was uploaded by the user via #fileInput.        Instance Variables    	contents:		<ByteArray>    	contentType:	<WAMimeType>    	fileName:		<String>        contents    	- the contents of the file, binary        contentType    	- the content type of the file    	    fileName    	- The name of the file the user agent uploaded.     This is locale name on the machine of the client.     The instance variable might include the full path on the file system,     the accessor will never return the path.<a id="orga9d7117"></a>### WAHeaderFields        GROrderedMultiMap subclass: #WAHeaderFields        I am the headers dictionary of an HTTP request or response.                GROrderedMultiMap is...    I am an implementation of an ordered multi-map.         I allow multiple values to be associated with the same key and maintain the order of addition.     #at: and its derivatives all operate on the first matching key,     while #allAt: returns the complete list of values for a key in the order they were added.<a id="org0b8d644"></a>### WAHttpVersion    WAObject subclass: #WAHttpVersion        A WAHttpVersion is xxxxxxxxx.        Instance Variables    	major:		<Object>    	minor:		<Object>        major    	- xxxxx        minor    	- xxxxx<a id="orgee081a2"></a>### WALocale    WAObject subclass: #WALocale            A WALocale defines a users langauge and country.        Instance Variables    	country:		<String>    	language:		<String>        country    	- either an ISO 2 or ISO 3 country code        language    	- either an ISO 2 or ISO 3 language code<a id="orgd48d514"></a>### WAMergedRequestFields    WAObject subclass: #WAMergedRequestFields            Provides a read-only view onto multiple dictionaries.     Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.<a id="orgd334658"></a>### WAMimeDocument    WAObject subclass: #WAMimeDocument        ME: notice this is not  a subclass of WADocument.        WAMimeDocument is the abstract base class for mime documents.     It is intended as a very basic, mime documents.     Implementations are free to use more advance, native implementations as long as they conform to the protocol.        Instance Variables    	contentType:		<WAMimeType>        mimeType    	- the mime type of this document<a id="orgcb615a5"></a>### WAMimeType        WAObject subclass: #WAMimeType            A WAMimeType abstracts a Internet media type, it is a two-part identifier for file formats on the Internet.        Instance Variables    	main:			<String>    	parameters:	<GRSmallDictionary>    	sub:			<String>        main    	- the main type        parameters    	- a lazily initialized dictionary of optional parameters        sub    	- the subtype<a id="orgbae4a72"></a>### WAQualifiedValue    WAObject subclass: #WAQualifiedValue        A WAQualifiedValue is an Object with an assigned quality value.        Instance Variables    	quality:		<Float>    	value:		<Object>        quality    	- between 0.0 and 1.0 or Float infinity if no value is given        value    	- the qualified object<a id="orgd4fe7c8"></a>### WAAccept        WAQualifiedValue subclass: #WAAccept        A WAAccept is a WAQualifiedValue with a value that is an instance of WAMimeType.     It represents how much a user agent prefers a certain mime type.<a id="orgfd91847"></a>### WAAcceptCharset        WAQualifiedValue subclass: #WAAcceptCharset            A WAAcceptCharset is a WAQualifiedValue with a value that is an instance of String.         It represents how much a user agent prefers a certain character set for the response.<a id="org7aff255"></a>### WAAcceptEncoding        WAQualifiedValue subclass: #WAAcceptEncoding        A WAAcceptCharset is a WAQualifiedValue with a value that is an instance of String.     It represents how much a user agent prefers a certain encoding for the response.<a id="org780cef5"></a>### WAAcceptLanguage    WAQualifiedValue subclass: #WAAcceptLanguage        A WAAcceptLanguage is a WAQualifiedValue with a value that is an instance of WALocale. It represents how much a user agent prefers a certain locale.<a id="orgcd81f0a"></a>## Handlers        Look at the implementors of 'createHandlers'        createHandlers     Array with: WARedirectingApplication new    		cache: WAUnidirectionalCache new;    		yourself.        createHandlers    	| dispatcher application session root |    	root := WADispatcher new.    	dispatcher := root register: WADispatcher new at: 'rails'.    	application := dispatcher register: WAApplication new at: 'homepage'.    	session := WASession new.    	application register: session.    	^ super createHandlers, (Array with: root with: dispatcher with: application with: session)        createHandlers    	| handler |    	handler := WARequestHandler new.    	handler preferenceAt: #charSet put: 'utf-16'.    	^ Array with: handler            createHandlers    	| handler |    	handler := WARequestHandler new.    	handler preferenceAt: #charSet put: 'utf-16'.    	^ Array with: handler            createHandlers    	^ #()            createHandlers    	| application session |    	application := WAApplication new    		cache: WAPredictableCache new;    		yourself.    	session := WASession new    		documentHandlers: WAPredictableCache new;    		yourself.    	application register: session.    	^ Array    		with: application    		with: session            createHandlers    	^ Array with: (WARegistry new    		 cache: WAPredictableCache new;    		yourself)        createHandlers    	^ Array with: WARequestHandler new<a id="orgcacb597"></a>## Key Generator<a id="orgac50c37"></a>### WAKeyGenerator    WAObject subclass: #WAKeyGenerator        :nocomment:<a id="org9cb8105"></a>### WAPrecomputedKeyGenerator    WAKeyGenerator subclass: #WAPrecomputedKeyGenerator        :nocomment:<a id="org6513fe2"></a>## Layer        What are the Layers?        This comment in WARequestHandlingConfiguration,    "This configuration class holds attributes needed by classes in the Request Handling layer."        tells me the application is divided into layers<a id="org15c66de"></a>## Library    Seaside serves static files using WAFileLibrary subclasses.     WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server.     WAFileHandler is registered with the default WADispatcher automatically.<a id="org46194fe"></a>### WAAbstractFileLibrary        WAObject subclass: #WAAbstractFileLibrary            Abstract superclass for Seaside file libraries<a id="orgb4ba4bb"></a>### WAFileLibrary            WAAbstractFileLibrary subclass: #WAFileLibrary        What does FileLibrary do    =============================    It allows to serve static files directly from seaside without the need for a standalone server like Apache or to configure Kom.     These files can reference each other (say a CSS references an image) and can be distrubuted the same way as normal Smalltalk code (Monticello, SqueakMap, ...).        Each file in a file library is represented by a method.     The method name is created from the file name, the dot is removed and the first letter of the suffix in capitalized.     This puts certain limitations to the allowed filenames. Eg. 'main.css' becomes #mainCss.        Like Script- and StyleLibraries FileLibraries can be added to an application so that they automatically include themselves in the document root.     Implement #selectorsToInclude and return the selectors you whish to be added to the document root.        How to create a FileLibrary    ================================    - First create the static files and put them in some directory.       From there they can reference the other files in the same directory normally with their filenames.    - Make sure you have a "Files" entry that serves your files.       This is a normal entry point type that you can find in your /seaside/config application.       If you don't already have one, you can create it if you select "Files" in the type field of the "add entry point" dialog.       For the rest of this text we assume you chose "files" as the path.    - Create a subclass of WAFileLibrary, for the rest of this text I assume its name is MyFileLibrary.    - To add the files to your file library there are two ways.    1. Programmatically with MyFileLibrary class >> #addAllFilesIn: / #addFileNamed:.        For example MyFileLibrary addAllFilesIn: '/path/to/directory/with/files' or MyFileLibrary addFileNamed: '/path/to/background.png'.    2. Via the web interface.        Go to your /seaside/config application and there click configure for your "Files".        Click "configure" behind MyFileLibrary.        There you can add a file by uploading it (select the file, then click "Add")        Note that a "Files" can consist of several file libraries and can even have tradional script or style libraries.        How to integrate a FileLibrary into your application    =============================================================    Files from a FileLibrary are ingetrated the same way other static files are integrated.     They have a constant path that is '/seaside/<Static File Library>/<FileLibrary class name>/<filename>'     so for example '/seaside/files/MyFileLibrary/background.png'.     These can be conveniently generated by 'MyFileLibrary / #aSelector' where #aSelector is the name of the method representing that file.     For example 'MyFileLibrary / #backgroundPng'.        How to get back the files in a FileLibrary    =================================================    The contents of a file library can be written out to disk.     Writing out a file library first makes a folder with the name of the file library in the folder of your Smallatlk image.     Then a file for each file in the file library is created in this folder. Writing out to disk can happen in three ways    1. MyFileLibrary default deployFiles    2. Via the configuration interface of the file library.        On the same page where you can add files to your file library there is also a button 'write to disk' which will write out all the files in this library.    3. Via the configuration interface of your application.        In the section where you can add libraries to your application there is a a button 'write to disk' which will write out all the libraries of this application.        Examples:    ==========        The following code uses WAFileLibrary to add a CSS file to a page.        updateRoot: anHtmlRoot    	super updateRoot: anHtmlRoot.    	anHtmlRoot stylesheet     		url: WAFileLibraryDemo / #mainCss    		    The folllowing code uses WAFileLibrary to display an image.        renderContentOn: html    	html image    		url: WAFileLibraryDemo / #mainJpg    		        Trouble Shooting:    ==========    Earlier versions would create methods without a time stamp. You can fix this by recompiling these methods by adapting the following code        SUAllTestLibrary basicNew in: [ :library |    	#(demologoGif headerGif backgroundGif demoGif logoGif menuGif) do: [ :each |    		library class    			addFileNamed: (library asFilename: each)    			contents: (library perform: each) ] ]<a id="org9f24dc8"></a>### WAFileMetadataLibrary    WAAbstractFileLibrary subclass: #WAFileMetadataLibrary        I seek to address the following WAFileLibrary related issues:        -""Arbitrary support for filenames"" JQuery-UI theme libraries contain currently unsupported filenames such as "e6e6e6_40x100_textures_02_glass_75.png".    -""Arbitrary directories for files"" JQuery-UI (and Twitter Bootstrap) expects certain JavaScript files, images etc in a subdirectory, such as "ui/i18n/ui.datepicker-de.js".    -""Arbitrary mime-types for files"" Currently mime-types are determined from the file-extension, sometimes it would be good to have some more control.        WAAbstractFileLibrary has been introduced which acts as a base for the old file libraries derived from WAFileLibrary and introduces a new subclass WAFileMetadataLibrary.     WAFileMetadataLibrary supports resources with paths, which is handy when, for example, the javascript or css in a file library expects its supporting images to be in subdirectories such as img/xxxx.png.     WAFileMetadataLibrary also records the original filenames so that when you #deployFiles from the file library on a production server, the exported files will maintain their original names and paths.        There's a new method for recursing a sub-directory tree to add all the files and record their relative paths:        =MYWAFileMetadataDerivedFileLibrary recursivelyAddAllFilesIn: '/var/www/files/twitterbootstrap'<a id="org75b4847"></a>### WAFileHandler    WARequestHandler subclass: #WAFileHandler        Seaside serves static files using WAFileLibrary subclasses.     WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server.     WAFileHandler is registered with the default WADispatcher automatically.<a id="org5bb26af"></a>### WAFileHandlerConfiguration    WASystemConfiguration subclass: #WAFileHandlerConfiguration        A WAFileHandlerConfiguration is xxxxxxxxx.        Instance Variables<a id="org51ebdbb"></a>### WAFileHandlerListing        WAObject subclass: #WAFileHandlerListing        A WAFileHandlerListing is xxxxxxxxx.        Instance Variables    	context:		<Object>    	handler:		<Object>        context    	- xxxxx        handler    	- xxxxx<a id="org06da601"></a>### WAForbiddenFileHandlerListing        WAFileHandlerListing subclass: #WAForbiddenFileHandlerListing            A WAForbiddenFileHandlerListing is xxxxxxxxx.        Instance Variables<a id="orge1e8205"></a>### WATextFileHandlerListing        WAFileHandlerListing subclass: #WATextFileHandlerListing        A WATextFileHandlerListing is xxxxxxxxx.        Instance Variables<a id="org3489011"></a>### WAFileLibraryResource        WAObject subclass: #WAFileLibraryResource            A resource within a Seaside file library<a id="org2d32481"></a>## Mutex<a id="org42d2297"></a>### WAMutex        WAObject subclass: #WAMutex        WAMutex provides mutual exclusion properties.        Only one process at a time can execute code within its #critical: method.     Other processes attempting to call #critical: will block until the first process leaves the critical section.     The process that owns the mutex (the one currently in the critical section),     however, may call #critical: repeatedly without fear of blocking.        The process currently inside the critical section can be terminated by calling #terminateOwner.     This will result in the process being unwound and the critical section being freed.<a id="org6d4108d"></a>## WAObject        GRObject subclass: #WAObject        A WAObject is the base class for all portable Seaside classes.     It provides convenience methods for accessing the current request context, session and application.        Its default error class is WAError        application    	"Answer the current seaside application, instance of WAApplication or a subclass."    	    	^ self requestContext application        requestContext    	"Answer the current WARequestContext instance."        	^ WACurrentRequestContext value                  "WACurrentRequestContext is a dynamic variable."            session    	"Answer the current seaside session, instance of WASession or a subclass."    	    	^ self requestContext session<a id="orgdbb2bb4"></a>## Painter        Painters are Visitors<a id="org7ed1930"></a>### WAPainterVisitor    WAVisitor subclass: #WAPainterVisitor            An implementation of the Visitor pattern for Painter subclasses.<a id="org366f29f"></a>### WAHaloVisitor    WAPainterVisitor subclass: #WAHaloVisitor<a id="orge744ba4"></a>### WAInitialRequestVisitor        WAPainterVisitor subclass: #WAInitialRequestVisitor<a id="org82cd49a"></a>### WAPluggablePresenterVisitor    WAPainterVisitor subclass: #WAPluggablePresenterVisitor    NO CLASS COMMENT<a id="org3211a25"></a>### WAPresenterGuide    WAPainterVisitor subclass: #WAPresenterGuide        WAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations.     Along the way, they will ask their client to visit each Painter they come across.    This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.<a id="org36850d8"></a>### WARenderingGuide    WAPresenterGuide subclass: #WARenderingGuide        Currently an empty class but still present for clarity and to allow customization of Rendering behaviour.<a id="orge72daaf"></a>### WAVisiblePresenterGuide    WAPresenterGuide subclass: #WAVisiblePresenterGuide        Visit the tree of all Presenters and their registered #children.     Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.<a id="org6366ca6"></a>### WAAllPresenterGuide    WAVisiblePresenterGuide subclass: #WAAllPresenterGuide        Visit the tree of all Presenters and their registered #children.<a id="org579ee65"></a>### WARenderVisitor        WAPainterVisitor subclass: #WARenderVisitor        A visitor that renders Painters.     It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.<a id="org5547d2f"></a>### WATaskVisitor    WAPainterVisitor subclass: #WATaskVisitor<a id="orgb4dde51"></a>### WAUpdateRootVisitor    WAPainterVisitor subclass: #WAUpdateRootVisitor        A visitor which asks Painters to update a WARoot subclass using #updateRoot:.        This is used to update the root of the Document stored on a WARenderContext.<a id="org612a56e"></a>### WAUpdateStatesVisitor    WAPainterVisitor subclass: #WAUpdateStatesVisitor            A visitor which asks Painters to update a WARoot subclass using #updateRoot:.        This is used to update the root of the Document stored on a WARenderContext.<a id="orga68d150"></a>### WAUpdateUrlVisitor    WAPainterVisitor subclass: #WAUpdateUrlVisitor        A visitor which asks Painters to update a WAUrl subclass using #updateRoot:.        This is used to update the base URL stored on a WARenderContext.<a id="org03bc222"></a>## ProcessSpecificVariables        Object subclass: #ProcessSpecificVariable            My subclasses (not instances of them) keep state specific to the current process.        There are two kinds of process-specific variables: process-local (state available    for read and write in all methods inside the process), and dynamic variables    (implementing dynamic scope).<a id="orgc64acdb"></a>### DynamicVariable<a id="org68c0953"></a>### GRDynamicVariable        DynamicVariable subclass: #GRDynamicVariable            A GRDynamicVariable is xxxxxxxxx.        Instance Variables<a id="orgc62b917"></a>### WADynamicVariable        GRDynamicVariable subclass: #WADynamicVariable        I exist for legacy purposes. You should subclass GRDynamicVariable.<a id="orga979d5f"></a>### WACurrentCallbackProcessingActionContinuation        WADynamicVariable subclass: #WACurrentCallbackProcessingActionContinuation        A WACurrentCallbackProcessingActionContinuation is xxxxxxxxx.        Instance Variables<a id="org5e8e85c"></a>### WACurrentExceptionHandler        WADynamicVariable subclass: #WACurrentExceptionHandler        I hold a reference to the current WAExceptionHandler.     This may be needed when nesting exception handlers so that the look up of an exception handler from within an exception handler block still succeeds.<a id="orgfc18d54"></a>### WACurrentRequestContext    WADynamicVariable subclass: #WACurrentRequestContext        A WACurrentRequestContext is a thread local variable that points to the current WARequestContext.        WARequestContext >> push: anObject during: aBlock     invokes my use: anObject during: aBlock    invokes DynamicVariable value: anObject during: aBlock<a id="orgf0acff9"></a>## Registry    see WARegistry under WARequestHandler    duplicated here.<a id="org52cfc57"></a>### WARegistry    WARequestHandler subclass: #WARegistry        WARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd.     WARegistry checks incoming request URLs for a key and looks for a matching active request handler.     If one exists, the request is sent to the proper handler.     If not, the request is either a new request (in which case #handleDefaultRequest: is called)     or a request to a now-inactive handler (in which case #handleExpiredRequest: is called).         These two methods allow subclasses to properly handle these requests.        Subclasses must implement the following messages:    	handleDefaultRequest:    		Handle a request without a session key, ie a new request.    	handlerField    		The URL parameter in which to store the request handler key.        Instance Variables:    	cache - an instance of WACache to hold the stored request handlers<a id="org25dde5f"></a>### WARegistryConfiguration    WASystemConfiguration subclass: #WARegistryConfiguration        A WARegistryConfiguration is xxxxxxxxx.<a id="orgc519f4a"></a>## Renderer    A Renderer provides methods for rendering data (typically HTML) onto a Document.         It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.        Renderer are typically controlled by a Painter.<a id="orgbd5c305"></a>### WARenderer    WAObject subclass: #WARenderer        A Renderer provides methods for rendering data (typically HTML) onto a Document.         It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.        Renderer are typically controlled by a Painter (Painters are Visitors).    WAObject subclass: #WARenderer        A Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.        Renderer are typically controlled by a Painter.            javascript-core and jquery-core have methods in me.        I provide the nextid and lastid and render method (verify this)<a id="org6ae2816"></a>### WACanvas        WARenderer subclass: #WACanvas            This is the superclass of all canvas. It's a rendering interface that generates brushes (see WABrush).        Subclass WAXmlCanvas, if you want to generate an XML dialect.<a id="org2fa318a"></a>### WAJsonCanvas        WACanvas subclass: #WAJsonCanvas        I am a  specific canvas to render JSON output.<a id="org5a9c63e"></a>### WATagCanvas    WACanvas subclass: #WATagCanvas        I am the abstract superclass for tag based canvases.<a id="orgebc0312"></a>### WAHtmlCanvas        WATagCanvas subclass: #WAHtmlCanvas        I'm a canvas for building HTML.<a id="orgaaefbf9"></a>### WAXmlCanvas    I'm an abstract canvas base class for building canvas for custom XML dialects.            WATagCanvas subclass: #WAXmlCanvas<a id="org7554954"></a>## Render Context<a id="orgd4822d6"></a>### WARenderContext    WAObject subclass: #WARenderContext        A WARenderContext provides all the state needed by a Renderer to do its work.        It is a decoupling device between whatever is initiating rendering and the Renderer itself.<a id="org0870fbb"></a>## Request<a id="org5011584"></a>### WARequest        WAObject subclass: #WARequest  has no children        I am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.        Instance Variables    	method:			<String>    	uri:					<WAUrl>    	version:				<WAHttpVersion>    	remoteAddress:	<String>    	headers:			<Dictionary<String, String>>    	cookies:			<Collection<WARequestCookie>>    	body:				<String>    	postFields:			<WARequestFields>    	sslSessionId:		<String>    			    method    	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		        uri    	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.    	    version    	- The version of this request.    	    remoteAddress    	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.        headers    	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.    	    cookies    	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.    	    body    	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.    	    postFields    	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.    	    sslSessionId    	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.<a id="org941e5b9"></a>## Request Handling and  Continuation    This is a mess taken from the category Seaside-Core-RequestHandling and     the class hierarchies.        This will be refactored into something conceptually useful<a id="org86102b8"></a>### WARequestHandler        WAObject subclass: #WARequestHandler        WARequestHandler is an abstract class whose subclasses handle http requests.     Most of the methods are either empty or return a default value.         Subclasses must implement the following messages:    	handleFiltered:	process the request        Below are the Handlers/registries.<a id="org45a69fe"></a>### WADispatcher    WARequestHandler subclass: #WADispatcher        explore: WADispatcher default    This is the entry point for Seaside.        see WAApplication , which is stored in the WADisplatcher.            WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc).         WADispatcher class>>default is the top level dispatcher.         When a Seaside application is registered as "foo" the application is added to the top level dispatcher.     The application is added to the entryPoints of the dispatcher at the key "foo".     If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo".     That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".           When a http request is received it is sent to WADispatcher class>>default to find the correct handler for the request.     If a handler exists for the request is sent to that handler.     Otherwise the request is sent to the not found response generator.        The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class>>default.     One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming).         Instance Variables:    	defaultName	<String>    	entryPoints	<(Dictionary of: WAEntryPoint)>	 the keys are strings, which are the names and URL path segments for the handler at that key<a id="orga88fa05"></a>### WADocumentHandler    WARequestHandler subclass: #WADocumentHandler            WADocumentHandler handles requests for images,     text documents and     binary files (byte arrays).     This class is not normally used directly.     A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler.     Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document,     registers the handler with a Registry,     and adds the correct url in the tag for the document.        Instance Variables:    	document	<WAMimeDocument>	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.<a id="org805c2b2"></a>### WAFileHandler    WARequestHandler subclass: #WAFileHandler            Seaside serves static files using WAFileLibrary subclasses.     WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server.     WAFileHandler is registered with the default WADispatcher automatically.<a id="org6da91b7"></a>### WAPathConsumer        WAObject subclass: #WAPathConsumer        A WAPathConsumer keeps track of the unconsumed path elements in request handling.        Image the following request path:    /start/middle/end    and a dispatcher mapped at 'start' and an application mapped at 'middle'.        First nothing at all would be consumed so the unconsumed path would be #('start' 'middle' 'end').    Then the dispatcher consumes 'start' and delegates to the application so the unconsumed path would be #('middle' 'end').    Then the application consumes 'middle' so the unconsumed path would be #('end').    In that case    self requestContext consumer peek    inside an #initialRequest: should answer 'end'.        Instance Variables    	path:		<Collection<String>>        path    	- the collection of unconsumed path elements<a id="org4df9865"></a>### WALegacyRedirectionHandler    WARequestHandler subclass: #WALegacyRedirectionHandler        I provide compatibility with old Seaside URLs that have Seaside in the path (eg. '/seaside/examples/counter') by simply removing it.<a id="orgc239a83"></a>### WANextUnconsumedPathElementRequestHandler    WARequestHandler subclass: #WANextUnconsumedPathElementRequestHandler            :nocomment:<a id="orgd9ce377"></a>### WARegistry    WARequestHandler subclass: #WARegistry        WARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd.     WARegistry checks incoming request URLs for a key and looks for a matching active request handler.     If one exists, the request is sent to the proper handler.     If not, the request is either a new request (in which case #handleDefaultRequest: is called)     or a request to a now-inactive handler (in which case #handleExpiredRequest: is called).         These two methods allow subclasses to properly handle these requests.        Subclasses must implement the following messages:    	handleDefaultRequest:    		Handle a request without a session key, ie a new request.    	handlerField    		The URL parameter in which to store the request handler key.        Instance Variables:    	cache - an instance of WACache to hold the stored request handlers<a id="org2821861"></a>### WARegistryConfiguration    WASystemConfiguration subclass: #WARegistryConfiguration        A WARegistryConfiguration is xxxxxxxxx.<a id="org498fb35"></a>### WARequestHandlingConfiguration    WASystemConfiguration subclass: #WARequestHandlingConfiguration            This configuration class holds attributes needed by classes in the Request Handling layer.<a id="org280492a"></a>### WAApplication         WARegistry subclass: #WAApplication            WAApplication is the starting point for a Seaside application.         When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher.   (explore: WADispatcher default)        The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application.         "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)    If you change the cache configuration  you need to send #initializeCache for the changes to take effect.        "libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.        Registering an Application.    	An application can be registered with a dispatcher by using the Seaside configuration page or via code.     Below MyComponent is a subclass of WAComponent.     The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration.         MyComponent class>>initialize    	"self initialize"    	| application |    	application := self registerAsApplication: 'sample'.    	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.    	application addLibrary: SampleLibrary.    	application configuration addAncestor: GlorpConfiguration new.    	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.    	application preferenceAt: #databaseServer put: '127.0.0.1'.    	application preferenceAt: #databaseConnectString put: 'glorptests'.        MyComponent>>someInstanceMethod    	"example of how to access attributes (preferences)"    	self session application preferenceAt: #glorpDatabasePlatform<a id="orgce6ac22"></a>### WARedirectingApplication    WAApplication subclass: #WARedirectingApplication        I revert to the old < 3.3.0 behavior which is easier for tests.<a id="org0f97a70"></a>### WARedirectingRegistry    WARegistry subclass: #WARedirectingRegistry        I revert to the old < 3.3.0 behavior which is easier for tests.<a id="org7a78cc4"></a>### WARestfulHandler    WARequestHandler subclass: #WARestfulHandler        :nocomment:<a id="org2549dc3"></a>### WACORSResourceExample    WARestfulHandler subclass: #WACORSResourceExample        :nocomment:<a id="org0099fbb"></a>### WASession        WARequestHandler subclass: #WASession        I am a Seaside session.     A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.        This class is intended to be subclasses by applications that need global state, like a user.         Custom state can be added by creating instance variables and storing it there.         The session can be retrieved by #session if inside a component or task or by evaluating: WACurrentRequestContext session        If the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system.         To manually expire a session call #expire.        A good way to clear all sessions is the following code:        WARegistry clearAllHandlers.    WAPlatform current garbageCollect<a id="org08bca89"></a>### WAExpirySession    WASession subclass: #WAExpirySession        :nocomment:<a id="org7927e05"></a>### WASessionCookieProtectedSession    WASession subclass: #WASessionCookieProtectedSession            I am a session with a WASessionCookieProtectionFilter.        provide a link here<a id="org9988324"></a>### WATestSession    WASession subclass: #WATestSession        :nocomment:<a id="orgd82bc1d"></a>### WASessionContinuation        WARequestHandler subclass: #WASessionContinuation            I represent a continuation as part of the flow of pages within a session.         I am not a real continuation (as compared to those used in #call: and #answer:),         I only represent a specific point in the session.         I reference the root component and a memory snapshot of backtracked objects.<a id="orgc2bb264"></a>### WANullSessionContinuation    WASessionContinuation subclass: #WANullSessionContinuation        :nocomment:<a id="orgf3ed612"></a>### WARenderLoopContinuation    WASessionContinuation subclass: #WARenderLoopContinuation            :nocomment:<a id="orgd398cf9"></a>### WAActionPhaseContinuation    WARenderLoopContinuation subclass: #WAActionPhaseContinuation        :nocomment:<a id="orgac020df"></a>### WACallbackProcessingActionContinuation        WAActionPhaseContinuation subclass: #WACallbackProcessingActionContinuation            :nocomment:<a id="org2be19ef"></a>### WAInitialRenderLoopContinuation        WAActionPhaseContinuation subclass: #WAInitialRenderLoopContinuation        I'm the initial continuation of a render loop.     I just render the initial page.     Subclasses may want to override #shouldRedirect and answer true so that a redirect happens before displaying the first page.<a id="org249f9e3"></a>### WAPluggableActionContinuation    WAActionPhaseContinuation subclass: #WAPluggableActionContinuation            This continuation executes an action (any class that implements #value or #value:).         If possible, the renderContext is passed in as an argument.         When the action is complete, if a response hasn't been returned, control is passed to a render continuation.'        Instance Variables:    	action	<BlockClosure | BlockContext | GRDelayedSend | MessageSend | WAContinuation | WAPartialContinuation>        :important:<a id="orgd20f641"></a>### WARenderPhaseContinuation    WARenderLoopContinuation subclass: #WARenderPhaseContinuation        :nocomment:<a id="org0379ac3"></a>### WAFlushingRenderPhaseContinuation    WARenderPhaseContinuation subclass: #WAFlushingRenderPhaseContinuation        :nocomment:<a id="orgd49ead2"></a>### WATestNoopRequestHandler    WARequestHandler subclass: #WATestNoopRequestHandler        :nocomment:<a id="org8d0d5a2"></a>### WATestNoopSessionHandler    WARequestHandler subclass: #WATestNoopSessionHandler        :nocomment:<a id="orge60a595"></a>### WARequestContext    WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)    WARequestContext encapsulates all the knowledge that should be available while processing a single request.     It does not matter if this is a request to a static file,     an AJAX request,     a long Comet request     or a normal Seaside requestion.        The request context is valid only during the request that caused it.     It should not be stored.     Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.     In both cases this might lead to memory leaks.<a id="org1dfd06a"></a>## Response<a id="org474fcb8"></a>### WAResponse                WAObject subclass: #WAResponse . I have children                A WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.    See class side initialize protocol for all the responses from the server.<a id="orgfeb3fac"></a>### WABufferedResponse                WAObject subclass: #WAResponse subclass: WABufferedResponse            A WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.        Instance Variables    	contentsStream:		<WriteStream> The contents of this message.            Basically a wrapper on a stream that obtains its headers from the parent.<a id="org8aac07e"></a>### WAComboResponse                WAObject subclass: #WAResponse subclass: WAComboResponse        WAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:        renderContentOn: aCanvas    	"Render the search page"        	self renderSearchLabelOn: aCanvas.    	self requestContext request flush. "flush before starting search to give immediate feedback"        	self searchResultsDo: [ :result |    		self renderSearchResult: result on: aCanvas.    		self requestContext request flush "flush after each search result" ]        After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.        Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.        on the TODO, I will investigate this more, later<a id="orgab341d1"></a>### WAStreamedResponse    WAObject subclass: #WAResponse subclass: WAStreamedResponse        A WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.        Instance Variables    	committed:		<Boolean>	Whether the status and header was written to the stream.    	externalStream:		<WriteStream>	The external stream to write to.<a id="orga25d5da"></a>### WAResponseGenerator    WAObject subclass: #WAResponseGenerator        The response generator configures the response of the provided request context according to the called generation method.     This class can be subclassed to provide custom response templates.<a id="org41e5f88"></a>### WAHtmlResponseGenerator    WAResponseGenerator subclass: #WAHtmlResponseGenerator            This subclass overrides certain generation methods to create prettier HTML responses, instead of plain text.<a id="org7c241c6"></a>## Root<a id="org1b64564"></a>### WARoot    WAObject subclass: #WARoot            A WARoot is the root of a document.         It is responsible to generate header and footer of a document.<a id="orgb2a5000"></a>### WAHtmlRoot        WARoot subclass: #WAHtmlRoot            A WAHtmlRoot is the root element of an HTML Document (<html>).        Instance Variables    	bodyAttrs:		<WAHtmlAttributes>    	context:			<WARenderContext>    	docType:		<String>    	headAttrs:		<WAHtmlAttributes>    	headElements:	<OrderedCollection<WAHtmlElement>>    	htmlAttrs:		<WAHtmlAttributes>    	scripts:			<Set<String>>    	styles:			<Set<String>>    	title:			<String>        bodyAttrs    	- the attributes of the <body> element        context    	- the context used to render the contents of the <body> element        docType    	- the document type        headAttrs    	- the attributes of the <head> element        headElements    	- the elements inside the <head> section        htmlAttrs    	- the attributes of the <html> element        scripts    	- contains the strings returned by WAPresenter >> #script        styles    	- contains the strings returned by WAPresenter >> #style        title    	- the title of the HTML document, the contents of the <title> element                writeHeadOn: aDocument    	aDocument nextPutAll: docType.    	aDocument openTag: 'html' attributes: htmlAttrs.    	aDocument openTag: 'head' attributes: headAttrs.    	self writeElementsOn: aDocument.    	self writeStylesOn: aDocument.    	self writeScriptsOn: aDocument.    	aDocument closeTag: 'head'.    	aDocument openTag: 'body' attributes: bodyAttrs<a id="org59e1fde"></a>### WAXmlRoot        WARoot subclass: #WAXmlRoot        No comment.        writePreambleOn: aDocument    	aDocument nextPutAll: '<?xml version="1.0" encoding="'; nextPutAll: self charSet; nextPutAll: '"?>'<a id="orgbbfac7f"></a>## ScriptGenerator<a id="orgd6ec355"></a>### WAScriptGenerator    WAObject subclass: #WAScriptGenerator        I am responsible to render the loadscripts and make them run on page load.     See subclasses for different strategies.<a id="org607fb8e"></a>### WADefaultScriptGenerator        WAScriptGenerator subclass: #WADefaultScriptGenerator            A WADefaultScriptGenerator uses the onLoad event on the body to trigger the load scripts.     Events handlers are directly inlined with the respective elements.     Both techniques are considered outdated and should be avoided if possible.<a id="orgf2b0a2d"></a>### WANullScriptGenerator    WAScriptGenerator subclass: #WANullScriptGenerator        A script generator that does not support any load scripts.     This results in cleaner HTML and should result in slightly faster page loads.<a id="org4c88513"></a>## Server<a id="orgfca99f5"></a>### WAServerAdaptor    A WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol:     - #codec     - #usesSmalltalkEncoding        Instance Variables    	codec:		<WACodec>        codec    	- the codec used for response conversion from characters to bytes<a id="orga3a1331"></a>### WATestServerAdapator    WAServerAdaptor subclass: #WATestServerAdaptor    A WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager<a id="org904d69d"></a>### WAWebServerAdaptor    WAServerAdaptor subclass: #WAWebServerAdaptor                What does this thing do?    It holds     a reference to its WAServerManager    a port    a requestHandler    a codec    a server of class WebServer from WebClient-Core in squeak    a certName<a id="org9b5e2b1"></a>### WAServerManager    A server manager cares on the available Seaside server adopters<a id="orgf692ce6"></a>### WebServer    Not a part of Seaside in Squeak, but part of WebClient-Core    I wonder if other WebClient-Core classes are used within the WA framework...            WebClient provides a simple yet complete HTTP server implementation.        To view the documentation evaluate:        	HelpBrowser openOn: WebServerHelp.            Does Pharo use a different class?<a id="orgd3f4989"></a>## Snapshot    Class references show WASessionContinuation and WAUpdateStatesVisitor<a id="org8973ffd"></a>### WASnapshot        WAObject subclass: #WASnapshot        I represent a memory snapshot of objects.     Objects can be registered by sending the message #register:.     All object snapshots are updated by sending #snapshot and restored by sending #restore.         To have specific snapshot and restore actions for particular classes,     override #snapshotCopy and #restoreFromSnapshot: in your classes.<a id="orgacb4c12"></a>## Strategy    A Strategy defines a set of algorithms that can be used interchangeably.     Modes of transportation to an airport is an example of a Strategy.     Several options exist such as driving one's own car, taking a taxi, an airport shuttle, a city bus, or a limousine service.         https://sourcemaking.com/design_patterns/strategy<a id="orgc3227e1"></a>### WAHandlerTrackingStrategy        WAObject subclass: #WAHandlerTrackingStrategy            I am a strategy of how request handlers should be tracked by a WARegistry or subclass.        One important thing to remember a WARegistry can contain all kinds of request handlers.     The most common case is a WAApplication that contains both WADocumentHandlers and WASessions.     Some tracking methods may not be appropriate for some kinds of handlers (eg. a WADocumentHandler should never be tracked using a cookie).     Some requests may have multiple keys (eg. a query field for a WADocumentHandler and a cookie for a WASession).     It's the job of the strategy to take this into consideration.        The 'public' protocol contains the methods that a tracking strategy must implement.     The 'private' protocol contains some utility methods that may be helpful implementing these methods.<a id="orgf8eece6"></a>### WAQueryFieldHandlerTrackingStrategy    WAHandlerTrackingStrategy subclass: #WAQueryFieldHandlerTrackingStrategy        I track request handlers using a query field. This results in URLs looking like this:        /tests/functional?_s=de379kaie13        This is a very simple and robust approach.         It is also very convenient for development. Just remove the _s and you have a new session.        However there are some drawbacks. The smallest is aesthetical, the URL in the address bar of the browser is less "clean".     Second because the session id is part of the request URL it shows up in all kinds of places.     For example server logs.     Not only the log of the server running the application but also very web site visited from there because it shows up in the Referer HTTP header.     The danger of this is that when somebody knows the session id of somebody else he can take over his session.     Most of these problems can be mitigated by adding a WARemoteAddressProtectionFilter or WASessionCookieProtectionFilter to every session.         Mind that WARemoteAddressProtectionFilter creates new problems for users with changing IPs (eg. mobile devices) and WASessionCookieProtectionFilter requires cookies.<a id="orgea2fb47"></a>### WASessionTrackingStrategy        WAHandlerTrackingStrategy subclass: #WASessionTrackingStrategy            I am the abstract base class for tracking strategies that track sessions differently from other request handlers (mostly WADocumentHandlers).        Concrete implementsions have to take care that expired document handlers don't expire sessions.<a id="org355f8c6"></a>### WACookieForBrowserIPForCrawlerTrackingStrategy        WASessionTrackingStrategy subclass: #WACookieForBrowserIPForCrawlerTrackingStrategy        WACookieForBrowserIPForCrawlerTrackingStrategy uses cookie based session tracking for browsers and IPs for crawlers (they don't support cookies).         This way there is never a session key in any URL.        This is inspired by:    http://www.tomcatexpert.com/blog/2011/05/18/crawler-session-manager-valve<a id="org24759ed"></a>### WACookieSessionTrackingStrategy    WASessionTrackingStrategy subclass: #WACookieSessionTrackingStrategy            I am the abstract base class for tracking strategies that use cookies to track sessions and query fields to track everything else.<a id="org8b89ac7"></a>### WACookieIfSupportedSessionTrackingStrategy        WACookieSessionTrackingStrategy subclass: #WACookieIfSupportedSessionTrackingStrategy        I use cookies to track sessions if the browser supports it and use query fields (?_s=key) otherwise.     I keep adding the session cookie and the session query field until the session cookie shows up in the request.         Then I stop adding the query field.<a id="org49aaf25"></a>### WAEnterpriseAuberginesStrategy        WACookieIfSupportedSessionTrackingStrategy subclass: #WAEnterpriseAuberginesStrategy            I implement a session tracking strategy that emulates common JavaEE application servers (Tomcat, WildFly AS). I am similar to WACookieIfSupportedSessionTrackingStrategy.        I will do the following    - add a cookie named JSESSIONID    - add a path parameter named jsessionid until we see a cookie, eg. /;jsessionid=1234?_k=5678<a id="org578b34c"></a>### WACookieOnlySessionTrackingStrategy    WACookieSessionTrackingStrategy subclass: #WACookieOnlySessionTrackingStrategy        I track sessions using cookies and everything else using query fields.     This works fine as long as the client accepts cookies. This breaks for web crawlers (they don't accept cookies).<a id="org1a4fea9"></a>### WAInvisibleSessionTrackingStrategy        WASessionTrackingStrategy subclass: #WAInvisibleSessionTrackingStrategy        I am the abstract base class for classes that that use some request attribute that is present on every request for tracking sessions.     For document handlers query fields are used.<a id="org72e9c3e"></a>### WAIPSessionTrackingStrategy    WAInvisibleSessionTrackingStrategy subclass: #WAIPSessionTrackingStrategy        I track sessions using the remote address of a client.     Usually you don't want to use this because it causes troubles when multiple users share the same IP (eg. several users from the same company).         That's why I'm marked as abstract.        There are some special cases like crawlers where it can work though.<a id="org0ad1989"></a>### WASslSessionTrackingStrategy    WAInvisibleSessionTrackingStrategy subclass: #WASslSessionTrackingStrategy            I track sessions using the SSL session id. This has the advantage that the session id never shows up in the request as a parameter or cookie.        Special server configuration to set the life time of an SSL session may be required.        http://www.roseindia.net/javacertification/ibm-287/http_sessions.shtml    http://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Frzatz%2F51%2Fprogram%2Fsesdeci.htm    http://en.wikipedia.org/wiki/Session_fixation#Solution:_Utilize_SSL_.2F_TLS_Session_identifier<a id="org901187a"></a>## Url<a id="org46387f5"></a>### WAUrl\#+BEGIN<sub>EXAMPLE</sub>I represent all portions of an URL as described by the RFC 1738 and updated by RFC 3986. I include scheme, userinfo, host, port, path, parameter, query, and fragment.Instance Variables	scheme:			<String> or nil	user:				<String> or nil	password:			<String> or nil	host:				<String> or nil	port:				<Integer> or nil	path:				<OrderedCollection> or nil	slash:				<Boolean>	queryFields:		<WARequestFields> or nil	fragment:			<String> or nil	pathParameters:	<GROrderedMultiMap> or nilA Primer on URL encoding:<http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding>Path Parameters:<http://doriantaylor.com/policy/http-url-path-parameter-syntax>you can have multiple name without values/path/name;param1;p2;p3or names with multiple values;param=val1,val2,val3#+END<sub>EXAMPLE</sub><a id="orgf7fc2e4"></a>## Visitor<a id="org2307234"></a>### WAVisitor    WAObject subclass: #WAVisitor        Common superclass for all visitors (visitor pattern)<a id="orga7d6863"></a>### WAAttributeVisitor    WAVisitor subclass: #WAAttributeVisitor        A visitor of attributes<a id="org855cf69"></a>### WAUserConfigurationEditorVisitor    WAAttributeVisitor subclass: #WAUserConfigurationEditorVisitor<a id="org87f4ab3"></a>## ValueHolder<a id="orgd04319d"></a>### WAValueHolder    WAObject subclass: #WAValueHolder        I wrap a single object.     I am like value holder except that I am portable and don't include the Model cruft in Squeak.<a id="org8a7440b"></a>## HOWTO    an assortment of howtos follows<a id="orgd733956"></a>### Clear Sessions    To manually expire a session call #expire.        A good way to clear all sessions is the following code:        WARegistry clearAllHandlers.    WAPlatform current garbageCollect            Here is another one:        https://discord.com/channels/223421264751099906/311419918631305218/940852922776948746    how to end a session and redirect.<a id="orgfb711c4"></a>## Bibliography    https://github.com/gettimothy/Doc-Seaside        https://github.com/seasidest        https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration        https://sourcemaking.com/design_patterns/strategy        http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding