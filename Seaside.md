# Table of Contents1.  [Seaside](#org44d4cd2)    1.  [Introduction](#org5c92607)    2.  [Followup](#org88547e5)    3.  [Cache](#org8542462)        1.  [Cache](#org1ef3d76)        2.  [WACache](#org40e52e3)    4.  [Codec](#org19f7226)        1.  [GRCodec](#org51ca420)    5.  [Context](#org1937901)        1.  [WAContextTest](#orgab69da5)        2.  [WARequestContext](#orgbcacb35)    6.  [KeyGenerator](#orge93ea9c)        1.  [WAKeyGenerator](#org43b1b03)    7.  [Registry](#orgd1bf065)    8.  [Rendering](#orga0a5fdd)        1.  [WARenderContext](#org0fc22c4)    9.  [Request](#orgd7df63e)        1.  [WARequest](#org2127311)    10. [RequestHandler](#orgc905d8a)        1.  [WARequestHandler](#orgf20f20c)    11. [Response](#orgedb1afc)        1.  [Response](#org62ae2ad)        2.  [WAResponse](#orgf67325c)    12. [Server](#org3a087f8)        1.  [WAServerAdaptor](#orgc718fb8)        2.  [WAServerManager](#orgd929926)        3.  [WebServer](#orgb4c0c4e)    13. [Visitor](#org10e939f)        1.  [Visitor](#orgaa1e418)        2.  [WAVisitor](#org27ade94)    14. [Todo below here](#org658daa3)        1.  [Errors](#orgbc919bd)        2.  [WAError](#orgfe3ce25)        3.  [WAAuthConfigurationError](#org0cb6a7b)        4.  [GRPlatform](#org76e53e6)        5.  [GRPharoPlatform](#orgad7232b)        6.  [GRSqueakPlatform](#org98427c1)        7.  [Transient Value Holder](#org1f7406c)        8.  [WAValueHolder](#org75c0c6a)        9.  [WADynamic Variable](#org6d59bf2)        10. [WAKeyGenerator](#org0f72ac9)        11. [WAMutex](#orge775c3a)        12. [WACookie](#orga008674)        13. [WARequestCookie](#orga2c2a3c)        14. [WAMergedRequestFields](#org644d160)    15. [HOWTO](#orge7d6ef2)        1.  [Clear Sessions](#orgd26da08)    16. [Bibliography](#orgc67cc08)<a id="org44d4cd2"></a># Seaside<a id="org5c92607"></a>## Introduction    Working Notes of an "in depth" study of the Seaside guts and patterns.<a id="org88547e5"></a>## Followup    Update Doc to handle TAGS and ignore #Startup etc.    Squeak uses WebServer, does Pharo use Kom thing?<a id="org8542462"></a>## Cache<a id="org1ef3d76"></a>### TODO Cache    Get examples/strategies/use-cases of WAExpiringCache    see if we can hack Seaside using examples from:         https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration<a id="org40e52e3"></a>### WACache    WAObject subclass: #WACache            WACacheis the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCache.        >>keySize returns 16        All other instance methods implement self subclassResponsibility1.  WABidirectionalCache        WACache subclass: #WABidirectionalCache                I support key -> value and value -> key mappings and never forget anything.                I also implement serveral methods of Dictionary.        1.  WAPredictableCache                WABidirectionalCache subclass: #WAPredictableCache                        A WAPredictableCache is a WACache that uses incrementing numbers as cache keys. This way the keys are predictable.             This is useful for tests.2.  WAExpiringCache        WACache subclass: #WAExpiringCache                I am the abstract base class for caches that remove entries. Subclasses are intended to use to track sessions.                    Instance Variables        	maximumSize			<Integer>        	maximumRelativeAge		<Integer>        	maximumAbsoluteAge	<Integer>        	overflowAction			<Symbol>        				        maximumSize:        	Number of sessions supported. When this limit is reached the overflow action is run. 0 for no maximum size. Has to be positive.                maximumRelativeAge:        	After so many seconds of inactivity a session is considered expired. 0 for no limit. Has to be positive.                maximumAbsoluteAge:        	After so many seconds after its creation a session is considered expired no matter when it was last accessed. 0 for no limit. Has to be positive.                overflowAction:        	What to do when the maximum number of sessions is reached. Only matters when the maximum size is bigger than 0.        	Possible values:        		#removeRelativeOldest remove the entry that hasn't been accessed for the longest time        		#removeAbsoluteOldest remove the entry that has been created the longest time ago        		#signalError signal WAMaximumNumberOfSessionsExceededError        1.  WABulkReapingCache                WAExpiringCache subclass: #WABulkReapingCache                        I am a cache that reaps all elements at once instead of incrementally.                        I am intended to be used in GemStone/S instead of WAHashCache. A background process should send #reap to me.                            Instance Variables            	dictionary:		<Dictionary>        2.  WAHashCache                WAExpiringCache subclass: #WAHashCache                        WAHashCache is a hash table based implementation of WACache.                        The characteristics of WAHashCache are:            - supports both absolute and relative timeouts at the same time https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration            - supports a maximum size with definable overflow action (expire oldest, expire least recently used, signal exception)            - access by key is fast (O(1) average case O(n) worst case)            - reaping expired sessions is proportional (O(n)) to the number of expired session and independent of the total number of sessions (O(1))            - creating a new session independent of the total number of sessions            - does not guard against hash collision attacks, you should not use user generated keys                        Instance Variables:            	keyTable 				<Array<WACacheKeyEntry>>            	size					<Integer>            	byAccessStart			<WACacheListEntry>            	byAccessEnd			<WACacheListEntry>            	byCreationStart		<WACacheListEntry>            	byCreationEnd			<WACacheListEntry>                        keyTable:            	Open hash table of  WACacheKeyEntry                        byAccessStart            	Head of the linked list sorted by access time                        byAccessEnd	            	Tail of the linked list sorted by access time                        byCreationStart            	Head of the linked list sorted by creation time                        byCreationEnd            	Tail of the linked list sorted by creation time                                    The implementation is a combination of:            - an open hash table, used for look ups by key             - a linked list of cache entries sorted by creation time, used for reaping by absolute age            - a linked list of cache entries sorted by access time, used for reaping by relative age                        For every cache entry there is a node in the hash table and a node in both of the linked lists. It is possible to navigate from every node for a key to every other node of the same key. This is required for removing and updating entries.3.  WAMutualExclusionCache        WACache subclass: #WAMutualExclusionCache                WAMutualExclusionCacheNG is a wrapper around a WACacheNG that wraps all messages in a mutex.                Instance Variables:        	mutex	<WAMutex>        	cache	<WACache>4.  WAUnidirectionalCache        WACache subclass: #WAUnidirectionalCache                I support only key -> value mappings and never forget anything.<a id="org19f7226"></a>## Codec    When a WAServerAdaptor is spun up, it has a GRNullCodec as its default.        the codec used for response conversion from characters to bytes    DECODING: Outside Data Converted Into the Image    ENCODING: Image data sent to outside the Image<a id="org51ca420"></a>### GRCodec            A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding)     and back outside the image (encoding).         The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.1.  GRNullCodec        GRObject subclass: #GRCodec                The null codec always returns the original streams.         It assumes that the outside world uses the same encoding as the inside world.         This is highly efficient as no transformation is applied to the data, but has its drawbacks.        1.  GRPharoLating1Codec                GRNullCodec subclass: #GRPharoLatin1Codec                                    A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).2.  GRPharoGenericCodec        GRCodec subclass: #GRPharoGenericCodec                :nocomment:3.  GRPharoUtf8Codec        GRCodec subclass: #GRPharoUtf8Codec                A WAUtf8Codec is a WACodec optimized for UTF-8.<a id="org1937901"></a>## Context<a id="orgab69da5"></a>### WAContextTest<a id="orgbcacb35"></a>### WARequestContext    WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)    WARequestContext encapsulates all the knowledge that should be available while processing a single request.     It does not matter if this is a request to a static file,     an AJAX request,     a long Comet request     or a normal Seaside requestion.        The request context is valid only during the request that caused it.     It should not be stored.     Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.     In both cases this might lead to memory leaks.<a id="orge93ea9c"></a>## KeyGenerator<a id="org43b1b03"></a>### WAKeyGenerator    WAObject subclass: #WAKeyGenerator        :nocomment:1.  WAPrecomputedKeyGenerator        WAKeyGenerator subclass: #WAPrecomputedKeyGenerator                :nocomment:<a id="orgd1bf065"></a>## Registry    see WARegistry under WARequestHandler<a id="orga0a5fdd"></a>## Rendering<a id="org0fc22c4"></a>### WARenderContext    WAObject subclass: #WARenderContext        A WARenderContext provides all the state needed by a Renderer to do its work.        It is a decoupling device between whatever is initiating rendering and the Renderer itself.<a id="orgd7df63e"></a>## Request<a id="org2127311"></a>### WARequest        WAObject subclass: #WARequest  has no children        I am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.        Instance Variables    	method:			<String>    	uri:					<WAUrl>    	version:				<WAHttpVersion>    	remoteAddress:	<String>    	headers:			<Dictionary<String, String>>    	cookies:			<Collection<WARequestCookie>>    	body:				<String>    	postFields:			<WARequestFields>    	sslSessionId:		<String>    			    method    	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		        uri    	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.    	    version    	- The version of this request.    	    remoteAddress    	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.        headers    	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.    	    cookies    	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.    	    body    	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.    	    postFields    	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.    	    sslSessionId    	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.<a id="orgc905d8a"></a>## RequestHandlerBelow are the Handlers/registries.<a id="orgf20f20c"></a>### WARequestHandler        WAObject subclass: #WARequestHandler        WARequestHandler is an abstract class whose subclasses handle http requests.     Most of the methods are either empty or return a default value.         Subclasses must implement the following messages:    	handleFiltered:	process the request1.  WADispatcher        WARequestHandler subclass: #WADispatcher                explore: WADispatcher default        This is the entry point for Seaside.                see WAApplication , which is stored in the WADisplatcher.                        WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc).                 WADispatcher class>>default is the top level dispatcher.                 When a Seaside application is registered as "foo" the application is added to the top level dispatcher.         The application is added to the entryPoints of the dispatcher at the key "foo".         If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo".         That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".                   When a http request is received it is sent to WADispatcher class>>default to find the correct handler for the request.         If a handler exists for the request is sent to that handler.         Otherwise the request is sent to the not found response generator.                The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class>>default.         One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming).                 Instance Variables:        	defaultName	<String>        	entryPoints	<(Dictionary of: WAEntryPoint)>	 the keys are strings, which are the names and URL path segments for the handler at that key2.  WADocumentHandler        WARequestHandler subclass: #WADocumentHandler                        WADocumentHandler handles requests for images,         text documents and         binary files (byte arrays).         This class is not normally used directly.         A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler.         Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document,         registers the handler with a Registry,         and adds the correct url in the tag for the document.                Instance Variables:        	document	<WAMimeDocument>	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.3.  WAFileHandler        WARequestHandler subclass: #WAFileHandler                        Seaside serves static files using WAFileLibrary subclasses.         WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server.         WAFileHandler is registered with the default WADispatcher automatically.4.  WALegacyRedirectionHandler        WARequestHandler subclass: #WALegacyRedirectionHandler                I provide compatibility with old Seaside URLs that have Seaside in the path (eg. '/seaside/examples/counter') by simply removing it.5.  WANextUnconsumedPathElementRequestHandler        WARequestHandler subclass: #WANextUnconsumedPathElementRequestHandler                        :nocomment:6.  WARegistry        WARequestHandler subclass: #WARegistry                WARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd.         WARegistry checks incoming request URLs for a key and looks for a matching active request handler.         If one exists, the request is sent to the proper handler.         If not, the request is either a new request (in which case #handleDefaultRequest: is called)         or a request to a now-inactive handler (in which case #handleExpiredRequest: is called).                 These two methods allow subclasses to properly handle these requests.                Subclasses must implement the following messages:        	handleDefaultRequest:        		Handle a request without a session key, ie a new request.        	handlerField        		The URL parameter in which to store the request handler key.                Instance Variables:        	cache - an instance of WACache to hold the stored request handlers        1.  WAApplication                             WARegistry subclass: #WAApplication                                    WAApplication is the starting point for a Seaside application.                         When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher.   (explore: WADispatcher default)                        The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application.                         "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)            If you change the cache configuration  you need to send #initializeCache for the changes to take effect.                        "libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.                        Registering an Application.            	An application can be registered with a dispatcher by using the Seaside configuration page or via code.             Below MyComponent is a subclass of WAComponent.             The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration.                         MyComponent class>>initialize            	"self initialize"            	| application |            	application := self registerAsApplication: 'sample'.            	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.            	application addLibrary: SampleLibrary.            	application configuration addAncestor: GlorpConfiguration new.            	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.            	application preferenceAt: #databaseServer put: '127.0.0.1'.            	application preferenceAt: #databaseConnectString put: 'glorptests'.                        MyComponent>>someInstanceMethod            	"example of how to access attributes (preferences)"            	self session application preferenceAt: #glorpDatabasePlatform                1.  WARedirectingApplication                        WAApplication subclass: #WARedirectingApplication                                I revert to the old < 3.3.0 behavior which is easier for tests.        2.  WARedirectingRegistry                WARegistry subclass: #WARedirectingRegistry                        I revert to the old < 3.3.0 behavior which is easier for tests.7.  WARestfulHandler        WARequestHandler subclass: #WARestfulHandler                :nocomment:        1.  WACORSResourceExample                WARestfulHandler subclass: #WACORSResourceExample                        :nocomment:8.  WASession                WARequestHandler subclass: #WASession                I am a Seaside session.         A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.                This class is intended to be subclasses by applications that need global state, like a user.                 Custom state can be added by creating instance variables and storing it there.                 The session can be retrieved by #session if inside a component or task or by evaluating: WACurrentRequestContext session                If the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system.                 To manually expire a session call #expire.                A good way to clear all sessions is the following code:                WARegistry clearAllHandlers.        WAPlatform current garbageCollect        1.  WAExpirySession                WASession subclass: #WAExpirySession                        :nocomment:        2.  WASessionCookieProtectedSession                WASession subclass: #WASessionCookieProtectedSession                                    I am a session with a WASessionCookieProtectionFilter.                        provide a link here        3.  WATestSession                WASession subclass: #WATestSession                        :nocomment:9.  WASessionContinuation                WARequestHandler subclass: #WASessionContinuation                        I represent a continuation as part of the flow of pages within a session.                 I am not a real continuation (as compared to those used in #call: and #answer:),                 I only represent a specific point in the session.                 I reference the root component and a memory snapshot of backtracked objects.        1.  WANullSessionContinuation                WASessionContinuation subclass: #WANullSessionContinuation                        :nocomment:        2.  WARenderLoopContinuation                WASessionContinuation subclass: #WARenderLoopContinuation                                    :nocomment:                1.  WAActionPhaseContinuation                        WARenderLoopContinuation subclass: #WAActionPhaseContinuation                                :nocomment:                        1.  WACallbackProcessingActionContinuation                                                    WAActionPhaseContinuation subclass: #WACallbackProcessingActionContinuation                                                            :nocomment:                        2.  WAInitialRenderLoopContinuation                                                    WAActionPhaseContinuation subclass: #WAInitialRenderLoopContinuation                                        I'm the initial continuation of a render loop.                     I just render the initial page.                     Subclasses may want to override #shouldRedirect and answer true so that a redirect happens before displaying the first page.                        3.  WAPluggableActionContinuation                                WAActionPhaseContinuation subclass: #WAPluggableActionContinuation                                                            This continuation executes an action (any class that implements #value or #value:).                                         If possible, the renderContext is passed in as an argument.                                         When the action is complete, if a response hasn't been returned, control is passed to a render continuation.'                                        Instance Variables:                    	action	<BlockClosure | BlockContext | GRDelayedSend | MessageSend | WAContinuation | WAPartialContinuation>                                        :important:                2.  WARenderPhaseContinuation                        WARenderLoopContinuation subclass: #WARenderPhaseContinuation                                :nocomment:                        1.  WAFlushingRenderPhaseContinuation                                WARenderPhaseContinuation subclass: #WAFlushingRenderPhaseContinuation                                        :nocomment:10. WATestNoopRequestHandler        WARequestHandler subclass: #WATestNoopRequestHandler                :nocomment:11. WATestNoopSessionHandler        WARequestHandler subclass: #WATestNoopSessionHandler                :nocomment:<a id="orgedb1afc"></a>## Response<a id="org62ae2ad"></a>### TODO Response    Write a mockups of     WAComboResponse    WAStreamedResponse<a id="orgf67325c"></a>### WAResponse                WAObject subclass: #WAResponse . I have children                A WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.    See class side initialize protocol for all the responses from the server.1.  WABufferedResponse                                WAObject subclass: #WAResponse subclass: WABufferedResponse                        A WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.                Instance Variables        	contentsStream:		<WriteStream> The contents of this message.                        Basically a wrapper on a stream that obtains its headers from the parent.2.  WAComboResponse                                WAObject subclass: #WAResponse subclass: WAComboResponse                WAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:                renderContentOn: aCanvas        	"Render the search page"                	self renderSearchLabelOn: aCanvas.        	self requestContext request flush. "flush before starting search to give immediate feedback"                	self searchResultsDo: [ :result |        		self renderSearchResult: result on: aCanvas.        		self requestContext request flush "flush after each search result" ]                After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.                Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.                on the TODO, I will investigate this more, later3.  WAStreamedResponse        WAObject subclass: #WAResponse subclass: WAStreamedResponse                A WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.                Instance Variables        	committed:		<Boolean>	Whether the status and header was written to the stream.        	externalStream:		<WriteStream>	The external stream to write to.<a id="org3a087f8"></a>## Server<a id="orgc718fb8"></a>### WAServerAdaptor    A WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol:     - #codec     - #usesSmalltalkEncoding        Instance Variables    	codec:		<WACodec>        codec    	- the codec used for response conversion from characters to bytes1.  WATestServerAdapator        WAServerAdaptor subclass: #WATestServerAdaptor        A WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager2.  WAWebServerAdaptor        WAServerAdaptor subclass: #WAWebServerAdaptor                                What does this thing do?        It holds         a reference to its WAServerManager        a port        a requestHandler        a codec        a server of class WebServer from WebClient-Core in squeak        a certName<a id="orgd929926"></a>### WAServerManager    A server manager cares on the available Seaside server adopters<a id="orgb4c0c4e"></a>### WebServer    Not a part of Seaside in Squeak, but part of WebClient-Core    I wonder if other WebClient-Core classes are used within the WA framework...            WebClient provides a simple yet complete HTTP server implementation.        To view the documentation evaluate:        	HelpBrowser openOn: WebServerHelp.            Does Pharo use a different class?<a id="org10e939f"></a>## Visitor<a id="orgaa1e418"></a>### TODO Visitorget a sense of the things WAVisitor children do.<a id="org27ade94"></a>### WAVisitor    WAObject subclass: #WAVisitor        Common superclass for all visitors (visitor pattern)1.  WAAttributeVisitor        WAVisitor subclass: #WAAttributeVisitor                A visitor of attributes        1.  WAUserConfigurationEditorVisitor                WAAttributeVisitor subclass: #WAUserConfigurationEditorVisitor2.  WAPainterVisitor        WAVisitor subclass: #WAPainterVisitor                        An implementation of the Visitor pattern for Painter subclasses.        1.  WAHaloVisitor                WAPainterVisitor subclass: #WAHaloVisitor        2.  WAInitialRequestVisitor                            WAPainterVisitor subclass: #WAInitialRequestVisitor        3.  WAPluggablePresenterVisitor                WAPainterVisitor subclass: #WAPluggablePresenterVisitor            NO CLASS COMMENT        4.  WAPresenterGuide                WAPainterVisitor subclass: #WAPresenterGuide                        WAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations.             Along the way, they will ask their client to visit each Painter they come across.            This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.                1.  WARenderingGuide                        WAPresenterGuide subclass: #WARenderingGuide                                Currently an empty class but still present for clarity and to allow customization of Rendering behaviour.                2.  WAVisiblePresenterGuide                        WAPresenterGuide subclass: #WAVisiblePresenterGuide                                Visit the tree of all Presenters and their registered #children.                 Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.                3.  WAAllPresenterGuide                        WAVisiblePresenterGuide subclass: #WAAllPresenterGuide                                Visit the tree of all Presenters and their registered #children.        5.  WARenderVisitor                            WAPainterVisitor subclass: #WARenderVisitor                        A visitor that renders Painters.             It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.        6.  WATaskVisitor                WAPainterVisitor subclass: #WATaskVisitor        7.  WAUpdateRootVisitor                WAPainterVisitor subclass: #WAUpdateRootVisitor                        A visitor which asks Painters to update a WARoot subclass using #updateRoot:.                        This is used to update the root of the Document stored on a WARenderContext.        8.  WAUpdateStatesVisitor                WAPainterVisitor subclass: #WAUpdateStatesVisitor                                    A visitor which asks Painters to update a WARoot subclass using #updateRoot:.                        This is used to update the root of the Document stored on a WARenderContext.        9.  WAUpdateUrlVisitor                WAPainterVisitor subclass: #WAUpdateUrlVisitor                        A visitor which asks Painters to update a WAUrl subclass using #updateRoot:.                        This is used to update the base URL stored on a WARenderContext.<a id="org658daa3"></a>## Todo below here<a id="orgbc919bd"></a>### Errors<a id="orgfe3ce25"></a>### WAError        GRError subclass: #WAError        Common superclass for Seaside errors<a id="org0cb6a7b"></a>### WAAuthConfigurationError    WAError subclass: #WAAuthConfigurationError        A WAAuthConfigurationError is signaled when no WAAuthConfiguration was added to an application that is behind a WAAuthenticationFilter.<a id="org76e53e6"></a>### GRPlatform<a id="orgad7232b"></a>### GRPharoPlatform    GRPlatform subclass: #GRPharoPlatform        A GRPharoPlatform is the Pharo implementation of GRPlatform, the Grease class that provides functionality that can not be implemented in a platform independent way.<a id="org98427c1"></a>### GRSqueakPlatform    GRPharoPlatform subclass: #GRSqueakPlatform<a id="org1f7406c"></a>### Transient Value Holder<a id="org75c0c6a"></a>### WAValueHolder    WAObject subclass: #WAValueHolder        I wrap a single object.     I am like value holder except that I am portable and don't include the Model cruft in Squeak.<a id="org6d59bf2"></a>### WADynamic Variable<a id="org0f72ac9"></a>### WAKeyGenerator<a id="orge775c3a"></a>### WAMutex<a id="orga008674"></a>### WACookie                I represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.    You can never trust information in a cookie, the client is free to edit it.    I model only a part of the full cookie specification.        Browser support:    http://www.mnot.net/blog/2006/10/27/cookie_fun        Netscape spec    http://cgi.netscape.com/newsref/std/cookie_spec.html        Cookie spec    http://tools.ietf.org/html/rfc2109        Cookie 2 spec    https://tools.ietf.org/html/rfc6265        HttpOnly    http://msdn2.microsoft.com/en-us/library/ms533046.aspx    https://bugzilla.mozilla.org/show_bug.cgi?id=178993        Compared to WARequestCookie I represent the information that is sent to the user agent.<a id="orga2c2a3c"></a>### WARequestCookie    A WARequestCookie is the cookie the user agent sent to the server.        Instance Variables    	domain:			<String>    	key:			<String>    	path:			<String>    	pathEncoded:	<String>    	ports:			<Collection<Integer>>    	value:			<String>    	version:			<Integer>        domain    	- xxxxx        key    	- xxxxx        path    	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:      1.  Let uri-path be the path portion of the request-uri if such a           portion exists (and empty otherwise).  For example, if the           request-uri contains just a path (and optional query string),           then the uri-path is that path (without the %x3F ("?") character           or query string), and if the request-uri contains a full           absoluteURI, the uri-path is the path component of that URI.           2.  If the uri-path is empty or if the first character of the uri-           path is not a %x2F ("/") character, output %x2F ("/") and skip           the remaining steps.           3.  If the uri-path contains no more than one %x2F ("/") character,           output %x2F ("/") and skip the remaining step.           4.  Output the characters of the uri-path from the first character up           to, but not including, the right-most %x2F ("/").        ports    	- xxxxx        value    	- xxxxx        version    	- the version of the cookie specification supported, currently only 1 is known<a id="org644d160"></a>### WAMergedRequestFields        Provides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.<a id="orge7d6ef2"></a>## HOWTO    an assortment of howtos follows<a id="orgd26da08"></a>### Clear Sessions    To manually expire a session call #expire.        A good way to clear all sessions is the following code:        WARegistry clearAllHandlers.    WAPlatform current garbageCollect<a id="orgc67cc08"></a>## Bibliography    https://github.com/seasidest        https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration