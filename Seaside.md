Table of Contents=================1.  [Seaside](#org46d6bfa)    1.  [Introduction](#org873237d)    2.  [JSCore](#org16b5b80)        1.  [JSJoin](#orgb9f5c32)        2.  [JSJson](#org5ca60c2)        3.  [JSLogger](#org989e691)        4.  [JSScript](#org26c758c)        5.  [JSFunction](#org13464e8)    3.  [JSDecoration](#orgc2189b5)    4.  [JQuery](#org4639e14)    5.  [JQ](#orgcc59a2e)    6.  [JQAjax](#orgdac27e3)    7.  [JQWidget](#orge85df0a)    8.  [Brush](#org880f7fe)        1.  [WACompund](#orgd48ff22)        2.  [WAJsonBrush](#orgc638beb)        3.  [WAJsonArrayBrush](#org7f140d9)        4.  [WAJsonElementBrush](#org78b4a26)        5.  [WAJsonKeyValueBrush](#orgde9e805)        6.  [WAJsonValueBrush](#orgc6a98cb)        7.  [WAJsonObjectBrush](#org82b738e)        8.  [WATagBrush](#org3eb1d06)    9.  [Builder](#org85027ef)    10. [Cache](#orgc593f11)        1.  [WACache](#org1f92792)        2.  [WABidirectionalCache](#orge414d8b)        3.  [WAPredictableCache](#org0b22acb)        4.  [WAExpiringCache](#org16d2377)        5.  [WABulkReapingCache](#org03c14f4)        6.  [WAHashCache](#orgdef80b9)        7.  [WAMutualExclusionCache](#orgba6a187)        8.  [WAUnidirectionalCache](#org0996f40)    11. [Codec](#org7c10414)        1.  [GRCodec](#orga042780)        2.  [GRNullCodec](#org803a759)        3.  [GRPharoLating1Codec](#org2e6210c)        4.  [GRPharoGenericCodec](#org490e716)        5.  [GRPharoUtf8Codec](#orge62e1e8)    12. [Context](#org289004e)        1.  [WAContextTest](#orge956c04)        2.  [WARequestContext](#org0067eb1)    13. [Document](#orgedcc70b)    14. [Key Generator](#org99872db)        1.  [WAKeyGenerator](#orgda633bc)        2.  [WAPrecomputedKeyGenerator](#org827896a)    15. [Painter](#org8c153f8)        1.  [WAPainterVisitor](#orge6761ef)        2.  [WAHaloVisitor](#orge93f198)        3.  [WAInitialRequestVisitor](#orgcb85565)        4.  [WAPluggablePresenterVisitor](#orgd33ca45)        5.  [WAPresenterGuide](#org56d645d)        6.  [WARenderingGuide](#org24d92d9)        7.  [WAVisiblePresenterGuide](#org6845071)        8.  [WAAllPresenterGuide](#org9dce885)        9.  [WARenderVisitor](#org16598b2)        10. [WATaskVisitor](#orgc00541f)        11. [WAUpdateRootVisitor](#org610c791)        12. [WAUpdateStatesVisitor](#orgeac7cc0)        13. [WAUpdateUrlVisitor](#org959c723)    16. [Registry](#org6663e4c)    17. [Renderer](#org9f019b2)        1.  [WARenderer](#orgbb2ece4)        2.  [WACanvas](#orgc6aa7d0)        3.  [WAJsonCanvas](#org8e4b821)        4.  [WATagCanvas](#org8814f26)        5.  [WAHtmlCanvas](#org909b828)        6.  [WAXmlCanvas](#org5eb459c)    18. [Render Context](#org73c8ed7)        1.  [WARenderContext](#orgefd71a7)    19. [Request](#org08075df)        1.  [WARequest](#org6d07e3c)    20. [Request Handler and  Continuation](#orgb179910)        1.  [WARequestHandler](#orgfdae77e)        2.  [WADispatcher](#org9e87095)        3.  [WADocumentHandler](#org168134c)        4.  [WAFileHandler](#org4d5db3c)        5.  [WALegacyRedirectionHandler](#org26fdd87)        6.  [WANextUnconsumedPathElementRequestHandler](#orgfceb43e)        7.  [WARegistry](#orga605cde)        8.  [WAApplication](#org93352ac)        9.  [WARedirectingApplication](#orga0b5f11)        10. [WARedirectingRegistry](#org4a3efa4)        11. [WARestfulHandler](#orgc65ab3a)        12. [WACORSResourceExample](#orgd7eeaca)        13. [WASession](#orgf1ce3c4)        14. [WAExpirySession](#orgee2b71b)        15. [WASessionCookieProtectedSession](#orgc3cb99f)        16. [WATestSession](#orgf7133b4)        17. [WASessionContinuation](#org582632c)        18. [WANullSessionContinuation](#org05407e5)        19. [WARenderLoopContinuation](#org5c51848)        20. [WAActionPhaseContinuation](#org951b4ac)        21. [WACallbackProcessingActionContinuation](#org5e5290b)        22. [WAInitialRenderLoopContinuation](#org1a8a290)        23. [WAPluggableActionContinuation](#org495ad59)        24. [WARenderPhaseContinuation](#orge311c62)        25. [WAFlushingRenderPhaseContinuation](#orgd30a018)        26. [WATestNoopRequestHandler](#org96a8ba8)        27. [WATestNoopSessionHandler](#orgafdafbb)    21. [Response](#org8ffca1e)        1.  [WAResponse](#orgb7e2a0f)        2.  [WABufferedResponse](#org153bbb3)        3.  [WAComboResponse](#org7c28e89)        4.  [WAStreamedResponse](#org842da38)    22. [Server](#orgc769629)        1.  [WAServerAdaptor](#orgf404582)        2.  [WATestServerAdapator](#org03d6ab6)        3.  [WAWebServerAdaptor](#org07e6684)        4.  [WAServerManager](#org23c1275)        5.  [WebServer](#org8922466)    23. [Visitor](#orgb981424)        1.  [WAVisitor](#org852495a)        2.  [WAAttributeVisitor](#org3923839)        3.  [WAUserConfigurationEditorVisitor](#org776d9ea)    24. [HOWTO](#orgd8d450a)        1.  [Clear Sessions](#orgb2249a9)    25. [Followup](#org43bdc16)    26. [Bibliography](#org8329323)    27. [Todo below here](#orged6ef7b)        1.  [Builder](#orgef29316)        2.  [Error](#org491e394)        3.  [WAError](#org321b7f0)        4.  [WAAuthConfigurationError](#org9e46ca9)        5.  [GRPlatform](#org276c492)        6.  [GRPharoPlatform](#orgd6214ea)        7.  [GRSqueakPlatform](#org5d80169)        8.  [Transient Value Holder](#orgbd3464b)        9.  [WAValueHolder](#org6369581)        10. [WADynamic Variable](#org072dcb4)        11. [WAKeyGenerator](#org7cfdca6)        12. [WAMutex](#org5a6bab4)        13. [WACookie](#org19ffcb7)        14. [WARequestCookie](#orgb92f5c8)        15. [WAMergedRequestFields](#orge66a747)<a id="org46d6bfa"></a>Seaside=======<a id="org873237d"></a>Introduction------------    Working Notes of an "in depth" study of the Seaside guts and patterns.<a id="org16b5b80"></a>JSCore------1.  JSJoin2.  JSJson3.  JSLogger4.  JSScript                JSObject subclass: #JSScript                I represent a sequence of JavaScript statements.5.  JSFunction<a id="orgc2189b5"></a>JSDecoration------------<a id="org4639e14"></a>JQuery------<a id="orgcc59a2e"></a>JQ--<a id="orgdac27e3"></a>JQAjax------<a id="orge85df0a"></a>JQWidget--------<a id="org880f7fe"></a>Brush-----    WAObject subclass: #WABrush    I represent a brush to be used on a *WACanvas*.        Instance Variables    	canvas:		The canvas instance I am used with.    	parent:		The parent brush I am used within.    	closed:		Wether I have been closed/flushed yet.        I have three immediate subclasses:    WACompound    WAJsonBrush    WATagBrush1.  WACompund        WABrush subclass: #WACompound                I am the superclass for stuff that is not html element but you still want to access via the canvas API.                I have two subclasses and do not appear to be very popular.2.  WAJsonBrush        WABrush subclass: #WAJsonBrush                A brush to generate JSON3.  WAJsonArrayBrush                WAJsonBrush subclass: #WAJsonArrayBrush                        Brush for a JSON array4.  WAJsonElementBrush        WAJsonBrush subclass: #WAJsonElementBrush                        Abstract superclass for JSON elements5.  WAJsonKeyValueBrush                WAJsonElementBrush subclass: #WAJsonKeyValueBrush                        A JSON key value6.  WAJsonValueBrush                WAJsonElementBrush subclass: #WAJsonValueBrush                A JSON value7.  WAJsonObjectBrush        WAJsonBrush subclass: #WAJsonObjectBrush                                A brush to generate a JSON object8.  WATagBrush        WABrush subclass: #WATagBrush                        This is the superclass for all XML element classes. Its main additions are        - element name (#tag)        - attributes (instance of WAHtmlAttributes)        - common events (onXXX), this is a hack and would better be solved with traits                        My subclasses are:                WAAnchorTag         WABasicFormTag         WABreakTag         WACanvasTag         WACollectionTag         WACommandTag         WADetailsTag         WAEmbedTag         WAEventSourceTag         WAFieldSetTag         WAFormInputTag         WAGenericTag         WAHeadingTag         WAHorizontalRuleTag         WAIframeTag         WAImageTag         WAKeyGeneratorTag         WALabelTag         WAMediaElementTag         WAMenuTag         WAMeterTag         WAObjectTag         WAOptionGroupTag         WAOptionTag         WAOptionalBreakTag         WAOutputTag         WAParameterTag         WAProgressTag         WARubyTextTag         WAScriptTag         WASourceTag         WATableCellTag         WATableTag         WATimeTag         WATrackTag         WAImageMapTag         WAPopupAnchorTag         WAFormTag         WADatalistTag         WAListTag         WASelectTag         WAAbstractTextAreaTag         WAButtonTag         WACheckboxTag         WAFileUploadTag         WAHiddenInputTag         WARadioButtonTag         WASubmitButtonTag         WAEditTag ZurbIFrameTag         WAAudioTag         WAVideoTag         WATableColumnGroupTag         WATableDataTag         WAOrderedListTag         WAUnorderedListTag         WAMultiSelectTag         WAColorInputTag         WAEmailInputTag         WASearchInputTag         WASteppedTag         WATelephoneInputTag         WATextAreaTag         WATextInputTag         WAUrlInputTag         WACancelButtonTag         WAImageButtonTag         WATableColumnTag         WATableHeadingTag         WAClosedRangeTag         WADateInputTag         WADateTimeInputTag         WADateTimeLocalInputTag         WAMonthInputTag         WAWeekInputTag         WAPasswordInputTag         WANumberInputTag         WARangeInputTag         WATimeInputTag                With the Zurb framework, I include                ZurbAnchorTag         ZurbArticleTag         ZurbButtonTag         ZurbCalloutTag         ZurbCellTag         ZurbCloseButtonTag         ZurbDivTag         ZurbFieldSetTag         ZurbFlexGridTag         ZurbFloatGridTag         ZurbFooterTag         ZurbGenericButtonTag         ZurbListItemTag         ZurbMenuTag         ZurbNavTag         ZurbResetButtonTag         ZurbSpanTag         ZurbSubmitButtonTag         ZurbTableTag         ZurbTabsTag <a id="org85027ef"></a>Builder-------    This is a convenience class which provides a result of a rendering operation as a string. It is expected to be used like this:            WAHtmlCanvas builder render: [ :html |    	html anchor    		url: 'htttp://www.seaside.st';    		with: 'Seaside Homepage' ]        See WABuilderCanvasTest for more examples.<a id="orgc593f11"></a>Cache-----1.  WACache        WAObject subclass: #WACache                        WACacheis the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCache.                >>keySize returns 16                All other instance methods implement self subclassResponsibility2.  WABidirectionalCache        WACache subclass: #WABidirectionalCache                I support key -> value and value -> key mappings and never forget anything.                I also implement serveral methods of Dictionary.3.  WAPredictableCache        WABidirectionalCache subclass: #WAPredictableCache                A WAPredictableCache is a WACache that uses incrementing numbers as cache keys. This way the keys are predictable.         This is useful for tests.4.  WAExpiringCache        WACache subclass: #WAExpiringCache                I am the abstract base class for caches that remove entries. Subclasses are intended to use to track sessions.                    Instance Variables        	maximumSize			<Integer>        	maximumRelativeAge		<Integer>        	maximumAbsoluteAge	<Integer>        	overflowAction			<Symbol>        				        maximumSize:        	Number of sessions supported. When this limit is reached the overflow action is run. 0 for no maximum size. Has to be positive.                maximumRelativeAge:        	After so many seconds of inactivity a session is considered expired. 0 for no limit. Has to be positive.                maximumAbsoluteAge:        	After so many seconds after its creation a session is considered expired no matter when it was last accessed. 0 for no limit. Has to be positive.                overflowAction:        	What to do when the maximum number of sessions is reached. Only matters when the maximum size is bigger than 0.        	Possible values:        		#removeRelativeOldest remove the entry that hasn't been accessed for the longest time        		#removeAbsoluteOldest remove the entry that has been created the longest time ago        		#signalError signal WAMaximumNumberOfSessionsExceededError5.  WABulkReapingCache        WAExpiringCache subclass: #WABulkReapingCache                I am a cache that reaps all elements at once instead of incrementally.                I am intended to be used in GemStone/S instead of WAHashCache. A background process should send #reap to me.                    Instance Variables        	dictionary:		<Dictionary>6.  WAHashCache        WAExpiringCache subclass: #WAHashCache                WAHashCache is a hash table based implementation of WACache.                The characteristics of WAHashCache are:        - supports both absolute and relative timeouts at the same time https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration        - supports a maximum size with definable overflow action (expire oldest, expire least recently used, signal exception)        - access by key is fast (O(1) average case O(n) worst case)        - reaping expired sessions is proportional (O(n)) to the number of expired session and independent of the total number of sessions (O(1))        - creating a new session independent of the total number of sessions        - does not guard against hash collision attacks, you should not use user generated keys                Instance Variables:        	keyTable 				<Array<WACacheKeyEntry>>        	size					<Integer>        	byAccessStart			<WACacheListEntry>        	byAccessEnd			<WACacheListEntry>        	byCreationStart		<WACacheListEntry>        	byCreationEnd			<WACacheListEntry>                keyTable:        	Open hash table of  WACacheKeyEntry                byAccessStart        	Head of the linked list sorted by access time                byAccessEnd	        	Tail of the linked list sorted by access time                byCreationStart        	Head of the linked list sorted by creation time                byCreationEnd        	Tail of the linked list sorted by creation time                        The implementation is a combination of:        - an open hash table, used for look ups by key         - a linked list of cache entries sorted by creation time, used for reaping by absolute age        - a linked list of cache entries sorted by access time, used for reaping by relative age                For every cache entry there is a node in the hash table and a node in both of the linked lists. It is possible to navigate from every node for a key to every other node of the same key. This is required for removing and updating entries.7.  WAMutualExclusionCache        WACache subclass: #WAMutualExclusionCache                WAMutualExclusionCacheNG is a wrapper around a WACacheNG that wraps all messages in a mutex.                Instance Variables:        	mutex	<WAMutex>        	cache	<WACache>8.  WAUnidirectionalCache        WACache subclass: #WAUnidirectionalCache                I support only key -> value mappings and never forget anything.<a id="org7c10414"></a>Codec-----1.  GRCodec                        A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding)         and back outside the image (encoding).                 The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.2.  GRNullCodec        GRObject subclass: #GRCodec                The null codec always returns the original streams.         It assumes that the outside world uses the same encoding as the inside world.         This is highly efficient as no transformation is applied to the data, but has its drawbacks.3.  GRPharoLating1Codec        GRNullCodec subclass: #GRPharoLatin1Codec                        A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).4.  GRPharoGenericCodec        GRCodec subclass: #GRPharoGenericCodec                :nocomment:5.  GRPharoUtf8Codec        GRCodec subclass: #GRPharoUtf8Codec                A WAUtf8Codec is a WACodec optimized for UTF-8.<a id="org289004e"></a>Context-------1.  WAContextTest2.  WARequestContext        WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)        WARequestContext encapsulates all the knowledge that should be available while processing a single request.         It does not matter if this is a request to a static file,         an AJAX request,         a long Comet request         or a normal Seaside requestion.                The request context is valid only during the request that caused it.         It should not be stored.         Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.         In both cases this might lead to memory leaks.<a id="orgedcc70b"></a>Document--------<a id="org99872db"></a>Key Generator-------------1.  WAKeyGenerator        WAObject subclass: #WAKeyGenerator                :nocomment:2.  WAPrecomputedKeyGenerator        WAKeyGenerator subclass: #WAPrecomputedKeyGenerator                :nocomment:<a id="org8c153f8"></a>Painter-------        Painters are Visitors1.  WAPainterVisitor        WAVisitor subclass: #WAPainterVisitor                        An implementation of the Visitor pattern for Painter subclasses.2.  WAHaloVisitor        WAPainterVisitor subclass: #WAHaloVisitor3.  WAInitialRequestVisitor                WAPainterVisitor subclass: #WAInitialRequestVisitor4.  WAPluggablePresenterVisitor        WAPainterVisitor subclass: #WAPluggablePresenterVisitor        NO CLASS COMMENT5.  WAPresenterGuide        WAPainterVisitor subclass: #WAPresenterGuide                WAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations.         Along the way, they will ask their client to visit each Painter they come across.        This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.6.  WARenderingGuide        WAPresenterGuide subclass: #WARenderingGuide                Currently an empty class but still present for clarity and to allow customization of Rendering behaviour.7.  WAVisiblePresenterGuide        WAPresenterGuide subclass: #WAVisiblePresenterGuide                Visit the tree of all Presenters and their registered #children.         Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.8.  WAAllPresenterGuide        WAVisiblePresenterGuide subclass: #WAAllPresenterGuide                Visit the tree of all Presenters and their registered #children.9.  WARenderVisitor                WAPainterVisitor subclass: #WARenderVisitor                A visitor that renders Painters.         It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.10. WATaskVisitor        WAPainterVisitor subclass: #WATaskVisitor11. WAUpdateRootVisitor        WAPainterVisitor subclass: #WAUpdateRootVisitor                A visitor which asks Painters to update a WARoot subclass using #updateRoot:.                This is used to update the root of the Document stored on a WARenderContext.12. WAUpdateStatesVisitor        WAPainterVisitor subclass: #WAUpdateStatesVisitor                        A visitor which asks Painters to update a WARoot subclass using #updateRoot:.                This is used to update the root of the Document stored on a WARenderContext.13. WAUpdateUrlVisitor        WAPainterVisitor subclass: #WAUpdateUrlVisitor                A visitor which asks Painters to update a WAUrl subclass using #updateRoot:.                This is used to update the base URL stored on a WARenderContext.<a id="org6663e4c"></a>Registry--------    see WARegistry under WARequestHandler<a id="org9f019b2"></a>Renderer--------    A Renderer provides methods for rendering data (typically HTML) onto a Document.         It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.        Renderer are typically controlled by a Painter.1.  WARenderer        WAObject subclass: #WARenderer                A Renderer provides methods for rendering data (typically HTML) onto a Document.                 It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.                Renderer are typically controlled by a Painter (Painters are Visitors).            WAObject subclass: #WARenderer                A Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.                Renderer are typically controlled by a Painter.                        javascript-core and jquery-core have methods in me.                I provide the nextid and lastid and render method (verify this)2.  WACanvas                WARenderer subclass: #WACanvas                        This is the superclass of all canvas. It's a rendering interface that generates brushes (see WABrush).                Subclass WAXmlCanvas, if you want to generate an XML dialect.3.  WAJsonCanvas                WACanvas subclass: #WAJsonCanvas                I am a  specific canvas to render JSON output.4.  WATagCanvas        WACanvas subclass: #WATagCanvas                I am the abstract superclass for tag based canvases.5.  WAHtmlCanvas                WATagCanvas subclass: #WAHtmlCanvas                I'm a canvas for building HTML.6.  WAXmlCanvas        I'm an abstract canvas base class for building canvas for custom XML dialects.                        WATagCanvas subclass: #WAXmlCanvas<a id="org73c8ed7"></a>Render Context--------------1.  WARenderContext        WAObject subclass: #WARenderContext                A WARenderContext provides all the state needed by a Renderer to do its work.                It is a decoupling device between whatever is initiating rendering and the Renderer itself.<a id="org08075df"></a>Request-------1.  WARequest                WAObject subclass: #WARequest  has no children                I am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.                Instance Variables        	method:			<String>        	uri:					<WAUrl>        	version:				<WAHttpVersion>        	remoteAddress:	<String>        	headers:			<Dictionary<String, String>>        	cookies:			<Collection<WARequestCookie>>        	body:				<String>        	postFields:			<WARequestFields>        	sslSessionId:		<String>        			        method        	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		                uri        	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.        	        version        	- The version of this request.        	        remoteAddress        	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.                headers        	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.        	        cookies        	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.        	        body        	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.        	        postFields        	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.        	        sslSessionId        	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.<a id="orgb179910"></a>Request Handler and  Continuation---------------------------------1.  WARequestHandler                WAObject subclass: #WARequestHandler                WARequestHandler is an abstract class whose subclasses handle http requests.         Most of the methods are either empty or return a default value.                 Subclasses must implement the following messages:        	handleFiltered:	process the request                Below are the Handlers/registries.2.  WADispatcher        WARequestHandler subclass: #WADispatcher                explore: WADispatcher default        This is the entry point for Seaside.                see WAApplication , which is stored in the WADisplatcher.                        WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc).                 WADispatcher class>>default is the top level dispatcher.                 When a Seaside application is registered as "foo" the application is added to the top level dispatcher.         The application is added to the entryPoints of the dispatcher at the key "foo".         If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo".         That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".                   When a http request is received it is sent to WADispatcher class>>default to find the correct handler for the request.         If a handler exists for the request is sent to that handler.         Otherwise the request is sent to the not found response generator.                The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class>>default.         One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming).                 Instance Variables:        	defaultName	<String>        	entryPoints	<(Dictionary of: WAEntryPoint)>	 the keys are strings, which are the names and URL path segments for the handler at that key3.  WADocumentHandler        WARequestHandler subclass: #WADocumentHandler                        WADocumentHandler handles requests for images,         text documents and         binary files (byte arrays).         This class is not normally used directly.         A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler.         Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document,         registers the handler with a Registry,         and adds the correct url in the tag for the document.                Instance Variables:        	document	<WAMimeDocument>	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.4.  WAFileHandler        WARequestHandler subclass: #WAFileHandler                        Seaside serves static files using WAFileLibrary subclasses.         WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server.         WAFileHandler is registered with the default WADispatcher automatically.5.  WALegacyRedirectionHandler        WARequestHandler subclass: #WALegacyRedirectionHandler                I provide compatibility with old Seaside URLs that have Seaside in the path (eg. '/seaside/examples/counter') by simply removing it.6.  WANextUnconsumedPathElementRequestHandler        WARequestHandler subclass: #WANextUnconsumedPathElementRequestHandler                        :nocomment:7.  WARegistry        WARequestHandler subclass: #WARegistry                WARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd.         WARegistry checks incoming request URLs for a key and looks for a matching active request handler.         If one exists, the request is sent to the proper handler.         If not, the request is either a new request (in which case #handleDefaultRequest: is called)         or a request to a now-inactive handler (in which case #handleExpiredRequest: is called).                 These two methods allow subclasses to properly handle these requests.                Subclasses must implement the following messages:        	handleDefaultRequest:        		Handle a request without a session key, ie a new request.        	handlerField        		The URL parameter in which to store the request handler key.                Instance Variables:        	cache - an instance of WACache to hold the stored request handlers8.  WAApplication                 WARegistry subclass: #WAApplication                        WAApplication is the starting point for a Seaside application.                 When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher.   (explore: WADispatcher default)                The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application.                 "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)        If you change the cache configuration  you need to send #initializeCache for the changes to take effect.                "libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.                Registering an Application.        	An application can be registered with a dispatcher by using the Seaside configuration page or via code.         Below MyComponent is a subclass of WAComponent.         The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration.                 MyComponent class>>initialize        	"self initialize"        	| application |        	application := self registerAsApplication: 'sample'.        	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.        	application addLibrary: SampleLibrary.        	application configuration addAncestor: GlorpConfiguration new.        	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.        	application preferenceAt: #databaseServer put: '127.0.0.1'.        	application preferenceAt: #databaseConnectString put: 'glorptests'.                MyComponent>>someInstanceMethod        	"example of how to access attributes (preferences)"        	self session application preferenceAt: #glorpDatabasePlatform9.  WARedirectingApplication        WAApplication subclass: #WARedirectingApplication                I revert to the old < 3.3.0 behavior which is easier for tests.10. WARedirectingRegistry        WARegistry subclass: #WARedirectingRegistry                I revert to the old < 3.3.0 behavior which is easier for tests.11. WARestfulHandler        WARequestHandler subclass: #WARestfulHandler                :nocomment:12. WACORSResourceExample        WARestfulHandler subclass: #WACORSResourceExample                :nocomment:13. WASession                WARequestHandler subclass: #WASession                I am a Seaside session.         A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.                This class is intended to be subclasses by applications that need global state, like a user.                 Custom state can be added by creating instance variables and storing it there.                 The session can be retrieved by #session if inside a component or task or by evaluating: WACurrentRequestContext session                If the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system.                 To manually expire a session call #expire.                A good way to clear all sessions is the following code:                WARegistry clearAllHandlers.        WAPlatform current garbageCollect14. WAExpirySession        WASession subclass: #WAExpirySession                :nocomment:15. WASessionCookieProtectedSession        WASession subclass: #WASessionCookieProtectedSession                        I am a session with a WASessionCookieProtectionFilter.                provide a link here16. WATestSession        WASession subclass: #WATestSession                :nocomment:17. WASessionContinuation                WARequestHandler subclass: #WASessionContinuation                        I represent a continuation as part of the flow of pages within a session.                 I am not a real continuation (as compared to those used in #call: and #answer:),                 I only represent a specific point in the session.                 I reference the root component and a memory snapshot of backtracked objects.18. WANullSessionContinuation        WASessionContinuation subclass: #WANullSessionContinuation                :nocomment:19. WARenderLoopContinuation        WASessionContinuation subclass: #WARenderLoopContinuation                        :nocomment:20. WAActionPhaseContinuation        WARenderLoopContinuation subclass: #WAActionPhaseContinuation                :nocomment:21. WACallbackProcessingActionContinuation                WAActionPhaseContinuation subclass: #WACallbackProcessingActionContinuation                        :nocomment:22. WAInitialRenderLoopContinuation                WAActionPhaseContinuation subclass: #WAInitialRenderLoopContinuation                I'm the initial continuation of a render loop.         I just render the initial page.         Subclasses may want to override #shouldRedirect and answer true so that a redirect happens before displaying the first page.23. WAPluggableActionContinuation        WAActionPhaseContinuation subclass: #WAPluggableActionContinuation                        This continuation executes an action (any class that implements #value or #value:).                 If possible, the renderContext is passed in as an argument.                 When the action is complete, if a response hasn't been returned, control is passed to a render continuation.'                Instance Variables:        	action	<BlockClosure | BlockContext | GRDelayedSend | MessageSend | WAContinuation | WAPartialContinuation>                :important:24. WARenderPhaseContinuation        WARenderLoopContinuation subclass: #WARenderPhaseContinuation                :nocomment:25. WAFlushingRenderPhaseContinuation        WARenderPhaseContinuation subclass: #WAFlushingRenderPhaseContinuation                :nocomment:26. WATestNoopRequestHandler        WARequestHandler subclass: #WATestNoopRequestHandler                :nocomment:27. WATestNoopSessionHandler        WARequestHandler subclass: #WATestNoopSessionHandler                :nocomment:<a id="org8ffca1e"></a>Response--------1.  WAResponse                                WAObject subclass: #WAResponse . I have children                                A WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.        See class side initialize protocol for all the responses from the server.2.  WABufferedResponse                                WAObject subclass: #WAResponse subclass: WABufferedResponse                        A WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.                Instance Variables        	contentsStream:		<WriteStream> The contents of this message.                        Basically a wrapper on a stream that obtains its headers from the parent.3.  WAComboResponse                                WAObject subclass: #WAResponse subclass: WAComboResponse                WAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:                renderContentOn: aCanvas        	"Render the search page"                	self renderSearchLabelOn: aCanvas.        	self requestContext request flush. "flush before starting search to give immediate feedback"                	self searchResultsDo: [ :result |        		self renderSearchResult: result on: aCanvas.        		self requestContext request flush "flush after each search result" ]                After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.                Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.                on the TODO, I will investigate this more, later4.  WAStreamedResponse        WAObject subclass: #WAResponse subclass: WAStreamedResponse                A WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.                Instance Variables        	committed:		<Boolean>	Whether the status and header was written to the stream.        	externalStream:		<WriteStream>	The external stream to write to.<a id="orgc769629"></a>Server------1.  WAServerAdaptor        A WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol:         - #codec         - #usesSmalltalkEncoding                Instance Variables        	codec:		<WACodec>                codec        	- the codec used for response conversion from characters to bytes2.  WATestServerAdapator        WAServerAdaptor subclass: #WATestServerAdaptor        A WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager3.  WAWebServerAdaptor        WAServerAdaptor subclass: #WAWebServerAdaptor                                What does this thing do?        It holds         a reference to its WAServerManager        a port        a requestHandler        a codec        a server of class WebServer from WebClient-Core in squeak        a certName4.  WAServerManager        A server manager cares on the available Seaside server adopters5.  WebServer        Not a part of Seaside in Squeak, but part of WebClient-Core        I wonder if other WebClient-Core classes are used within the WA framework...                        WebClient provides a simple yet complete HTTP server implementation.                To view the documentation evaluate:                	HelpBrowser openOn: WebServerHelp.                        Does Pharo use a different class?<a id="orgb981424"></a>Visitor-------1.  WAVisitor        WAObject subclass: #WAVisitor                Common superclass for all visitors (visitor pattern)2.  WAAttributeVisitor        WAVisitor subclass: #WAAttributeVisitor                A visitor of attributes3.  WAUserConfigurationEditorVisitor        WAAttributeVisitor subclass: #WAUserConfigurationEditorVisitor<a id="orgd8d450a"></a>HOWTO-----    an assortment of howtos follows1.  Clear Sessions        To manually expire a session call #expire.                A good way to clear all sessions is the following code:                WARegistry clearAllHandlers.        WAPlatform current garbageCollect<a id="org43bdc16"></a>Followup--------    Update Doc to handle TAGS and ignore #Startup etc.    Squeak uses WebServer, does Pharo use Kom thing?    Get examples/strategies/use-cases of WAExpiringCache    see if we can hack Seaside using examples from:         https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration        Write a mockups of     WAComboResponse    WAStreamedResponse        get a sense of the things WAVisitor children do.<a id="org8329323"></a>Bibliography------------    https://github.com/seasidest        https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration<a id="orged6ef7b"></a>Todo below here---------------1.  Builder2.  Error3.  WAError                GRError subclass: #WAError                Common superclass for Seaside errors4.  WAAuthConfigurationError        WAError subclass: #WAAuthConfigurationError                A WAAuthConfigurationError is signaled when no WAAuthConfiguration was added to an application that is behind a WAAuthenticationFilter.5.  GRPlatform6.  GRPharoPlatform        GRPlatform subclass: #GRPharoPlatform                A GRPharoPlatform is the Pharo implementation of GRPlatform, the Grease class that provides functionality that can not be implemented in a platform independent way.7.  GRSqueakPlatform        GRPharoPlatform subclass: #GRSqueakPlatform8.  Transient Value Holder9.  WAValueHolder        WAObject subclass: #WAValueHolder                I wrap a single object.         I am like value holder except that I am portable and don't include the Model cruft in Squeak.10. WADynamic Variable11. WAKeyGenerator12. WAMutex13. WACookie                                I represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.        You can never trust information in a cookie, the client is free to edit it.        I model only a part of the full cookie specification.                Browser support:        http://www.mnot.net/blog/2006/10/27/cookie_fun                Netscape spec        http://cgi.netscape.com/newsref/std/cookie_spec.html                Cookie spec        http://tools.ietf.org/html/rfc2109                Cookie 2 spec        https://tools.ietf.org/html/rfc6265                HttpOnly        http://msdn2.microsoft.com/en-us/library/ms533046.aspx        https://bugzilla.mozilla.org/show_bug.cgi?id=178993                Compared to WARequestCookie I represent the information that is sent to the user agent.14. WARequestCookie        A WARequestCookie is the cookie the user agent sent to the server.                Instance Variables        	domain:			<String>        	key:			<String>        	path:			<String>        	pathEncoded:	<String>        	ports:			<Collection<Integer>>        	value:			<String>        	version:			<Integer>                domain        	- xxxxx                key        	- xxxxx                path        	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:          1.  Let uri-path be the path portion of the request-uri if such a               portion exists (and empty otherwise).  For example, if the               request-uri contains just a path (and optional query string),               then the uri-path is that path (without the %x3F ("?") character               or query string), and if the request-uri contains a full               absoluteURI, the uri-path is the path component of that URI.                   2.  If the uri-path is empty or if the first character of the uri-               path is not a %x2F ("/") character, output %x2F ("/") and skip               the remaining steps.                   3.  If the uri-path contains no more than one %x2F ("/") character,               output %x2F ("/") and skip the remaining step.                   4.  Output the characters of the uri-path from the first character up               to, but not including, the right-most %x2F ("/").                ports        	- xxxxx                value        	- xxxxx                version        	- the version of the cookie specification supported, currently only 1 is known15. WAMergedRequestFields                Provides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.