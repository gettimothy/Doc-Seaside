# Table of Contents1.  [Seaside](#org6e34eea)    1.  [Introduction](#org13877bc)    2.  [JSCore](#org26c7221)        1.  [JSJoin](#org456814c)        2.  [JSJson](#orgfae3608)        3.  [JSLogger](#org0b765ed)        4.  [JSScript](#org5229446)        5.  [JSFunction](#org93a9ec9)    3.  [JSDecoration](#orgb0b37b3)    4.  [JQuery](#orgb715d36)    5.  [JQ](#orgb1b6fe4)    6.  [JQAjax](#org9a8f530)    7.  [JQWidget](#orgfb8f2d1)    8.  [Brush](#org3eb8260)        1.  [WACompund](#org1666363)        2.  [WAJsonBrush](#org60faf73)        3.  [WAJsonArrayBrush](#org36b5860)        4.  [WAJsonElementBrush](#org3a2c54d)        5.  [WAJsonKeyValueBrush](#org0839e86)        6.  [WAJsonValueBrush](#org9983cfa)        7.  [WAJsonObjectBrush](#org99dffa2)        8.  [WATagBrush](#org8caec6c)    9.  [Builder](#org6ea9202)    10. [Cache](#org16f33d5)        1.  [WACache](#org9e55a78)        2.  [WABidirectionalCache](#org8f4c7c2)        3.  [WAPredictableCache](#org8a705b8)        4.  [WAExpiringCache](#org59b0f89)        5.  [WABulkReapingCache](#orged98812)        6.  [WAHashCache](#org8496825)        7.  [WAMutualExclusionCache](#orgc8a825c)        8.  [WAUnidirectionalCache](#orgaa96896)    11. [Codec](#orgf270f7a)        1.  [GRCodec](#org913255a)        2.  [GRNullCodec](#org73b2648)        3.  [GRPharoLating1Codec](#org79632d6)        4.  [GRPharoGenericCodec](#org670f01f)        5.  [GRPharoUtf8Codec](#org9221d5e)    12. [Context](#org799a8a8)        1.  [WAContextTest](#org49ac764)        2.  [WARequestContext](#orgffc23b8)    13. [Document](#org983b378)        1.  [WADocument](#orgb268845)        2.  [WAJsonDocument](#org1028b69)        3.  [WAXmlDocument](#orgaa924d9)        4.  [WAHtmlDocument](#org373d901)        5.  [WAPrettyPrintedDocument](#org98a60a1)        6.  [WAUnescapedDocument](#org60ecba5)    14. [Key Generator](#orgb375a6f)        1.  [WAKeyGenerator](#orgbc6c98e)        2.  [WAPrecomputedKeyGenerator](#orgb9953e3)    15. [Painter](#org717a57f)        1.  [WAPainterVisitor](#org2af4630)        2.  [WAHaloVisitor](#org8fcb14d)        3.  [WAInitialRequestVisitor](#orgf77875a)        4.  [WAPluggablePresenterVisitor](#orgcc68f3d)        5.  [WAPresenterGuide](#org92a8650)        6.  [WARenderingGuide](#org6d7c5c3)        7.  [WAVisiblePresenterGuide](#org807d1e4)        8.  [WAAllPresenterGuide](#orge182ae4)        9.  [WARenderVisitor](#org4716f32)        10. [WATaskVisitor](#org9d01fa4)        11. [WAUpdateRootVisitor](#orgb03e41d)        12. [WAUpdateStatesVisitor](#orga069522)        13. [WAUpdateUrlVisitor](#orga4d9dd4)    16. [Registry](#orga1c74b6)    17. [Renderer](#org96de21b)        1.  [WARenderer](#org32a4a10)        2.  [WACanvas](#org8730cfd)        3.  [WAJsonCanvas](#orgeb1f202)        4.  [WATagCanvas](#org6ef1989)        5.  [WAHtmlCanvas](#org114f5ed)        6.  [WAXmlCanvas](#org08d7865)    18. [Render Context](#orge0ed911)        1.  [WARenderContext](#org7a13185)    19. [Request](#orgfdb2d02)        1.  [WARequest](#org8af96d0)    20. [Request Handler and  Continuation](#org4e6009c)        1.  [WARequestHandler](#orgba0191f)        2.  [WADispatcher](#orgee205f2)        3.  [WADocumentHandler](#org004fd7d)        4.  [WAFileHandler](#org262b405)        5.  [WALegacyRedirectionHandler](#org4d0958d)        6.  [WANextUnconsumedPathElementRequestHandler](#org6fa98b3)        7.  [WARegistry](#org4a67929)        8.  [WAApplication](#org63d6bb9)        9.  [WARedirectingApplication](#org377fea8)        10. [WARedirectingRegistry](#org0af584b)        11. [WARestfulHandler](#orgb88453f)        12. [WACORSResourceExample](#orga0a345f)        13. [WASession](#org96e6d00)        14. [WAExpirySession](#org0e64f62)        15. [WASessionCookieProtectedSession](#orgd717788)        16. [WATestSession](#orgdf2bc7b)        17. [WASessionContinuation](#org0a9bec4)        18. [WANullSessionContinuation](#orgf370d31)        19. [WARenderLoopContinuation](#org12dcafe)        20. [WAActionPhaseContinuation](#orged63806)        21. [WACallbackProcessingActionContinuation](#org707ab6d)        22. [WAInitialRenderLoopContinuation](#org1f860d6)        23. [WAPluggableActionContinuation](#org448ff20)        24. [WARenderPhaseContinuation](#org029b157)        25. [WAFlushingRenderPhaseContinuation](#org31e6857)        26. [WATestNoopRequestHandler](#org72a7a16)        27. [WATestNoopSessionHandler](#org81020da)    21. [Response](#org3820cc4)        1.  [WAResponse](#orgfe5f7ba)        2.  [WABufferedResponse](#org64bd9e9)        3.  [WAComboResponse](#org0a791d7)        4.  [WAStreamedResponse](#org4ad3dd5)    22. [Root](#org9314086)        1.  [WARoot](#org1fc991e)        2.  [WAHtmlRoot](#org5d18534)        3.  [WAXmlRoot](#orgcfb0f87)    23. [Server](#orgba8fd3f)        1.  [WAServerAdaptor](#orgdd0af9b)        2.  [WATestServerAdapator](#org63422f8)        3.  [WAWebServerAdaptor](#org1333ded)        4.  [WAServerManager](#orge2c907e)        5.  [WebServer](#org2d15673)    24. [Visitor](#orgf7ebd03)        1.  [WAVisitor](#org1d6ba0b)        2.  [WAAttributeVisitor](#orgbabbc3f)        3.  [WAUserConfigurationEditorVisitor](#org901457b)    25. [HOWTO](#org8e63581)        1.  [Clear Sessions](#org9050bcc)    26. [Followup](#orgf32692d)    27. [Bibliography](#org27a50b6)    28. [Todo below here](#org0cc8dd2)        1.  [Builder](#orgb038154)        2.  [Error](#org23c01dd)        3.  [WAError](#org54c2fcf)        4.  [WAAuthConfigurationError](#org67a07b9)        5.  [GRPlatform](#org14a267b)        6.  [GRPharoPlatform](#orgec8d62a)        7.  [GRSqueakPlatform](#orgfe5079d)        8.  [Transient Value Holder](#orga0fcf25)        9.  [WAValueHolder](#org7b6d962)        10. [WADynamic Variable](#orgbf3be29)        11. [WAKeyGenerator](#org9efa76f)        12. [WAMutex](#orgd1205ad)        13. [WACookie](#orgf7ac1da)        14. [WARequestCookie](#orgf592f01)        15. [WAMergedRequestFields](#org01eb69a)<a id="org6e34eea"></a># Seaside<a id="org13877bc"></a>## Introduction    Working Notes of an "in depth" study of the Seaside guts and patterns.<a id="org26c7221"></a>## JSCore<a id="org456814c"></a>### JSJoin<a id="orgfae3608"></a>### JSJson<a id="org0b765ed"></a>### JSLogger<a id="org5229446"></a>### JSScript        JSObject subclass: #JSScript        I represent a sequence of JavaScript statements.<a id="org93a9ec9"></a>### JSFunction<a id="orgb0b37b3"></a>## JSDecoration<a id="orgb715d36"></a>## JQuery<a id="orgb1b6fe4"></a>## JQ<a id="org9a8f530"></a>## JQAjax<a id="orgfb8f2d1"></a>## JQWidget<a id="org3eb8260"></a>## Brush    WAObject subclass: #WABrush    I represent a brush to be used on a *WACanvas*.        Instance Variables    	canvas:		The canvas instance I am used with.    	parent:		The parent brush I am used within.    	closed:		Wether I have been closed/flushed yet.        I have three immediate subclasses:    WACompound    WAJsonBrush    WATagBrush<a id="org1666363"></a>### WACompund    WABrush subclass: #WACompound        I am the superclass for stuff that is not html element but you still want to access via the canvas API.        I have two subclasses and do not appear to be very popular.<a id="org60faf73"></a>### WAJsonBrush    WABrush subclass: #WAJsonBrush        A brush to generate JSON<a id="org36b5860"></a>### WAJsonArrayBrush        WAJsonBrush subclass: #WAJsonArrayBrush            Brush for a JSON array<a id="org3a2c54d"></a>### WAJsonElementBrush    WAJsonBrush subclass: #WAJsonElementBrush            Abstract superclass for JSON elements<a id="org0839e86"></a>### WAJsonKeyValueBrush        WAJsonElementBrush subclass: #WAJsonKeyValueBrush            A JSON key value<a id="org9983cfa"></a>### WAJsonValueBrush        WAJsonElementBrush subclass: #WAJsonValueBrush        A JSON value<a id="org99dffa2"></a>### WAJsonObjectBrush    WAJsonBrush subclass: #WAJsonObjectBrush                A brush to generate a JSON object<a id="org8caec6c"></a>### WATagBrush    WABrush subclass: #WATagBrush            This is the superclass for all XML element classes. Its main additions are    - element name (#tag)    - attributes (instance of WAHtmlAttributes)    - common events (onXXX), this is a hack and would better be solved with traits            My subclasses are:        WAAnchorTag     WABasicFormTag     WABreakTag     WACanvasTag     WACollectionTag     WACommandTag     WADetailsTag     WAEmbedTag     WAEventSourceTag     WAFieldSetTag     WAFormInputTag     WAGenericTag     WAHeadingTag     WAHorizontalRuleTag     WAIframeTag     WAImageTag     WAKeyGeneratorTag     WALabelTag     WAMediaElementTag     WAMenuTag     WAMeterTag     WAObjectTag     WAOptionGroupTag     WAOptionTag     WAOptionalBreakTag     WAOutputTag     WAParameterTag     WAProgressTag     WARubyTextTag     WAScriptTag     WASourceTag     WATableCellTag     WATableTag     WATimeTag     WATrackTag     WAImageMapTag     WAPopupAnchorTag     WAFormTag     WADatalistTag     WAListTag     WASelectTag     WAAbstractTextAreaTag     WAButtonTag     WACheckboxTag     WAFileUploadTag     WAHiddenInputTag     WARadioButtonTag     WASubmitButtonTag     WAEditTag ZurbIFrameTag     WAAudioTag     WAVideoTag     WATableColumnGroupTag     WATableDataTag     WAOrderedListTag     WAUnorderedListTag     WAMultiSelectTag     WAColorInputTag     WAEmailInputTag     WASearchInputTag     WASteppedTag     WATelephoneInputTag     WATextAreaTag     WATextInputTag     WAUrlInputTag     WACancelButtonTag     WAImageButtonTag     WATableColumnTag     WATableHeadingTag     WAClosedRangeTag     WADateInputTag     WADateTimeInputTag     WADateTimeLocalInputTag     WAMonthInputTag     WAWeekInputTag     WAPasswordInputTag     WANumberInputTag     WARangeInputTag     WATimeInputTag        With the Zurb framework, I include        ZurbAnchorTag     ZurbArticleTag     ZurbButtonTag     ZurbCalloutTag     ZurbCellTag     ZurbCloseButtonTag     ZurbDivTag     ZurbFieldSetTag     ZurbFlexGridTag     ZurbFloatGridTag     ZurbFooterTag     ZurbGenericButtonTag     ZurbListItemTag     ZurbMenuTag     ZurbNavTag     ZurbResetButtonTag     ZurbSpanTag     ZurbSubmitButtonTag     ZurbTableTag     ZurbTabsTag <a id="org6ea9202"></a>## Builder    This is a convenience class which provides a result of a rendering operation as a string. It is expected to be used like this:            WAHtmlCanvas builder render: [ :html |    	html anchor    		url: 'htttp://www.seaside.st';    		with: 'Seaside Homepage' ]        See WABuilderCanvasTest for more examples.<a id="org16f33d5"></a>## Cache<a id="org9e55a78"></a>### WACache    WAObject subclass: #WACache            WACacheis the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCache.        >>keySize returns 16        All other instance methods implement self subclassResponsibility<a id="org8f4c7c2"></a>### WABidirectionalCache    WACache subclass: #WABidirectionalCache        I support key -> value and value -> key mappings and never forget anything.        I also implement serveral methods of Dictionary.<a id="org8a705b8"></a>### WAPredictableCache    WABidirectionalCache subclass: #WAPredictableCache        A WAPredictableCache is a WACache that uses incrementing numbers as cache keys. This way the keys are predictable.     This is useful for tests.<a id="org59b0f89"></a>### WAExpiringCache    WACache subclass: #WAExpiringCache        I am the abstract base class for caches that remove entries. Subclasses are intended to use to track sessions.            Instance Variables    	maximumSize			<Integer>    	maximumRelativeAge		<Integer>    	maximumAbsoluteAge	<Integer>    	overflowAction			<Symbol>    				    maximumSize:    	Number of sessions supported. When this limit is reached the overflow action is run. 0 for no maximum size. Has to be positive.        maximumRelativeAge:    	After so many seconds of inactivity a session is considered expired. 0 for no limit. Has to be positive.        maximumAbsoluteAge:    	After so many seconds after its creation a session is considered expired no matter when it was last accessed. 0 for no limit. Has to be positive.        overflowAction:    	What to do when the maximum number of sessions is reached. Only matters when the maximum size is bigger than 0.    	Possible values:    		#removeRelativeOldest remove the entry that hasn't been accessed for the longest time    		#removeAbsoluteOldest remove the entry that has been created the longest time ago    		#signalError signal WAMaximumNumberOfSessionsExceededError<a id="orged98812"></a>### WABulkReapingCache    WAExpiringCache subclass: #WABulkReapingCache        I am a cache that reaps all elements at once instead of incrementally.        I am intended to be used in GemStone/S instead of WAHashCache. A background process should send #reap to me.            Instance Variables    	dictionary:		<Dictionary><a id="org8496825"></a>### WAHashCache    WAExpiringCache subclass: #WAHashCache        WAHashCache is a hash table based implementation of WACache.        The characteristics of WAHashCache are:    - supports both absolute and relative timeouts at the same time https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration    - supports a maximum size with definable overflow action (expire oldest, expire least recently used, signal exception)    - access by key is fast (O(1) average case O(n) worst case)    - reaping expired sessions is proportional (O(n)) to the number of expired session and independent of the total number of sessions (O(1))    - creating a new session independent of the total number of sessions    - does not guard against hash collision attacks, you should not use user generated keys        Instance Variables:    	keyTable 				<Array<WACacheKeyEntry>>    	size					<Integer>    	byAccessStart			<WACacheListEntry>    	byAccessEnd			<WACacheListEntry>    	byCreationStart		<WACacheListEntry>    	byCreationEnd			<WACacheListEntry>        keyTable:    	Open hash table of  WACacheKeyEntry        byAccessStart    	Head of the linked list sorted by access time        byAccessEnd	    	Tail of the linked list sorted by access time        byCreationStart    	Head of the linked list sorted by creation time        byCreationEnd    	Tail of the linked list sorted by creation time            The implementation is a combination of:    - an open hash table, used for look ups by key     - a linked list of cache entries sorted by creation time, used for reaping by absolute age    - a linked list of cache entries sorted by access time, used for reaping by relative age        For every cache entry there is a node in the hash table and a node in both of the linked lists. It is possible to navigate from every node for a key to every other node of the same key. This is required for removing and updating entries.<a id="orgc8a825c"></a>### WAMutualExclusionCache    WACache subclass: #WAMutualExclusionCache        WAMutualExclusionCacheNG is a wrapper around a WACacheNG that wraps all messages in a mutex.        Instance Variables:    	mutex	<WAMutex>    	cache	<WACache><a id="orgaa96896"></a>### WAUnidirectionalCache    WACache subclass: #WAUnidirectionalCache        I support only key -> value mappings and never forget anything.<a id="orgf270f7a"></a>## Codec<a id="org913255a"></a>### GRCodec            A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding)     and back outside the image (encoding).         The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.<a id="org73b2648"></a>### GRNullCodec    GRObject subclass: #GRCodec        The null codec always returns the original streams.     It assumes that the outside world uses the same encoding as the inside world.     This is highly efficient as no transformation is applied to the data, but has its drawbacks.<a id="org79632d6"></a>### GRPharoLating1Codec    GRNullCodec subclass: #GRPharoLatin1Codec            A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).<a id="org670f01f"></a>### GRPharoGenericCodec    GRCodec subclass: #GRPharoGenericCodec        :nocomment:<a id="org9221d5e"></a>### GRPharoUtf8Codec    GRCodec subclass: #GRPharoUtf8Codec        A WAUtf8Codec is a WACodec optimized for UTF-8.<a id="org799a8a8"></a>## Context<a id="org49ac764"></a>### WAContextTest<a id="orgffc23b8"></a>### WARequestContext    WARequestContext request: (WARequest new) response:  (WABufferedResponse new)  codec: ( GRNullCodec new)    WARequestContext encapsulates all the knowledge that should be available while processing a single request.     It does not matter if this is a request to a static file,     an AJAX request,     a long Comet request     or a normal Seaside requestion.        The request context is valid only during the request that caused it.     It should not be stored.     Neither within instance variables, nor within the execution stack so that it might be captured by a continuation.     In both cases this might lead to memory leaks.<a id="org983b378"></a>## DocumentA Seaside Document is basically a wrapper on a Stream and a Codec.<a id="orgb268845"></a>### WADocument    WAObject subclass: #WADocument        A WADocument combines an output stream and an instance of root.         The root is responsible to render header and footer if necessary.<a id="org1028b69"></a>### WAJsonDocument        WADocument subclass: #WAJsonDocument            I add the possibility to generate JSON.<a id="orgaa924d9"></a>### WAXmlDocument        WADocument subclass: #WAXmlDocument        A WAXmlDocument is adds the possibility to generate XML tags and knows encoders for XML text and URLs.<a id="org373d901"></a>### WAHtmlDocument        WAXmlDocument subclass: #WAHtmlDocument        A WAHtmlDocument controls how a string is created from a series of brushes.<a id="org98a60a1"></a>### WAPrettyPrintedDocument        WAHtmlDocument subclass: #WAPrettyPrintedDocument                This Document can be used in place of a WAHtmlDocument and will display a pretty version of the HTML source that would have been generated by the WAHtmlDocument.        The technique here is that:     - anything we are asked to output raw (i.e. #nextPut: and #nextPutAll:) we encode with entities     - anything we are asked to entity encode (i.e. via #xmlEncoder) we double-encode, by wrapping the two WAXmlEncoders around each other     - anything we want to output ourselves (i.e. prettiness) we do using a WAHtmlCanvas that we create ourselves<a id="org60ecba5"></a>### WAUnescapedDocument    WAXmlDocument subclass: #WAUnescapedDocument        A WAUnescapedDocument does not do any escaping.<a id="orgb375a6f"></a>## Key Generator<a id="orgbc6c98e"></a>### WAKeyGenerator    WAObject subclass: #WAKeyGenerator        :nocomment:<a id="orgb9953e3"></a>### WAPrecomputedKeyGenerator    WAKeyGenerator subclass: #WAPrecomputedKeyGenerator        :nocomment:<a id="org717a57f"></a>## Painter        Painters are Visitors<a id="org2af4630"></a>### WAPainterVisitor    WAVisitor subclass: #WAPainterVisitor            An implementation of the Visitor pattern for Painter subclasses.<a id="org8fcb14d"></a>### WAHaloVisitor    WAPainterVisitor subclass: #WAHaloVisitor<a id="orgf77875a"></a>### WAInitialRequestVisitor        WAPainterVisitor subclass: #WAInitialRequestVisitor<a id="orgcc68f3d"></a>### WAPluggablePresenterVisitor    WAPainterVisitor subclass: #WAPluggablePresenterVisitor    NO CLASS COMMENT<a id="org92a8650"></a>### WAPresenterGuide    WAPainterVisitor subclass: #WAPresenterGuide        WAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations.     Along the way, they will ask their client to visit each Painter they come across.    This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.<a id="org6d7c5c3"></a>### WARenderingGuide    WAPresenterGuide subclass: #WARenderingGuide        Currently an empty class but still present for clarity and to allow customization of Rendering behaviour.<a id="org807d1e4"></a>### WAVisiblePresenterGuide    WAPresenterGuide subclass: #WAVisiblePresenterGuide        Visit the tree of all Presenters and their registered #children.     Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.<a id="orge182ae4"></a>### WAAllPresenterGuide    WAVisiblePresenterGuide subclass: #WAAllPresenterGuide        Visit the tree of all Presenters and their registered #children.<a id="org4716f32"></a>### WARenderVisitor        WAPainterVisitor subclass: #WARenderVisitor        A visitor that renders Painters.     It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.<a id="org9d01fa4"></a>### WATaskVisitor    WAPainterVisitor subclass: #WATaskVisitor<a id="orgb03e41d"></a>### WAUpdateRootVisitor    WAPainterVisitor subclass: #WAUpdateRootVisitor        A visitor which asks Painters to update a WARoot subclass using #updateRoot:.        This is used to update the root of the Document stored on a WARenderContext.<a id="orga069522"></a>### WAUpdateStatesVisitor    WAPainterVisitor subclass: #WAUpdateStatesVisitor            A visitor which asks Painters to update a WARoot subclass using #updateRoot:.        This is used to update the root of the Document stored on a WARenderContext.<a id="orga4d9dd4"></a>### WAUpdateUrlVisitor    WAPainterVisitor subclass: #WAUpdateUrlVisitor        A visitor which asks Painters to update a WAUrl subclass using #updateRoot:.        This is used to update the base URL stored on a WARenderContext.<a id="orga1c74b6"></a>## Registry    see WARegistry under WARequestHandler<a id="org96de21b"></a>## Renderer    A Renderer provides methods for rendering data (typically HTML) onto a Document.         It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.        Renderer are typically controlled by a Painter.<a id="org32a4a10"></a>### WARenderer    WAObject subclass: #WARenderer        A Renderer provides methods for rendering data (typically HTML) onto a Document.         It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.        Renderer are typically controlled by a Painter (Painters are Visitors).    WAObject subclass: #WARenderer        A Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.        Renderer are typically controlled by a Painter.            javascript-core and jquery-core have methods in me.        I provide the nextid and lastid and render method (verify this)<a id="org8730cfd"></a>### WACanvas        WARenderer subclass: #WACanvas            This is the superclass of all canvas. It's a rendering interface that generates brushes (see WABrush).        Subclass WAXmlCanvas, if you want to generate an XML dialect.<a id="orgeb1f202"></a>### WAJsonCanvas        WACanvas subclass: #WAJsonCanvas        I am a  specific canvas to render JSON output.<a id="org6ef1989"></a>### WATagCanvas    WACanvas subclass: #WATagCanvas        I am the abstract superclass for tag based canvases.<a id="org114f5ed"></a>### WAHtmlCanvas        WATagCanvas subclass: #WAHtmlCanvas        I'm a canvas for building HTML.<a id="org08d7865"></a>### WAXmlCanvas    I'm an abstract canvas base class for building canvas for custom XML dialects.            WATagCanvas subclass: #WAXmlCanvas<a id="orge0ed911"></a>## Render Context<a id="org7a13185"></a>### WARenderContext    WAObject subclass: #WARenderContext        A WARenderContext provides all the state needed by a Renderer to do its work.        It is a decoupling device between whatever is initiating rendering and the Renderer itself.<a id="orgfdb2d02"></a>## Request<a id="org8af96d0"></a>### WARequest        WAObject subclass: #WARequest  has no children        I am a server independent http request object. Instance of me can be aquired through WAObject >> #currentRequest.        Instance Variables    	method:			<String>    	uri:					<WAUrl>    	version:				<WAHttpVersion>    	remoteAddress:	<String>    	headers:			<Dictionary<String, String>>    	cookies:			<Collection<WARequestCookie>>    	body:				<String>    	postFields:			<WARequestFields>    	sslSessionId:		<String>    			    method    	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		        uri    	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.    	    version    	- The version of this request.    	    remoteAddress    	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.        headers    	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.    	    cookies    	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.    	    body    	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.    	    postFields    	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.    	    sslSessionId    	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.<a id="org4e6009c"></a>## Request Handler and  Continuation<a id="orgba0191f"></a>### WARequestHandler        WAObject subclass: #WARequestHandler        WARequestHandler is an abstract class whose subclasses handle http requests.     Most of the methods are either empty or return a default value.         Subclasses must implement the following messages:    	handleFiltered:	process the request        Below are the Handlers/registries.<a id="orgee205f2"></a>### WADispatcher    WARequestHandler subclass: #WADispatcher        explore: WADispatcher default    This is the entry point for Seaside.        see WAApplication , which is stored in the WADisplatcher.            WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc).         WADispatcher class>>default is the top level dispatcher.         When a Seaside application is registered as "foo" the application is added to the top level dispatcher.     The application is added to the entryPoints of the dispatcher at the key "foo".     If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo".     That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".           When a http request is received it is sent to WADispatcher class>>default to find the correct handler for the request.     If a handler exists for the request is sent to that handler.     Otherwise the request is sent to the not found response generator.        The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class>>default.     One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming).         Instance Variables:    	defaultName	<String>    	entryPoints	<(Dictionary of: WAEntryPoint)>	 the keys are strings, which are the names and URL path segments for the handler at that key<a id="org004fd7d"></a>### WADocumentHandler    WARequestHandler subclass: #WADocumentHandler            WADocumentHandler handles requests for images,     text documents and     binary files (byte arrays).     This class is not normally used directly.     A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler.     Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document,     registers the handler with a Registry,     and adds the correct url in the tag for the document.        Instance Variables:    	document	<WAMimeDocument>	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.<a id="org262b405"></a>### WAFileHandler    WARequestHandler subclass: #WAFileHandler            Seaside serves static files using WAFileLibrary subclasses.     WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server.     WAFileHandler is registered with the default WADispatcher automatically.<a id="org4d0958d"></a>### WALegacyRedirectionHandler    WARequestHandler subclass: #WALegacyRedirectionHandler        I provide compatibility with old Seaside URLs that have Seaside in the path (eg. '/seaside/examples/counter') by simply removing it.<a id="org6fa98b3"></a>### WANextUnconsumedPathElementRequestHandler    WARequestHandler subclass: #WANextUnconsumedPathElementRequestHandler            :nocomment:<a id="org4a67929"></a>### WARegistry    WARequestHandler subclass: #WARegistry        WARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd.     WARegistry checks incoming request URLs for a key and looks for a matching active request handler.     If one exists, the request is sent to the proper handler.     If not, the request is either a new request (in which case #handleDefaultRequest: is called)     or a request to a now-inactive handler (in which case #handleExpiredRequest: is called).         These two methods allow subclasses to properly handle these requests.        Subclasses must implement the following messages:    	handleDefaultRequest:    		Handle a request without a session key, ie a new request.    	handlerField    		The URL parameter in which to store the request handler key.        Instance Variables:    	cache - an instance of WACache to hold the stored request handlers<a id="org63d6bb9"></a>### WAApplication         WARegistry subclass: #WAApplication            WAApplication is the starting point for a Seaside application.         When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher.   (explore: WADispatcher default)        The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application.         "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)    If you change the cache configuration  you need to send #initializeCache for the changes to take effect.        "libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.        Registering an Application.    	An application can be registered with a dispatcher by using the Seaside configuration page or via code.     Below MyComponent is a subclass of WAComponent.     The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration.         MyComponent class>>initialize    	"self initialize"    	| application |    	application := self registerAsApplication: 'sample'.    	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.    	application addLibrary: SampleLibrary.    	application configuration addAncestor: GlorpConfiguration new.    	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.    	application preferenceAt: #databaseServer put: '127.0.0.1'.    	application preferenceAt: #databaseConnectString put: 'glorptests'.        MyComponent>>someInstanceMethod    	"example of how to access attributes (preferences)"    	self session application preferenceAt: #glorpDatabasePlatform<a id="org377fea8"></a>### WARedirectingApplication    WAApplication subclass: #WARedirectingApplication        I revert to the old < 3.3.0 behavior which is easier for tests.<a id="org0af584b"></a>### WARedirectingRegistry    WARegistry subclass: #WARedirectingRegistry        I revert to the old < 3.3.0 behavior which is easier for tests.<a id="orgb88453f"></a>### WARestfulHandler    WARequestHandler subclass: #WARestfulHandler        :nocomment:<a id="orga0a345f"></a>### WACORSResourceExample    WARestfulHandler subclass: #WACORSResourceExample        :nocomment:<a id="org96e6d00"></a>### WASession        WARequestHandler subclass: #WASession        I am a Seaside session.     A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.        This class is intended to be subclasses by applications that need global state, like a user.         Custom state can be added by creating instance variables and storing it there.         The session can be retrieved by #session if inside a component or task or by evaluating: WACurrentRequestContext session        If the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system.         To manually expire a session call #expire.        A good way to clear all sessions is the following code:        WARegistry clearAllHandlers.    WAPlatform current garbageCollect<a id="org0e64f62"></a>### WAExpirySession    WASession subclass: #WAExpirySession        :nocomment:<a id="orgd717788"></a>### WASessionCookieProtectedSession    WASession subclass: #WASessionCookieProtectedSession            I am a session with a WASessionCookieProtectionFilter.        provide a link here<a id="orgdf2bc7b"></a>### WATestSession    WASession subclass: #WATestSession        :nocomment:<a id="org0a9bec4"></a>### WASessionContinuation        WARequestHandler subclass: #WASessionContinuation            I represent a continuation as part of the flow of pages within a session.         I am not a real continuation (as compared to those used in #call: and #answer:),         I only represent a specific point in the session.         I reference the root component and a memory snapshot of backtracked objects.<a id="orgf370d31"></a>### WANullSessionContinuation    WASessionContinuation subclass: #WANullSessionContinuation        :nocomment:<a id="org12dcafe"></a>### WARenderLoopContinuation    WASessionContinuation subclass: #WARenderLoopContinuation            :nocomment:<a id="orged63806"></a>### WAActionPhaseContinuation    WARenderLoopContinuation subclass: #WAActionPhaseContinuation        :nocomment:<a id="org707ab6d"></a>### WACallbackProcessingActionContinuation        WAActionPhaseContinuation subclass: #WACallbackProcessingActionContinuation            :nocomment:<a id="org1f860d6"></a>### WAInitialRenderLoopContinuation        WAActionPhaseContinuation subclass: #WAInitialRenderLoopContinuation        I'm the initial continuation of a render loop.     I just render the initial page.     Subclasses may want to override #shouldRedirect and answer true so that a redirect happens before displaying the first page.<a id="org448ff20"></a>### WAPluggableActionContinuation    WAActionPhaseContinuation subclass: #WAPluggableActionContinuation            This continuation executes an action (any class that implements #value or #value:).         If possible, the renderContext is passed in as an argument.         When the action is complete, if a response hasn't been returned, control is passed to a render continuation.'        Instance Variables:    	action	<BlockClosure | BlockContext | GRDelayedSend | MessageSend | WAContinuation | WAPartialContinuation>        :important:<a id="org029b157"></a>### WARenderPhaseContinuation    WARenderLoopContinuation subclass: #WARenderPhaseContinuation        :nocomment:<a id="org31e6857"></a>### WAFlushingRenderPhaseContinuation    WARenderPhaseContinuation subclass: #WAFlushingRenderPhaseContinuation        :nocomment:<a id="org72a7a16"></a>### WATestNoopRequestHandler    WARequestHandler subclass: #WATestNoopRequestHandler        :nocomment:<a id="org81020da"></a>### WATestNoopSessionHandler    WARequestHandler subclass: #WATestNoopSessionHandler        :nocomment:<a id="org3820cc4"></a>## Response<a id="orgfe5f7ba"></a>### WAResponse                WAObject subclass: #WAResponse . I have children                A WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.    See class side initialize protocol for all the responses from the server.<a id="org64bd9e9"></a>### WABufferedResponse                WAObject subclass: #WAResponse subclass: WABufferedResponse            A WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.        Instance Variables    	contentsStream:		<WriteStream> The contents of this message.            Basically a wrapper on a stream that obtains its headers from the parent.<a id="org0a791d7"></a>### WAComboResponse                WAObject subclass: #WAResponse subclass: WAComboResponse        WAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:        renderContentOn: aCanvas    	"Render the search page"        	self renderSearchLabelOn: aCanvas.    	self requestContext request flush. "flush before starting search to give immediate feedback"        	self searchResultsDo: [ :result |    		self renderSearchResult: result on: aCanvas.    		self requestContext request flush "flush after each search result" ]        After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.        Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.        on the TODO, I will investigate this more, later<a id="org4ad3dd5"></a>### WAStreamedResponse    WAObject subclass: #WAResponse subclass: WAStreamedResponse        A WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.        Instance Variables    	committed:		<Boolean>	Whether the status and header was written to the stream.    	externalStream:		<WriteStream>	The external stream to write to.<a id="org9314086"></a>## Root<a id="org1fc991e"></a>### WARoot    WAObject subclass: #WARoot            A WARoot is the root of a document.         It is responsible to generate header and footer of a document.<a id="org5d18534"></a>### WAHtmlRoot        WARoot subclass: #WAHtmlRoot            A WAHtmlRoot is the root element of an HTML Document (<html>).        Instance Variables    	bodyAttrs:		<WAHtmlAttributes>    	context:			<WARenderContext>    	docType:		<String>    	headAttrs:		<WAHtmlAttributes>    	headElements:	<OrderedCollection<WAHtmlElement>>    	htmlAttrs:		<WAHtmlAttributes>    	scripts:			<Set<String>>    	styles:			<Set<String>>    	title:			<String>        bodyAttrs    	- the attributes of the <body> element        context    	- the context used to render the contents of the <body> element        docType    	- the document type        headAttrs    	- the attributes of the <head> element        headElements    	- the elements inside the <head> section        htmlAttrs    	- the attributes of the <html> element        scripts    	- contains the strings returned by WAPresenter >> #script        styles    	- contains the strings returned by WAPresenter >> #style        title    	- the title of the HTML document, the contents of the <title> element                writeHeadOn: aDocument    	aDocument nextPutAll: docType.    	aDocument openTag: 'html' attributes: htmlAttrs.    	aDocument openTag: 'head' attributes: headAttrs.    	self writeElementsOn: aDocument.    	self writeStylesOn: aDocument.    	self writeScriptsOn: aDocument.    	aDocument closeTag: 'head'.    	aDocument openTag: 'body' attributes: bodyAttrs<a id="orgcfb0f87"></a>### WAXmlRoot        WARoot subclass: #WAXmlRoot        No comment.        writePreambleOn: aDocument    	aDocument nextPutAll: '<?xml version="1.0" encoding="'; nextPutAll: self charSet; nextPutAll: '"?>'<a id="orgba8fd3f"></a>## Server<a id="orgdd0af9b"></a>### WAServerAdaptor    A WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol:     - #codec     - #usesSmalltalkEncoding        Instance Variables    	codec:		<WACodec>        codec    	- the codec used for response conversion from characters to bytes<a id="org63422f8"></a>### WATestServerAdapator    WAServerAdaptor subclass: #WATestServerAdaptor    A WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager<a id="org1333ded"></a>### WAWebServerAdaptor    WAServerAdaptor subclass: #WAWebServerAdaptor                What does this thing do?    It holds     a reference to its WAServerManager    a port    a requestHandler    a codec    a server of class WebServer from WebClient-Core in squeak    a certName<a id="orge2c907e"></a>### WAServerManager    A server manager cares on the available Seaside server adopters<a id="org2d15673"></a>### WebServer    Not a part of Seaside in Squeak, but part of WebClient-Core    I wonder if other WebClient-Core classes are used within the WA framework...            WebClient provides a simple yet complete HTTP server implementation.        To view the documentation evaluate:        	HelpBrowser openOn: WebServerHelp.            Does Pharo use a different class?<a id="orgf7ebd03"></a>## Visitor<a id="org1d6ba0b"></a>### WAVisitor    WAObject subclass: #WAVisitor        Common superclass for all visitors (visitor pattern)<a id="orgbabbc3f"></a>### WAAttributeVisitor    WAVisitor subclass: #WAAttributeVisitor        A visitor of attributes<a id="org901457b"></a>### WAUserConfigurationEditorVisitor    WAAttributeVisitor subclass: #WAUserConfigurationEditorVisitor<a id="org8e63581"></a>## HOWTO    an assortment of howtos follows<a id="org9050bcc"></a>### Clear Sessions    To manually expire a session call #expire.        A good way to clear all sessions is the following code:        WARegistry clearAllHandlers.    WAPlatform current garbageCollect<a id="orgf32692d"></a>## Followup    Update Doc to handle TAGS and ignore #Startup etc.    Squeak uses WebServer, does Pharo use Kom thing?    Get examples/strategies/use-cases of WAExpiringCache    see if we can hack Seaside using examples from:         https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration        Write a mockups of     WAComboResponse    WAStreamedResponse        get a sense of the things WAVisitor children do.<a id="org27a50b6"></a>## Bibliography    https://github.com/seasidest        https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration<a id="org0cc8dd2"></a>## Todo below here<a id="orgb038154"></a>### Builder<a id="org23c01dd"></a>### Error<a id="org54c2fcf"></a>### WAError        GRError subclass: #WAError        Common superclass for Seaside errors<a id="org67a07b9"></a>### WAAuthConfigurationError    WAError subclass: #WAAuthConfigurationError        A WAAuthConfigurationError is signaled when no WAAuthConfiguration was added to an application that is behind a WAAuthenticationFilter.<a id="org14a267b"></a>### GRPlatform<a id="orgec8d62a"></a>### GRPharoPlatform    GRPlatform subclass: #GRPharoPlatform        A GRPharoPlatform is the Pharo implementation of GRPlatform, the Grease class that provides functionality that can not be implemented in a platform independent way.<a id="orgfe5079d"></a>### GRSqueakPlatform    GRPharoPlatform subclass: #GRSqueakPlatform<a id="orga0fcf25"></a>### Transient Value Holder<a id="org7b6d962"></a>### WAValueHolder    WAObject subclass: #WAValueHolder        I wrap a single object.     I am like value holder except that I am portable and don't include the Model cruft in Squeak.<a id="orgbf3be29"></a>### WADynamic Variable<a id="org9efa76f"></a>### WAKeyGenerator<a id="orgd1205ad"></a>### WAMutex<a id="orgf7ac1da"></a>### WACookie                I represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.    You can never trust information in a cookie, the client is free to edit it.    I model only a part of the full cookie specification.        Browser support:    http://www.mnot.net/blog/2006/10/27/cookie_fun        Netscape spec    http://cgi.netscape.com/newsref/std/cookie_spec.html        Cookie spec    http://tools.ietf.org/html/rfc2109        Cookie 2 spec    https://tools.ietf.org/html/rfc6265        HttpOnly    http://msdn2.microsoft.com/en-us/library/ms533046.aspx    https://bugzilla.mozilla.org/show_bug.cgi?id=178993        Compared to WARequestCookie I represent the information that is sent to the user agent.<a id="orgf592f01"></a>### WARequestCookie    A WARequestCookie is the cookie the user agent sent to the server.        Instance Variables    	domain:			<String>    	key:			<String>    	path:			<String>    	pathEncoded:	<String>    	ports:			<Collection<Integer>>    	value:			<String>    	version:			<Integer>        domain    	- xxxxx        key    	- xxxxx        path    	- According to https://tools.ietf.org/html/rfc6265#section-5.1.4 user-agents must use an algorithm equivalent to the following one:      1.  Let uri-path be the path portion of the request-uri if such a           portion exists (and empty otherwise).  For example, if the           request-uri contains just a path (and optional query string),           then the uri-path is that path (without the %x3F ("?") character           or query string), and if the request-uri contains a full           absoluteURI, the uri-path is the path component of that URI.           2.  If the uri-path is empty or if the first character of the uri-           path is not a %x2F ("/") character, output %x2F ("/") and skip           the remaining steps.           3.  If the uri-path contains no more than one %x2F ("/") character,           output %x2F ("/") and skip the remaining step.           4.  Output the characters of the uri-path from the first character up           to, but not including, the right-most %x2F ("/").        ports    	- xxxxx        value    	- xxxxx        version    	- the version of the cookie specification supported, currently only 1 is known<a id="org01eb69a"></a>### WAMergedRequestFields        Provides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.