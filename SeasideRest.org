*  SeasideRest#+STARTUP: content align#+FILETAGS: :programming:#+TAGS:pharo:squeak:nocomment:important:** Introduction #+BEGIN_EXAMPLEI am separating out the REST from Seaside notes.I will probably do the same for Javascript stuff too.#+END_EXAMPLE** Todo#+BEGIN_EXAMPLEDocument the uncommented stuff like WAMatch#+END_EXAMPLE** REST Handler#+BEGIN_EXAMPLEinitial collectin from the Seaide-REST-Core-Handler category#+END_EXAMPLE*** WARestfulConfiguration#+BEGIN_EXAMPLEWASystemConfiguration subclass: #WARestfulConfigurationA WARestfulConfiguration is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WARestfulFilter#+BEGIN_EXAMPLEWARequestFilter subclass: #WARestfulFilterA WARestfulFilter is xxxxxxxxx.Instance Variables	routes:		<Object>routes	- xxxxx#+END_EXAMPLE*** WARestfulComponentFilter#+BEGIN_EXAMPLEWARestfulFilter subclass: #WARestfulComponentFilterI allow mixing stateless and stateful Seaside application. I am intended for cases where there are a couple of stateless "browse" pages before sateful application pages that require a session. If a request comes in and has a session it gets dispatched to the application, otherwise it's treated as a normal REST request.At any time session can be started from an initialized component by sending #startSessionWithRoot:.To use me:- subclass me- add me to your application- implement the methods for the URL patterns you need- send #startSessionWithRoot: in your methodsI am the fault of Norbert.#+END_EXAMPLE*** WARestfulHandler#+BEGIN_EXAMPLEWARequestHandler subclass: #WARestfulHandlerA WARestfulHandler is xxxxxxxxx.Instance Variables	routes:		<Object>routes	- xxxxx#+END_EXAMPLE** Route*** WARoute#+BEGIN_EXAMPLEWAObject subclass: #WARouteI am a message that can be sent if I match a request. Message arguments can be taken from the request.Instance Variables:	method		<String>	selector	<Symbol>	produces 	<WAMatch>	consumes 	<WAMatch>		method	- The HTTP method on which to follow this route, eg. 'GET'selector	- The selector to perform, eg. #index	produces	- The MIME type this route produces (Content-Type HTTP header)	consumes	- The MIME type this route accepts (Accept HTTP header)#+END_EXAMPLE*** WAComplexRoute#+BEGIN_EXAMPLEWARoute subclass: #WAComplexRouteA WAComplexRoute is xxxxxxxxx.Instance Variables	isOverlyComplex:		<Object>	parameterMatches:		<Object>	pathMatches:		<Object>isOverlyComplex	- xxxxxparameterMatches	- xxxxxpathMatches	- xxxxx#+END_EXAMPLE*** WASimpleRoute#+BEGIN_EXAMPLEWARoute subclass: #WASimpleRouteI match only on an exact number of path elements and no URL parameters. The path elements are turned into message arguments.Instance Variables:	count	<Integer>		count	- The exact number of path elements that have to be present.#+END_EXAMPLE*** WARouteBuilder#+BEGIN_EXAMPLEWAObject subclass: #WARouteBuilderI am a builder for building WARoute instances from a CompiledMethod.Instance Variables:	compiled	<CompiledMethod>	method		<String>	path		<String>	produces	<WAWildcardMimeTypeMatch|WAMimeTypeMatch>	consumes	<Collection<WAWildcardMimeTypeMatch|WAMimeTypeMatch>>Class Instance Variables:	configuration	<Collection>#+END_EXAMPLE*** WARouteContainer#+BEGIN_EXAMPLEWAObject subclass: #WARouteContainerA WARouteContainer is a collection of routes that all accept the same number of path elements ordered by priority.Instance Variables	pathElementCount:		<Integer>	routes:		<SortedCollection<WARoute>>pathElementCount	- the number of path elements that any of the routes in this container acceptsroutes	- the routes ordered by priority#+END_EXAMPLE*** WARouteResult#+BEGIN_EXAMPLEWAObject subclass: #WARouteResultI am the result of a route look up. I contain all the information required to "execute" the result.Instance Variables:	route	<WARoute>	elements	<Collection<String>>	parameters	<WARequestFields>		route	the found route	elements	the unconsumed path elements of the request	parameters	the query fields of the request#+END_EXAMPLE*** WASortedAccepts#+BEGIN_EXAMPLEWAObject subclass: #WASortedAcceptsA WASortedAccepts is xxxxxxxxx.Instance Variables	accepts:		<Object>accepts	- xxxxx#+END_EXAMPLE** Match*** WAMatch#+BEGIN_EXAMPLEWAObject subclass: #WAMatchA WAMatch is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WACompositeMimeTypeMatch#+BEGIN_EXAMPLEWAMatch subclass: #WACompositeMimeTypeMatchA WACompositeMimeTypeMatch is xxxxxxxxx.Instance Variables	matches:		<Object>matches	- xxxxx#+END_EXAMPLE*** WAMimeTypeMatch#+BEGIN_EXAMPLEWAMatch subclass: #WAMimeTypeMatchA WAMimeTypeMatch is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAFullMimeTypeMatch#+BEGIN_EXAMPLEWAMimeTypeMatch subclass: #WAFullMimeTypeMatchA WAFullMimeTypeMatch is xxxxxxxxx.Instance Variables	main:		<Object>	sub:		<Object>main	- xxxxxsub	- xxxxx#+END_EXAMPLE*** WAMainMimeTypeMatch#+BEGIN_EXAMPLEWAMimeTypeMatch subclass: #WAMainMimeTypeMatchA WAMainMimeTypeMatch is xxxxxxxxx.Instance Variables	main:		<Object>main	- xxxxx#+END_EXAMPLE*** WASubMimeTypeMatch#+BEGIN_EXAMPLEWAMimeTypeMatch subclass: #WASubMimeTypeMatchA WASubMimeTypeMatch is xxxxxxxxx.Instance Variables	sub:		<Object>sub	- xxxxx#+END_EXAMPLE*** WAWildcardMimeTypeMatch#+BEGIN_EXAMPLEWAMimeTypeMatch subclass: #WAWildcardMimeTypeMatchA WAWildcardMimeTypeMatch is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAPPathMatch#+BEGIN_EXAMPLEWAMatch subclass: #WAPPathMatchA WAPPathMatch is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAExactPathMatch#+BEGIN_EXAMPLEWAPPathMatch subclass: #WAExactPathMatchA WAExactPathMatch is xxxxxxxxx.Instance Variables	element:		<Object>element	- xxxxx#+END_EXAMPLE*** WAOrPathMatch#+BEGIN_EXAMPLEWAPPathMatch subclass: #WAOrPathMatch#+END_EXAMPLE*** WAPlaceholderPathMatch#+BEGIN_EXAMPLEWAPPathMatch subclass: #WAPlaceholderPathMatchA WAPlaceholderPathMatch is xxxxxxxxx.Instance Variables	sourceIndex:		<Object>	targetIndex:		<Object>sourceIndex	- xxxxxtargetIndex	- xxxxx#+END_EXAMPLE*** WAFullPlaceholderPathMatch#+BEGIN_EXAMPLEWAPlaceholderPathMatch subclass: #WAFullPlaceholderPathMatchA WAFullPlaceholderPathMatch is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAMultiPlaceholderPathMatch#+BEGIN_EXAMPLEWAPlaceholderPathMatch subclass: #WAMultiPlaceholderPathMatchA WAMultiPlaceholderPathMatch is xxxxxxxxx.Instance Variables#+END_EXAMPLE*** WAPrefixPlaceholderPathMatch#+BEGIN_EXAMPLEWAPlaceholderPathMatch subclass: #WAPrefixPlaceholderPathMatchA WAPrefixPlaceholderPathMatch is xxxxxxxxx.Instance Variables	prefix:		<Object>prefix	- xxxxx#+END_EXAMPLE*** WASuffixPlaceholderPathMatch#+BEGIN_EXAMPLEWAPlaceholderPathMatch subclass: #WASuffixPlaceholderPathMatchA WASuffixPlaceholderPathMatch is xxxxxxxxx.Instance Variables	suffix:		<Object>suffix	- xxxxx#+END_EXAMPLE*** WAParameterMatch#+BEGIN_EXAMPLEWAMatch subclass: #WAParameterMatchA WAParameterMatch is xxxxxxxxx.Instance Variables	name:		<Object>name	- xxxxx#+END_EXAMPLE*** WAExactParameterMatch#+BEGIN_EXAMPLEWAParameterMatch subclass: #WAExactParameterMatchA WAExactParameterMatch is xxxxxxxxx.Instance Variables	value:		<Object>value	- xxxxx#+END_EXAMPLE*** WAPlaceholderParameterMatch#+BEGIN_EXAMPLEWAParameterMatch subclass: #WAPlaceholderParameterMatchA WAPlaceholderParameterMatch is xxxxxxxxx.Instance Variables	index:		<Object>index	- xxxxx#+END_EXAMPLE** Bibliography#+BEGIN_EXAMPLE  https://github.com/gettimothy/Doc-Seaside  https://restfulapi.net/#+END_EXAMPLE